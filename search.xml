<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>扩散模型(Diffusion Model)原理详解</title>
      <link href="/2025/02/19/computervision/kuo-san-mo-xing-diffusion-model-yuan-li-xiang-jie/"/>
      <url>/2025/02/19/computervision/kuo-san-mo-xing-diffusion-model-yuan-li-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1><span id="diffusionmodel的基本原理ddpm">DiffusionModel的基本原理(DDPM)</span></h1><p>Denoising Diffusion Probabilistic Models(DDPM)在流程上分为两个步骤 -Forward (diffusion) process: 在输入的数据上逐步的增加噪声 - Backward(denoising) process: 在噪声图上进行降噪，从噪声中恢复出原来的图像</p><span id="more"></span><figure><img src="https://s2.loli.net/2024/05/06/wMiEscWqSGf2zrb.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h2><span id="diffusion-process">Diffusion Process</span></h2><p>DiffusionProcess是在原始数据的基础上逐步增加噪声，通过超参数迭代次数<span class="math inline">\(T\)</span>和variance schedule <span class="math inline">\(\beta_{t} \in (0,1)\)</span>控制。因此，有以下条件概率 <span class="math display">\[q(\mathbf{x}_{t}| \mathbf{x}_{t-1})=\mathcal{N}(\mathbf{x}_{t} |\sqrt{1-\beta_{t}}\mathbf{x}_{t-1},\beta_{t} \mathbf{I})\]</span> 其中variance schedule满足 <span class="math display">\[0 &lt; \beta_{1} &lt; \beta_{2} &lt; \cdots &lt; \beta_{T} &lt; 1\]</span> 这里采样时候需要采用ReparameterizationTrick，因为采样是无法进行反向传播的。所以引入一个新的变量<span class="math inline">\(\epsilon\)</span>将随机性和传播过程分离开 <span class="math display">\[\begin{align*}\mathcal{N}(\mu,\sigma^{2})&amp;= \mu+\sigma \cdot \epsilon\\\epsilon &amp;\sim \mathcal{N}(0, \mathbf{I})\end{align*}\]</span> 所以，diffusion每一步增加噪声可以按照如下操作 <span class="math display">\[\mathbf{x}_{t}=\sqrt{1-\beta_{t}} \mathbf{x}_{t-1} + \sqrt{\beta_{t}}\epsilon\]</span> 由于diffusionprocess是确定的，在实际过程中并不需要进行每一步迭代，可以直接计算出从原始数据到迭代<span class="math inline">\(T\)</span>步后的结果</p><figure><img src="https://s2.loli.net/2024/05/06/k7jxUXSfrqPeb3m.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>从上面的条件概率中，可以得到diffusion process的closed form <span class="math display">\[\begin{align*}\mathbf{x}_{t} &amp;= \sqrt{\bar{\alpha_{t}}}\mathbf{x}_{0} +\sqrt{1-\bar{\alpha}_{t}} \epsilon\\\alpha_{t} &amp;= 1-\beta_{t}\\\bar{\alpha}_{t} &amp;= \prod_{i=1}^{t} \alpha_{i}\\\epsilon &amp;\sim \mathcal{N}(0, \mathbf{I})\end{align*}\]</span></p><h2><span id="denoise-process">Denoise Process</span></h2><p>Denoiseprocess是从噪声图中移除噪声来恢复原图。这个过程需要我们知道概率分布<span class="math inline">\(q(\mathbf{x}_{t-1} |\mathbf{x}_{t})\)</span>，也就是从某一时刻的数据反推上一时刻的数据，进行多次迭代后恢复最初的数据<span class="math inline">\(\mathbf{x}_{0}\)</span>。根据Bayes Rule， <span class="math display">\[q(\mathbf{x}_{t-1}|\mathbf{x}_{t})=q(\mathbf{x}_{t}|\mathbf{x}_{t-1})\frac{q(\mathbf{x}_{t-1})}{q(\mathbf{x}_{t})}\]</span> 其中 <span class="math inline">\(q(\mathbf{x}_{t})=\intq(\mathbf{x}_{t} | \mathbf{x}_{0}) q(\mathbf{x}_{0}) \mathrm{d}\mathbf{x}_{0}\)</span>，但是这一项积分是无法计算的。因此，DDPM采用了神经网络去学习一个模型<span class="math inline">\(p_{\theta}(\mathbf{x}_{t-1} |\mathbf{x}_{t})\)</span> 近似估计<span class="math inline">\(q(\mathbf{x}_{t-1} | \mathbf{x}_{t},\mathbf{x}_{0})\)</span>。通过推导，可以得到 <span class="math inline">\(q(\mathbf{x}_{t-1} | \mathbf{x}_{t},\mathbf{x}_{0})\)</span> 也是一个高斯分布，并且高斯分布的均值和方差如下<span class="math display">\[\begin{align*}\boldsymbol{\mu}_q(\boldsymbol{x}_t, \boldsymbol{x}_0) &amp;=\frac{\sqrt{\alpha_t}(1 - \bar{\alpha}_{t-1})\boldsymbol{x}_t +\sqrt{\bar{\alpha}_{t-1}}(1 - \alpha_t)\boldsymbol{x}_0}{1 -\bar{\alpha}_t} \\\sigma_q^2 &amp;= \frac{(1 - \alpha_t)(1 - \bar{\alpha}_{t-1})}{1 -\bar{\alpha}_t}\end{align*}\]</span> 更进一步的将 <span class="math inline">\(x_0 =\frac{1}{\sqrt{a_t}} \left( x_t - \sqrt{1 - \bar{a}_t} \epsilon\right)\)</span> 带入，可以得到 <span class="math display">\[\mu_q(x_t, x_0) = \frac{1}{\sqrt{\alpha_t}} x_t - \frac{1 -\alpha_t}{\sqrt{1 - \bar{\alpha}_t} \sqrt{\alpha_t}} \epsilon\]</span> 个人对为什么用<span class="math inline">\(p_{\theta}(\mathbf{x}_{t-1} |\mathbf{x}_{t})\)</span>拟合<span class="math inline">\(q(\mathbf{x}_{t-1} | \mathbf{x}_{t},\mathbf{x}_{0})\)</span>的理解是，当有原始数据和最终的噪声结果的时候，降噪过程是可以计算得到的。但是inference的过程中我们显然是不知道原始数据的，所以希望通过神经网络从原始数据中学习一个采样分布近似的拟合。具体的，给定加噪后的结果<span class="math inline">\(x_{t}\)</span>和时间步长<span class="math inline">\(t\)</span>，用网络预测从<span class="math inline">\(x_{0}\)</span>到<span class="math inline">\(x_{t}\)</span>过程中添加的噪声<span class="math inline">\(\epsilon(x_{t},t)\)</span>，预测噪声同时也等价于预测原始图像<span class="math inline">\(x_{0}\)</span>，有了<span class="math inline">\(x_{0}\)</span>就可以用<span class="math inline">\(q(\mathbf{x}_{t-1} | \mathbf{x}_{t},\mathbf{x}_{0})\)</span>进行采样。 <span class="math display">\[p_{\theta}(x_{t-1} | x_{t}) = \mathcal{N}(x_{t-1}; \mu_{\theta}(x_{t},t), \sigma_t I) \approx q(x_{t-1} | x_{t}, x_0)\]</span></p><h2><span id="training-process">Training Process</span></h2><p>DDPM的损失函数类似于VAE，使用了ELBO的方法，完整推导参见<a href="https://arxiv.org/pdf/2208.11970">Understanding Diffusion Models:A Unified Perspective</a></p><figure><img src="https://s2.loli.net/2025/02/01/USZLYBskHTh92NQ.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p><span class="math display">\[\begin{align*}\log p(\boldsymbol{x}) \geq&amp; \mathbb{E}_q(\boldsymbol{x}_{1:T} |\boldsymbol{x}_0) \left[ \log\frac{p(\boldsymbol{x}_{0:T})}{q(\boldsymbol{x}_{1:T} |\boldsymbol{x}_0)} \right] \\=&amp;\underbrace{\mathbb{E}_{q\left(\boldsymbol{x}_1 \mid\boldsymbol{x}_0\right)}\left[\logp_{\boldsymbol{\theta}}\left(\boldsymbol{x}_0 \mid\boldsymbol{x}_1\right)\right]}_{\text {reconstruction term}}-\underbrace{D_{\mathrm{KL}}\left(q\left(\boldsymbol{x}_T \mid\boldsymbol{x}_0\right) \| p\left(\boldsymbol{x}_T\right)\right)}_{\text{prior matching term }}\\&amp;-\sum_{t=2}^T \underbrace{\mathbb{E}_{q\left(\boldsymbol{x}_t \mid\boldsymbol{x}_0\right)}\left[D_{\mathrm{KL}}\left(q\left(\boldsymbol{x}_{t-1}\mid \boldsymbol{x}_t, \boldsymbol{x}_0\right) \|p_{\boldsymbol{\theta}}\left(\boldsymbol{x}_{t-1} \mid\boldsymbol{x}_t\right)\right)\right]}_{\text {denoising matching term}}\end{align*}\]</span></p><ul><li>Reconstruction term: <span class="math inline">\(\mathbb{E}_{q\left(\boldsymbol{x}_1 \mid\boldsymbol{x}_0\right)}\left[\logp_{\boldsymbol{\theta}}\left(\boldsymbol{x}_0 \mid\boldsymbol{x}_1\right)\right]\)</span></li><li>Prior matching term: <span class="math inline">\(D_{\mathrm{KL}}\left(q\left(\boldsymbol{x}_T \mid\boldsymbol{x}_0\right) \|p\left(\boldsymbol{x}_T\right)\right)\)</span></li><li>Denoising matching term: <span class="math inline">\(\mathbb{E}_{q\left(\boldsymbol{x}_t \mid\boldsymbol{x}_0\right)}\left[D_{\mathrm{KL}}\left(q\left(\boldsymbol{x}_{t-1}\mid \boldsymbol{x}_t, \boldsymbol{x}_0\right) \|p_{\boldsymbol{\theta}}\left(\boldsymbol{x}_{t-1} \mid\boldsymbol{x}_t\right)\right)\right]\)</span></li></ul><p>注意到这里reconstruction term和prior matching term实际上就是VAEloss，由于这两项是在diffusionprocess中没有任何网络参数参与，所以可以看作是常数忽略不计。</p><p>由于<span class="math inline">\(q\left(\boldsymbol{x}_{t-1} \mid\boldsymbol{x}_t, \boldsymbol{x}_0\right)\)</span>和<span class="math inline">\(p_{\boldsymbol{\theta}}\left(\boldsymbol{x}_{t-1}\mid \boldsymbol{x}_t\right)\)</span> 都是高斯分布，所以denoisingmatching term可以实际上转化为 <span class="math display">\[\arg \min_{\theta} D_{KL}(q(x_{t-1}|x_t, x_0) \parallelp_\theta(x_{t-1}|x_t)) = \arg \min_{\theta} \frac{1}{2\sigma_q^2(t)}\left[ \| \mu_\theta - \mu_q \|_2^2 \right]\]</span> <span class="math inline">\(\mu_{q}\)</span>在之前已经推导过了，同样的我们可以把模型预测的高斯参数<span class="math inline">\(\mu_{\theta}\)</span>写作 <span class="math display">\[\mu_\theta(x_t, t) = \frac{1}{\sqrt{\alpha_t}} x_t - \frac{1 -\alpha_t}{\sqrt{1 - \bar{\alpha}_t} \sqrt{\alpha_t}}\hat\epsilon(x_{t},t)\]</span> 其中<span class="math inline">\(\hat\epsilon(x_{t},t)\)</span>是模型预测的噪声，因此最终的损失函数就变成了匹配随机生成的噪声和模型预测的噪声<span class="math inline">\(\|\epsilon-\epsilon_{\theta}(\sqrt{\bar{\alpha}_{t}}\mathbf{x}_{0}+\sqrt{1-\bar{\alpha}_{t}}\epsilon,t)\|\)</span>。</p><figure><img src="https://s2.loli.net/2025/01/26/vzLjD5mJ6ZMIRnP.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h2><span id="network-architecture">Network Architecture</span></h2><p>Diffusion Model目前常见的网络结构主要采用了U-Net +Attention的结构</p><figure><img src="https://s2.loli.net/2024/05/06/2rOQx3Hl7kqVGEs.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h1><span id="denosing-diffusionimplicit-model-ddim">Denosing DiffusionImplicit Model (DDIM)</span></h1><p>DDPM存在的一个问题是需要设置比较长的扩散步长才能得到比较好的生成结果，因此生成的速度比较慢。DDIM通过解除DDPM中扩散过程的马尔可夫链的限制，用非马尔可夫过程进行生成，大大提高了DDPM的生成效率。</p><p>DDIM注意到了DDPM中的一个问题，就是噪声生成的过程<span class="math inline">\(q(x_{t} | x_{0})\)</span>实际上只用了marginaldistribution并没有用到join distribution <span class="math inline">\(q(x_{1:T}|x_{0})\)</span>，也就是给定<span class="math inline">\(x_0\)</span>和时间<span class="math inline">\(t\)</span>，加噪的过程实际上是确定的 <span class="math display">\[q(\mathbf{x}_{t} | \mathbf{x}_{0}) = \mathcal{N}(\mathbf{x}_{t};\sqrt{\alpha_{t}}\mathbf{x_{0}}, (1-\alpha_{t}) \mathbf{I})\]</span> 因此，如果可以在将马尔科夫链限制去除的同时，能够保持<span class="math inline">\(q(x_{t}|x_0)\)</span>有着相同的概率分布，也就是对任意时间步长<span class="math inline">\(t\)</span>，使得<span class="math inline">\(q(x_{t}|x_{0})\)</span>都满足以上的概率分布。DDIM提出了以下采样概率分布 <span class="math display">\[\begin{align*}q_{\sigma}(x_{t-1}|x_t,x_0) = \mathcal{N}\left(  \sqrt{\alpha_{t-1}}x_0 + \sqrt{1 - \alpha_{t-1} - \sigma_t^2} \cdot\frac{x_t - \sqrt{\alpha_t}x_0}{\sqrt{1 - \alpha_t}}, \  \sigma_{t}^2I\right). \tag{1}\end{align*}\]</span> 其中这里的符号<span class="math inline">\(\alpha_{t}\)</span>就是DDPM中的<span class="math inline">\(\bar \alpha\)</span></p><h2><span id="待定系数">待定系数</span></h2><p>在DDPM中，根据贝叶斯公式，有以下结论 <span class="math display">\[p(x_{t-1} | x_{t}, x_{0})=\frac{p(x_{t} | x_{t-1}) p(x_{t-1} |x_{0})}{p(x_{t} | x_{0})}\]</span> 其中我们已知 <span class="math display">\[\begin{align*}p(x_{t} | x_{0}) &amp;= \mathcal{N}(\sqrt{\bar \alpha_{t}} x_{0},(1-\bar \alpha_{t}) \mathbf{I}) \\x_{t} &amp;= \sqrt{\bar \alpha_{t}} x_{0} + \sqrt{1 - \bar{\alpha_{t}}}\epsilon &#39;&#39;, \textbf{ where } \epsilon&#39;&#39; \sim\mathcal{N}(0, \mathbf{I}) \tag{2}\end{align*}\]</span>类似的，我们可以进行推广，将DDPM中的马尔可夫链限制去除，我们可以将 <span class="math inline">\(t-1\)</span> 和 <span class="math inline">\(t\)</span> 替换为<span class="math inline">\(s,k\)</span> 其中 <span class="math inline">\(s&lt;k\)</span>，得到 <span class="math display">\[p(x_{s} | x_{k}, x_{0})=\frac{p(x_{k} | x_{s}) p(x_{s} | x_{0})}{p(x_{k}| x_{0})}\]</span> 这里<span class="math inline">\(p(x_{s}|x_{0}),p(x_{k}|x_{0})\)</span>是已知固定的，但是<span class="math inline">\(p(x_{k}|x_{s})\)</span>是未知的。如何设定采样分布的形式呢？这里可以使用待定系数法，将<span class="math inline">\(p(x_{s}|x_{k},x_{0})\)</span>设定为和未知变量<span class="math inline">\(k,m,\alpha\)</span>有关的高斯分布 <span class="math display">\[p(x_{s}| x_{k},x_{0}) \sim \mathcal{N}(k x_{0} + m x_{k}, \sigma^{2}\mathbf{I}) \tag{3}\]</span> 重参数化并带入已知结论(2) <span class="math display">\[\begin{align*}x_{s} &amp;=  kx_{0} + m x_{k} + \alpha \epsilon&#39;\\&amp;= kx_{0} + m \left(\sqrt{\bar \alpha_{k}} x_{0} + \sqrt{1 -\bar{\alpha_{k}}} \epsilon &#39;&#39;\right) + \sigma \epsilon&#39;\\&amp;= \left(k+m \sqrt{\bar \alpha_{k}}\right)x_{0} + m\sqrt{1-\bar\alpha_{k}} \epsilon&#39;&#39; + \sigma \epsilon&#39;\end{align*}\]</span> 其中<span class="math inline">\(\epsilon&#39; \sim\mathcal{N}(0,\mathbf{I})\)</span>，所以这就是两个独立高斯分布 <span class="math inline">\(\epsilon&#39;\)</span> 和 <span class="math inline">\(\epsilon&#39;&#39;\)</span> 的和。因此<span class="math inline">\(x_{s}\)</span>满足高斯分布 <span class="math display">\[\begin{align*}x_{s} \sim \mathcal{N}\left(\left(k+m \sqrt{\bar\alpha_{k}}\right)x_{0},m^{2}(1-\bar \alpha_{k})+\sigma^{2}\right)\end{align*}\]</span> 重参数化后已知结论进行对比 <span class="math display">\[\begin{align*}x_{s} &amp;= \left(k+m\sqrt{\bar \alpha_{k}}x_{0}\right) +\sqrt{m^{2}(1-\bar \alpha_{k}) + \sigma^{2}} \epsilon \\x_{s} &amp;= \sqrt{\bar \alpha_{s}} x_{0} + \sqrt{1 - \bar \alpha_{s}}\epsilon&#39;&#39;\end{align*}\]</span> 根据待定系数得出以下两个方程 <span class="math display">\[\begin{align*}k + m \sqrt{\bar \alpha_{k}} &amp;= \sqrt{\bar \alpha_{s}}\\\sqrt{m^{2}(1-\bar \alpha_{k}) + \sigma^{2}} &amp;= \sqrt{1 - \bar\alpha_{s}}\end{align*}\]</span> 通过两个方程我们可以将<span class="math inline">\(m,k\)</span>解出 <span class="math display">\[\begin{align*}m &amp;= \sqrt{\frac{1 - \bar \alpha_{s} - \sigma^{2}}{1 - \bar\alpha_{k}}}\\k &amp;= \sqrt{\bar \alpha_{s}} - \sqrt{\frac{(1 - \bar \alpha_{s} -\sigma^{2})\bar \alpha_{k}}{1 - \bar \alpha_{k}}}\end{align*}\]</span> 带入到公式(3)中，可以得到 <span class="math display">\[p(x_{s}| x_{k},x_{0}) \sim \mathcal{N}\left(\left(\sqrt{\bar \alpha_{s}}- \sqrt{\frac{(1 - \bar \alpha_{s} - \sigma^{2})\bar \alpha_{k}}{1 -\bar \alpha_{k}}}\right) x_{0} + \sqrt{\frac{1 - \bar \alpha_{s} -\sigma^{2}}{1 - \bar \alpha_{k}}} x_{k}, \sigma^{2} \mathbf{I}\right)\tag{3}\]</span> 重新整理并让<span class="math inline">\(s=t-1,k=t\)</span>时，就可以推出公式(1)</p><p>在DDIM的附录中通过数学归纳法证明了，当使用给出的采样概率分布时，是能够满足<span class="math inline">\(q(x_{t}|x_{0})\)</span>需要的概率分布的，如下两张图所示</p><figure><img src="https://s2.loli.net/2025/02/01/jUeBrI6V3tPdy9N.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><figure><img src="https://s2.loli.net/2025/02/01/tUdTDaHVRzMgYFJ.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>这里利用了结论(2.115) <img src="https://s2.loli.net/2025/02/01/mkv8KPCtj16N2F3.png" alt="image.png"></p><h2><span id="生成过程">生成过程</span></h2><p>DDIM的生成过程和DDPM是一致的，同样是通过神经网络学习预测噪声，再通过采样分布进行采样进而迭代生成结果。DDIM论文里通过Theorem1说明了DDIM和DDPM的变分目标是一致的</p><figure><img src="https://s2.loli.net/2025/02/01/3jHcfplT29bCWPq.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>因此可以采用同样的优化目标，也就是对预测的噪声和实际的噪声进行匹配<span class="math display">\[\begin{align*}L_{\gamma}(\epsilon_\theta):= \sum_{t=1}^T \gamma_t \mathbb{E}_{\\x_0 \sim q(x_0),\epsilon_t \sim \mathcal{N}({\bf 0}, I)} \left[  \left\|    \epsilon_\theta^{(t)}\left(      \sqrt{\alpha_t}x_0 + \sqrt{1-\alpha_t}\epsilon_t    \right) - \epsilon_t  \right\|_2^2\right]\end{align*}\]</span> (注：这里开始用的都是DDIM论文中的表示，也就是<span class="math inline">\(\alpha_{t}=\bar \alpha_{t}\)</span>)所以，由于优化目标和生成过程的一致性，DDIM可以利用预训练好的DDPM模型作为优化目标的求解结果，也就是相同的噪声预测网络，只需要调整采样的过程以及参数<span class="math inline">\(\sigma\)</span>得到更好的生成过程。</p><p>通过将公式(1)进行重参数化展开，以及将<span class="math inline">\(x_{0}\)</span>替换为网络预测结果，可以得到以下采样过程<span class="math display">\[\begin{align*}\boldsymbol{x}_{t-1} = \sqrt{\alpha_{t-1}} \underbrace{\left(\frac{\boldsymbol{x}_t - \sqrt{1 - \alpha_t}\epsilon^{(t)}_{\theta}(\boldsymbol{x}_t)}{\sqrt{\alpha_t}}\right)}_{\text{&quot;predicted $\boldsymbol{x}_0$&quot;}} +\underbrace{\sqrt{1 - \alpha_{t-1} - \sigma^2_t \cdot\epsilon^{(t)}_{\theta}(\boldsymbol{x}_t)}}_{\text{&quot;directionpointing to $\boldsymbol{x}_t$&quot;}} + \underbrace{\sigma_t\epsilon_t}_{\text{random noise}}\end{align*}\]</span> 其中，当<span class="math inline">\(\sigma_t = \sqrt{\frac{1 -\alpha_{t-1}}{1 - \alpha_t}} \sqrt{1 -\frac{\alpha_t}{\alpha_{t-1}}}\)</span>时，生成过程等价于DDPM；而当<span class="math inline">\(\sigma_{t}=0\)</span>时，这时randomnoise就是0，所以生成过程就失去了随机性变成了一个确定的过程，论文中将这种情况称之为<em>denoisingdiffusion implicit model</em> (DDIM)</p><p><span class="math inline">\(\sigma_{t}\)</span>可以写成是<span class="math inline">\(\eta (\sqrt{\frac{1 - \alpha_{t-1}}{1 - \alpha_t}}\sqrt{1 - \frac{\alpha_t}{\alpha_{t-1}}})\)</span>的形式，其中<span class="math inline">\(0 \leq \eta \leq 1\)</span>用于控制生成过程</p><h2><span id="加速生成模型">加速生成模型</span></h2><p>DDIM论文提出了这样一个观点：DDPM的训练结果实质上包含了它的任意子序列参数的训练结果。因此，生成过程不需要严格遵循<span class="math inline">\((x_{T}, \cdots,x_{1})\)</span>的过程，而是可以进行跳跃步，选择其中的一个长度为<span class="math inline">\(S\)</span>的子序列<span class="math inline">\((x_{\tau_{S}},\cdots,x_{\tau_{1}})\)</span>做生成，只需要满足<span class="math display">\[q(x_{\tau_{i}} | x_{0}) =\mathcal{N}(x_{\tau_{i}};\sqrt{\alpha_{\tau_{i}}x_{0}}, (1-\alpha_{\tau_{i}}) \mathbf{I})\]</span> 如下图所示，本来生成过程是<span class="math inline">\(x_{3}\rightarrow x_{2} \rightarrow x_{1} \rightarrow x_{0}\)</span>，现在可以跳步，变成了<span class="math inline">\(x_{3}  \rightarrowx_{1} \rightarrow x_{0}\)</span></p><figure><img src="https://s2.loli.net/2025/02/01/L6X3GFI9Eh2lT1i.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><div class="note info no-icon"><h2><span id="方差选择整理ddpm-amp-ddim">📌方差选择整理(DDPM &amp; DDIM)</span></h2><p><strong>DDPM</strong> 的方差选择<a href="https://zhuanlan.zhihu.com/p/525106459">1</a>：</p><ol type="1"><li><strong><span class="math inline">\(\sigma_{t, \theta}^2 =\Sigma_{\theta}(x_t, t)\)</span></strong><ul><li>模型学习的方差（称为 <code>learned</code>）<br></li><li>实际未在 DDPM 中使用，但被 GLIDE 采用。</li></ul></li><li><strong><span class="math inline">\(\sigma_{t, s}^2 = \beta_t =\frac{1 - \alpha_{t-1}}{1 - \alpha_t} \beta_t\)</span></strong><ul><li>由公式 (8-1) 推导得出（称为 <code>fixedsmall</code>）<br></li><li>用于 <code>celebahq</code> 和 <code>lsun</code> 数据集。</li></ul></li><li><strong><span class="math inline">\(\sigma_{t, l}^2 =\beta_t\)</span></strong><ul><li>称为 <code>fixedlarge</code>，用于 <code>cifar10</code> 数据集<br></li><li>满足 <span class="math inline">\(\sigma_{t,l} &gt;\sigma_{t,s}\)</span>，即方差更大。</li></ul></li></ol><p><strong>DDIM</strong> 的方差选择： - <strong><span class="math inline">\(\sigma_t(\eta)^2 = \eta \cdot\hat{\beta}_t\)</span></strong><br>- 基于 DDPM 的 <code>fixedsmall</code> 版本，额外乘以系数 <span class="math inline">\(\eta\)</span>。</p></div><h1><span id="latent-diffusion-modelstable-diffusion">Latent Diffusion Model(Stable Diffusion)</span></h1><p>DDPM还存在一个问题，就是需要大量的计算资源。由于DDPM直接在图像空间上进行训练和推理，导致了非常耗时。LDM(Latent Diffusion Model)也就是StableDiffusion提出了一种方法，首先将图像用VAE encode为一个低分辨率的latentspace，在latent space上进行生成，然后再将latent spacedecode还原为图像空间，能够大大降低训练推理所需的计算资源。</p><p><img src="https://s2.loli.net/2024/05/06/kYpVcjCnD8HMLsU.png" alt="image.png"> <img src="https://s2.loli.net/2024/05/06/4LaDJd8OYxzNyrR.png" alt="image.png"></p><p>LDM论文观察到，DDPM模型对图像的压缩通常由perceptualcompression和semanticcompression组成。因此，LDM提出可以用Autoencoder将图像的perceptualinformation在训练中剔除掉，只让Diffusion Model对semantic的部分压缩。</p><figure><img src="https://s2.loli.net/2025/02/02/7iBW56zIRHwujoe.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>LDM采用的网络架构如下图所示，其中<span class="math inline">\(\varepsilon\)</span> 和<span class="math inline">\(\mathcal{D}\)</span>分别是预训练好的Autoencoder中的Encoder和Decoder。通过Encoder首先将图片进行perceptualcompression得到latent space <span class="math inline">\(z\)</span>，然后在latent space通过diffutionprocess进行加噪。Denoise process采用了带有Attention的UNet架构，通过CrossAttention注入conditioning信息。</p><figure><img src="https://s2.loli.net/2025/02/02/dVxjIQYXLRefzU9.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>Attention由很多变种，在LDM中主要有Self Attention和CrossAttention两种。</p><ul><li>Cross Attention<ul><li><span class="math inline">\(CrossAttn(A,B)=Attentino(W_{Q} \cdot A,W_{K} \cdot B, W_{V} \cdot B)\)</span></li><li>可以理解为利用A对B上的信息进行Query，比如在下图中，不同的文本token会产生不同的attentionmap <img src="https://s2.loli.net/2025/02/02/TrSogKQdJaFP8Ul.png" alt="image.png"></li></ul></li><li>Self Attention<ul><li><span class="math inline">\(SelfAttn(A)=Attention(W_{Q} \cdot A,W_{K} \cdot A, W_{V} \cdot A)\)</span></li><li>可以理解为A自己作了一次特征提取，将重要的信息提取出来</li></ul></li></ul><figure><img src="https://s2.loli.net/2025/02/02/X67Cj9gVvFNSBmH.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>总结一下，LDM最主要的是两个贡献</p><ol type="1"><li>在diffusion model的基础上，对图像空间进行压缩，在压缩后的latentspace上进行diffusion生成</li><li>使用cross attention将conditioning信息注入到网络中</li></ol><h1><span id="参考资料">参考资料</span></h1><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/525106459">由浅入深了解DiffusionModel - 知乎</a></li><li><a href="https://zhuanlan.zhihu.com/p/599160988">一文读懂DiffusionModel - 知乎</a></li><li><a href="https://arxiv.org/pdf/2208.11970">Understanding DiffusionModels: A Unified Perspective</a></li><li><a href="https://zhuanlan.zhihu.com/p/565698027">扩散模型之DDIM -知乎</a></li><li><a href="https://kexue.fm/archives/9181">生成扩散模型漫谈（四）：DDIM =高观点DDPM - 科学空间|Scientific Spaces</a></li><li><a href="https://www.bilibili.com/video/BV1YS421d7DN">【论文精读】DENOISINGDIFFUSION IMPLICIT MODELS【DDIM的背景介绍】</a></li><li><a href="https://zhouyifan.net/2024/01/23/20230709-SD2/">StableDiffusion 解读（二）：论文精读 | 周弈帆的博客</a></li><li><a href="https://zhouyifan.net/2024/01/23/20230713-SD3/">StableDiffusion 解读（三）：原版实现及Diffusers实现源码解读 |周弈帆的博客</a></li><li><a href="https://arxiv.org/pdf/2403.03431">Towards UnderstandingCross and Self-Attention in Stable Diffusion for Text-Guided ImageEditing</a></li><li><a href="https://arxiv.org/abs/2208.01626">Prompt-to-Prompt ImageEditing with Cross Attention Control</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ComputerVision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> Diffusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时渲染笔记-Importance Resampling and ReSTIR</title>
      <link href="/2025/01/04/gamegraphics/shi-shi-xuan-ran-bi-ji-importance-resampling-and-restir/"/>
      <url>/2025/01/04/gamegraphics/shi-shi-xuan-ran-bi-ji-importance-resampling-and-restir/</url>
      
        <content type="html"><![CDATA[<h2><span id="resampled-importance-samplingris">Resampled importance sampling(RIS)</span></h2><h3><span id="ris算法流程">RIS算法流程</span></h3><p>RIS流程:</p><ol type="1"><li>从一个易于采样的分布(<strong>proposal PDF</strong>) <span class="math inline">\(p(x)\)</span>上，进行采样，抽取<span class="math inline">\(M\)</span>个样本</li><li>得到一个期望进行拟合的真实目标概率分布(<strong>target PDF</strong>)<span class="math inline">\(\hat p(x)\)</span></li><li>对于每一个抽取的样本，分配权重<span class="math inline">\(w(x)={\hatp(x)}/{p(x)}\)</span>，进而得到每个样本的条件概率，通过这种方式进行采样的方法叫做重要性重采样Samplingimportance resampling (SIR)</li><li>采样出来的结果可以用于1-sample RIS estimator</li></ol><p><span class="math display">\[\langle L \rangle = \frac{f(y)}{\hat p(y)} \cdot \left(\frac{1}{M}\sum\limits_{j=1}^{M}w(x_{j}) \right)\]</span></p><ol start="5" type="1"><li>多次进行RIS采样，从样本池中的<span class="math inline">\(M\)</span>个样本（可以重新生成样本池，也可以直接在同一个样本池中进行采样进行简化）中有放回的采样<span class="math inline">\(N\)</span>个样本，得到最终的结果</li></ol><p><span class="math display">\[\langle L \rangle = \frac{1}{N}\sum\limits_{i=1}^{N}\left(\frac{f(y_{i})}{\hat p(y_{i})} \cdot \left(\frac{1}{M}\sum\limits_{j=1}^{M}w_{i}(x_{ij}) \right) \right)\]</span> <span id="more"></span></p><p>其中<span class="math inline">\(\hat{p}(y)/\frac{1}{M}\sum\limits_{j=1}^{M}w(x_{j})\)</span>是<strong>SIR PDF</strong>，也就是修正过后的真实的采样的PDF</p><p>通过RIS方法进行采样好处是可以近似的采样任意的概率分布，比如我们在ReSTIR算法中可以将<span class="math inline">\(L(\omega)f_{r}(\omega_{o},\omega_{i})\cos{\theta_{i}}\)</span>，也就是renderingequation中除去visibility的光照贡献，论文中称之为<em>unshadowedillumination</em>作为目标函数（对这个概率分布采用传统采样方法是无法实现的，因为无法进行归一化，PDF是无法计算出来的）</p><p>下面两张图展示了RIS的伪代码和流程</p><figure><img src="https://s2.loli.net/2025/01/04/FbSWmNk8jGDxhlq.png" alt="image-20250104021443035"><figcaption aria-hidden="true">image-20250104021443035</figcaption></figure><figure><img src="https://s2.loli.net/2024/12/26/Vy3fwR1AgBmqsl9.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h3><span id="ris和mis相结合">RIS和MIS相结合</span></h3><p>在使用RIS的同时，也可以采用MIS，进一步降低方差，达到更好的效果。这里通常有两种结合的方式。</p><p><strong>第一种方法</strong>第一步的时候，可以直接采用MIS的方式在两个概率分布上进行采样，得到两组采样后的结果。在这种情况下，分配权重的时候就需要考虑使用MIS的结果。正如GRIS <a href="https://research.nvidia.com/publication/2022-07_generalized-resampled-importance-sampling-foundations-restir">论文</a>中指出的，每个proposalPDF 的权重可以推广到这种形式 <span class="math display">\[w_{i}(x)=m_{i}(x)\frac{\hat p(x)}{p_{i}(x)}\]</span> 其中<span class="math inline">\(m_{i}(x)\)</span>代表的是MIS中采用的权重，一般常用的是balancedheuristic [[Computer Graphics Review#Multiple Importancesampling]]，形式如下： <span class="math display">\[w_{s}(x)=\frac{N_{s}p_{s}(x)}{\sum\nolimits_{j}N_{j}p_{j}(x)}\]</span></p><figure><img src="https://s2.loli.net/2024/12/26/42CTh9gFWils5bD.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><div class="note info no-icon"><p>Luckily, Talbot [2005] showed how to leverage multiple competingtechniques using MIS within RIS to reduce variance: generate the pool ofproposals using MIS and use the effective MIS (mixture) PDF as thesource PDF in the rest of the RIS procedure.</p></div><p><strong>第二种方法</strong></p><p>另外我们还可以把SIR视作一种单独的采样方法，然后对于SIR得到的结果之后再进行MIS</p><figure><img src="https://s2.loli.net/2024/12/27/OKDh7cBasIMvwmQ.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h3><span id="ris的无偏性推导">RIS的无偏性推导</span></h3><p>首先需要证明RIS是无偏的，我们只需要证明一下结论成立 <span class="math display">\[\mathbb{E}\left( \frac{1}{N}\sum\nolimits_{i=1}^{N}\frac{f(y_{i})}{\hat{p}(y_{i})} \left(\frac{1}{M}\sum\limits_{j=1}^{M}w(x_{ij}) \right) \right) = \int{f(x)}{\mathrm{d}{x}}\]</span>为了推导方便，这里定义一些简化的表示以及回顾之前的一些公式以及一些需要用到的结论<span class="math display">\[\begin{align*}W&amp;= \sum\limits_{i=1}^{M}w_{i}(x_{i})\\w_{i}(x)&amp;= m_{i}(x)\frac{\hat p(x)}{p_{i}(x)}\\\mathbb{E}\left( X \right) &amp;= \mathbb{E}\left( \mathbb{E}(X|Y)\right)\end{align*}\]</span> 并且由于引入了GRIS，这里新引入的权重<span class="math inline">\(m(x)\)</span>中包含了归一化的<span class="math inline">\(1/M\)</span>，因此这里需要忽略 <span class="math display">\[\mathbb{E}\left( \frac{1}{N}\sum\nolimits_{i=1}^{N}\frac{f(y_{i})}{\hat{p}(y_{i})} \left( \sum\limits_{j=1}^{M}w(x_{ij})\right) \right) = \int{f(x)} {\mathrm{d}{x}}\]</span> 详细推导过程，在<a href="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/#resampled-importance-sampling-ris">UnderstandingThe Math Behind ReStir DI · A Graphics Guy'sNote</a>推导的基础上添加了一些中间步骤，不知道理解是否正确。 <span class="math display">\[\begin{align*}&amp;\mathbb{E}\left( \frac{1}{N}\sum\nolimits_{i=1}^{N}\frac{f(y_{i})}{\hat{p}(y_{i})} \left( \sum\limits_{j=1}^{M}w(x_{ij})\right) \right) \\=&amp; \frac{1}{N}\sum\limits_{i=1}^{N}\mathbb{E}\left(\frac{f(y_{i})}{\hat{p}(y_{i})} \left(\sum\limits_{j=1}^{M}w(x_{ij})\right) \right)\\=&amp; \mathbb{E}\left( \frac{f(y)}{\hat p(y)}\left(\sum\limits_{j=1}^{M}w(x_{j}) \right) \right) = \mathbb{E}\left(\frac{f(y)}{\hat p(y)} W\right)\\=&amp; \mathbb{E}\left( \mathbb{E}\left( \frac{f(y)}{\hat p(y)}W\middle|x_{1},\cdots x_{k} \right) \right)\\=&amp; \underbrace{\int \cdots\int}_{M}\mathbb{E}\left(\frac{f(x_{k})}{\hat p(x_{k})}W  \right) \prod_{i=1}^{M}p(x_{i})\mathrm{d}{x_{1}}\cdots \mathrm{d}{x_{M}}\\=&amp; \underbrace{\int \cdots\int}_{M} \left(\sum\limits_{k=1}^{M}\frac{f(x_{k})}{\hat p(x_{k})}W \cdotp(y=x_{k}\vert x_{1},\cdots, x_{k})\right)\prod_{i=1}^{M}p(x_{i})\mathrm{d}{x_{1}}\cdots \mathrm{d}{x_{M}} \\=&amp; \underbrace{\int \cdots\int}_{M} \left(\sum\limits_{k=1}^{M}\frac{f(x_{k})}{\hat p(x_{k})}W\frac{w(x_{k})}{W}\right)\prod_{i=1}^{M}p(x_{i}) \mathrm{d}{x_{1}}\cdots\mathrm{d}{x_{M}} \\=&amp; \sum\limits_{k=1}^{M}\underbrace{\int \cdots\int}_{M} \left(m_{k}(x_{k}) f(x_{k}) \right)\prod_{i=1\&amp;i \ne k}^{M}p(x_{i})\mathrm{d}{x_{1}}\cdots \mathrm{d}{x_{M}} \\=&amp; \sum\limits_{k=1}^{M}\intm_{k}(x_{k})f(x_{k})\mathrm{d}x_{k}\prod_{i=1\&amp;i \ne k}^{M}\intp(x_{i})\mathrm{d}x_{i}  \\=&amp; \int \sum\limits_{k=1}^{M}m_{k}(x)f(x) \mathrm{d}x_{k}=\int f(x)\mathrm{d}x_{k}\end{align*}\]</span></p><h2><span id="weighted-reservoir-samplingwrs">Weighted Reservoir Sampling(WRS)</span></h2><h3><span id="wrs算法流程">WRS算法流程</span></h3><p>WRS是一种从一个流(stream)<span class="math inline">\(\{x_{1}, x_{2},\cdots,x_{M}\}\)</span>进行流式采样的算法，每个元素有一个对应的权重<span class="math inline">\(w(x_{i})\)</span>，所以<span class="math inline">\(x_{i}\)</span>被选中的概率是 <span class="math display">\[P_{i}=\frac{w(x_{i})}{\sum\limits_{j=1}^{M}w(x_{j})}\]</span> <img src="https://s2.loli.net/2025/01/04/YywevT6aHLkQ9gj.png" alt="image-20250104022122055"></p><p>数据结构</p><ul><li>最终输出的采样的样本</li><li>当前权重之和</li><li>当前处理过的样本数量<span class="math inline">\(M\)</span></li></ul><p>输入：加权样本集合(<span class="math inline">\(\mathbb{S}\)</span>)以及对应权重</p><p>流程:依次遍历集合中所有样本，每次update时更新权重之和，并对当前样本以<span class="math inline">\(w_{i}/w_{\text{sum}}\)</span>的概率进行样本的替换或保留。</p><p>WRS算法可以保证在每一次处理一个新的样本时，选择每一个样本的概率都是满足加权概率的。在处理完第<span class="math inline">\(m+1\)</span>个样本的时候，前<span class="math inline">\(m\)</span>个样本中<span class="math inline">\(x_{i}\)</span>被保留的概率是 <span class="math display">\[\frac{w(x_{i})}{\sum\nolimits_{j=1}^{m}w({x_{j}})}\left(1-\frac{w(x_{m+1})}{\sum\nolimits_{j=1}^{m+1}w({x_{j}})}\right)=\frac{w(x_{i})}{\sum\nolimits_{j=1}^{m+1}w({x_{j}})}\]</span> 这个概率仍然满足加权概率的要求。</p><h3><span id="reservoir的合并">Reservoir的合并</span></h3><p>假如我们现在有两个Reservoir，其中<span class="math inline">\(A\)</span>已经处理了<span class="math inline">\(N\)</span>个样本，<span class="math inline">\(B\)</span>处理了<span class="math inline">\(M\)</span>个样本，我们可以将这两个Reservoir进行合并，得到一个处理了<span class="math inline">\(N+M\)</span>样本的大Reservoir。</p><p>选择<span class="math inline">\(A\)</span>的概率: <span class="math inline">\(w_{sum}^{A}/(w_{sum}^{A}+w_{sum}^{B})\)</span>选择<span class="math inline">\(B\)</span>的概率: <span class="math inline">\(w_{sum}^{B}/(w_{sum}^{A}+w_{sum}^{B})\)</span>选择<span class="math inline">\(A\)</span>中样本<span class="math inline">\(x^{A}_{i}\)</span>的概率 <span class="math display">\[\frac{w_{i}^{A}}{w^{A}_{sum}}\cdot\frac{w_{sum}^{A}}{(w_{sum}^{A}+w_{sum}^{B})}=\frac{w_{i}^{A}}{(w_{sum}^{A}+w_{sum}^{B})}\]</span> 选择<span class="math inline">\(B\)</span>中样本<span class="math inline">\(x^{B}_{i}\)</span>的概率</p><p><span class="math display">\[\frac{w_{i}^{B}}{w^{B}_{sum}}\cdot\left(1-\frac{w_{sum}^{A}}{(w_{sum}^{A}+w_{sum}^{B})}\right)=\frac{w_{i}^{B}}{(w_{sum}^{A}+w_{sum}^{B})}\]</span></p><p>仍然符合加权概率的要求。</p><figure><img src="https://s2.loli.net/2025/01/04/gJVKGQuo9Cn82MP.png" alt="image-20250104022139413"><figcaption aria-hidden="true">image-20250104022139413</figcaption></figure><p>WRS的好处</p><ol type="1"><li>采样加权的离散值时，不需要进行预处理以及额外的存储</li><li>不关心样本总数</li><li>灵活的采样时机，比如在空间上、在时间上或者是多线程上进行采样</li><li>具有层次结构，可以分而治之的进行采样</li></ol><h2><span id="在ris中使用wrs进行采样">在RIS中使用WRS进行采样</span></h2><p>有了RIS和WRS之后，可以将两者结合，每一次生成一个RIS的样本池中的样本后，直接计算权重利用Reservoir进行采样，省去了预处理的以及查找采样的步骤</p><figure><img src="https://s2.loli.net/2025/01/04/8LH2ZMPqpxFXsW1.png" alt="image-20250104022157281"><figcaption aria-hidden="true">image-20250104022157281</figcaption></figure><p>ReSTIR算法除了将RIS和MRS结合起来以外，还引入了空间(Spatio)和时间(Temporal)上的样本的重复利用。在空间上，ReSTIR会combine当前像素点和邻居像素的reservoirs。在时间上，ReSTIR会存储上一帧的每一个像素的reservoir，和当前帧对应像素的reservoir进行combine。</p><p>使用spatialtemporalreuse的原因是因为在通常情况下，近邻像素的几何材质等相关信息和该像素具有相似性，并且在大多数情况下，上一帧的信息也可以在下一帧上进行利用。通过这样的方式，可以扩大合理的样本量，从而进一步降低方差。以下是ReSTIR完整的伪代码。</p><figure><img src="https://s2.loli.net/2025/01/04/9pKyxtMiB4ObeT2.png" alt="image-20250104022219028"><figcaption aria-hidden="true">image-20250104022219028</figcaption></figure><h3><span id="一些疑问">一些疑问</span></h3><p>首先注意到，如果我们使用了邻居像素的reservoir进行合并，但是很明显邻居像素的targetPDF和当前像素的显然是不一致的。这里应该如何理解呢？这是因为这里只是将邻居像素的SIRPDF作为了一个新的proposal PDF引入了，实际拟合的targetPDF仍然是当前像素的概率分布，所以并不会造成问题。</p><p>另一方面，在将RIS和MIS结合起来的时候，MIS的权重选择也是一个问题。通常情况下，MIS的权重采用的是heuristicweights，但是在这里由于无法很方便的计算一个给定方向上的SIRPDF，所以无法实现。因此，论文中采用了uniform的权重，仍然满足MIS的条件。</p><h2><span id="reference">Reference</span></h2><ol type="1"><li><a href="https://blog.traverseresearch.nl/dynamic-diffuse-global-illumination-b56dc0525a0a">Dynamicdiffuse global illumination | by Darius Bouma | Dec, 2023 | TraverseResearch</a></li><li><a href="https://research.nvidia.com/sites/default/files/pubs/2020-07_Spatiotemporal-reservoir-resampling/ReSTIR.pdf">research.nvidia.com/sites/default/files/pubs/2020-07_Spatiotemporal-reservoir-resampling/ReSTIR.pdf</a></li><li><a href="https://agraphicsguynotes.com/posts/understanding_the_math_behind_restir_di/">UnderstandingThe Math Behind ReStir DI · A Graphics Guy's Note</a></li><li><a href="https://graphics.cs.utah.edu/research/projects/gris/sig22_GRIS.pdf">graphics.cs.utah.edu/research/projects/gris/sig22_GRIS.pdf</a></li><li><a href="https://github.com/DQLin/ReSTIR_PT">GitHub -DQLin/ReSTIR_PT: Source Code for SIGGRAPH 2022 Paper "GeneralizedResampled Importance Sampling: Foundations of ReSTIR"</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 实时渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实时渲染笔记-Global Illumination</title>
      <link href="/2025/01/04/gamegraphics/shi-shi-xuan-ran-bi-ji-global-illumination/"/>
      <url>/2025/01/04/gamegraphics/shi-shi-xuan-ran-bi-ji-global-illumination/</url>
      
        <content type="html"><![CDATA[<figure><img src="https://s2.loli.net/2024/12/31/dL9xGh2gctreIkK.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>全局光照对于渲染真实的场景起到至关重要的作用。通常情况下，整个场景被照亮是一个非常复杂的过程，一个shadingpoint可能会受到直接光照、间接光照、散射、焦散、阴影等等的影响，如上图所示。所以没有全局光照只有直接光照会导致渲染的结果不真实，最直观的效果就是阴影区域非常黑，而有了间接光照，阴影区域就会有一个合理的亮度。</p><span id="more"></span><p><img src="https://s2.loli.net/2025/01/03/KZO1jtoplkLRVXz.png" alt="image.png"> # Reflective Shadow Maps (RSM)</p><p>Reflective Shadow Map (RSM)从名称上也可以看出来，这种方法的思路和Shadow Map是一致的，区别是ShadowMap只记录从光源出渲染的深度，而RSM还会存储包括深度、世界坐标、法线、光照能量等信息</p><figure><img src="https://s2.loli.net/2025/01/03/CqjGMkEu2dRihPr.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>它的基本思想是，从光源视角出发，我们可以得到所有可以被光源照亮的区域，这些区域就可以当作是次级光的发出光源。在ShadowMap上的每一个像素可以视作是一小片间接光的光源patch，我们知道光入射的方向，但是我们不知道光出射的方向。因此，RSM作出了一个假设，假设这些patch的surface都是diffuse的，因此出射光是朝着半球面各个方向发散的。</p><p>现在我们需要知道每一片间接光光源patch对shadingpoint的贡献。回顾渲染方程，可以通过换元将单位立体角上的积分转化为对光源面积的积分，下面是表示p点照亮q点反射的渲染方程。<span class="math display">\[\begin{align*}L_o(q, \omega_o) &amp;= \int_{\Omega_\text{patch}} L_i(q, \omega_i) V(q,\omega_i) f_r(q, \omega_i, \omega_o) \cos \theta_i \, d\omega_{i}\\&amp;= \int_{A_\text{patch}} L_i(p \to q) V(q, \omega_i) f_r(q, p \to q,\omega_o) \frac{\cos \theta_p \cos \theta_q}{\|q - p\|^2} \, dA\end{align*}\]</span></p><p>由于我们假设次级光源表面是diffuse的，所以有 <span class="math display">\[f_{r}(p)=\frac{\rho}{\pi}\]</span> Shadingpoint接收到的radiance就是这一个patch反射出的光强，这里从光源到次级光源的radiance可以写作flux和面积的比值，这样的好处是面积可以和积分中的面积约掉，这样子在存储的时候只需要存储一个flux就可以了，而不用考虑面积。<span class="math display">\[L_{i}(p)=f_{r}(p)\cdot E(l \rightarrow p)=f_{r} \cdot\frac{\Phi}{\mathrm{d}A}\]</span>存储了次级光源处的flux，我们就可以在渲染q点的时候利用存储的flux通过以下公式计算出p点对q点贡献的irradiance大小。这里忽略了从p点到q点的visibility的计算，因为如果每一个光线都计算的话计算量太大，很难算。所以RSM直接假设所有的次级光源对于shadingpoint都是可见的。</p><figure><img src="https://s2.loli.net/2025/01/03/PxILc9eBNYfJoKS.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>当然，在实际实现过程中，我们不可能把shadowmap上所有的像素都进行计算，所以我们需要进行采样。总体上看，离shadingpoint更近的次级光源对于shadingpoint会更大。这里RSM再次作出假设，根据shading point在shadowmap上的位置和次级光源在像素上的位置的距离进行不同密度的采样，距离近的采样密度大，远的采样密度小。对于采样的结果，RSM引入了权重，权重同样通过距离决定，越近权重越小，越远权重越大。</p><figure><img src="https://s2.loli.net/2025/01/03/ovFrZlMXyAz86si.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>RSM好处在于实现非常简单，完全按照ShadowMap的一套流程，但是性能有待提高，因为对于每一个光源都需要生成相应的RSM，而且由于存在很多假设，并且只考虑了一次反射的间接光，所以效果肯定是局限的。</p><h1><span id="light-propagation-volumeslpv">Light Propagation Volumes(LPV)</span></h1><p>在全局光照中，我们核心要解决的问题是在shadingpoint上获得从任意一个方向上接收到的radiance大小。通常情况下，我们都会采用一个基本假设，也就是radiance在传播过程中大小是不会改变的。LPV从名称上看，采用了Volume的方式，让光线在volume中进行传播。具体实现中，分为以下步骤</p><ol type="1"><li>生成直接光照的场景表示<ul><li>第一步采用了Reflective ShadowMap的办法，生成一个虚拟次级光源的集合，同样的，将次级光源的表面假设为diffuse材质。</li></ul></li><li>次级虚拟光源在场景体素中的注入<ul><li>将整个场景划分为三维网格</li><li>对于每一个格点，找到其中所有的虚拟光源，将虚拟光源的有向radiance贡献相加</li><li>对于有向radiance，可以使用SphericalHarmonics进行压缩，常用的做法是映射到二阶SH上</li></ul></li><li>体素中的radiance传播<ul><li>对于每一个格点，计算上下左右前后的六个格点中光源的对该格点的贡献，并重新映射到SH上</li><li>迭代若干次，使得LPV达到稳定的状态（这有点类似流体中的格点法） <img src="https://s2.loli.net/2025/01/03/JPIdVvefhWsG5Rm.png" alt="image.png"></li></ul></li><li>使用最终的light propagation volume进行场景渲染<ul><li>在最后渲染时，对于每一个shadingpoint，找到它所在的格点，利用格点中存储的radiance进行渲染</li></ul></li></ol><figure><img src="https://s2.loli.net/2025/01/03/UNszdfMlIOPHCjB.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>这样的方法在最后渲染时存在一个问题，如上图中，如果三维网格的划分过于稀疏，就会存在虽然一个次级光源本不该照亮一个被遮挡的shadingpoint，但是由于他们在同一个网格之中，实际计算会考虑这个次级光源的贡献的。因此，就会有下面的结果的出现</p><figure><img src="https://s2.loli.net/2025/01/03/NGo6u3XxfSqgZT7.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>在工业界的具体实现中，可能会存在一些自适应网格的方法，使用不规则的网格大小适应不同区域内的物体大小，带来的损失就是需要较为复杂的计算。更常见的做法时Cascaded的LPV，采用层级网格对不同距离的物体用不同大小的网格。</p><figure><img src="https://s2.loli.net/2025/01/03/S2RmAbiEgN1o6MD.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h1><span id="voxel-global-illuminationvxgi">Voxel Global Illumination(VXGI)</span></h1><p>VXGI也是一个2pass的算法，但是区别于Reflective ShadowMap，VXGI采用了Voxel对radiance信息进行存储。总体上VXGI分为两个步骤 1.lightpass：从光源视角出发，发出光线，同样的生成次级光源的patch，存储在八叉树的网格结构中2. camera pass：从摄像机出发，根据shadingpoint的BRDF采样一个反射的cone，并计算其贡献 <img src="https://s2.loli.net/2025/01/03/9zXMbmZJsaxYEFB.png" alt="image.png"></p><p>具体的，首先VXGI将整个场景划分为一个层次化结构，使用八叉树进行网格划分。使用层次结构(Hierachicalstructure)的好处是我们可以获得一个类似mipmap的结构，在最后的渲染中可以使用更高级的节点进行估算。在lightpass中，首先从光源出发，我们可以将每个光源patch的radiance计算出来，存储在八叉树的叶子节点中。为了实现mipmap的效果，需要继续进行filtering，逐层的更新父级节点的radiance。具体细节参见paper。</p><figure><img src="https://s2.loli.net/2025/01/03/Mo94ZOlSAc6kgzn.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>有了存储的radiance之后，在conetracing的时候就可以进行加速。最直观的思路是找到cone内所有相交的voxel，将所有的贡献相加，这显然是不显示的。VXGI提出的方法类似于raymarching，从shadingpoint出发逐级步进，在之前存储的层次化结构上逐级查询，通过插值得到贡献的radiance大小。</p><figure><img src="https://s2.loli.net/2025/01/04/bWTDn3rhYKZJwaC.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>对于glossy材质的物体，只需要采样一个cone，而对于diffuse的物体，理论上我们需要计算整个半球面上所有的次级光源的贡献。VXGI提出我们可以近似的用多个cone去近似的覆盖整个半球面（8个）</p><figure><img src="https://s2.loli.net/2025/01/04/tGZc1JDEv53Xiq6.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h1><span id="screen-space">Screen Space</span></h1><p>RSM、LPV、VXGI都是直接利用三维空间中的信息计算GlobalIllumination，这些方法基本上都有一个缺陷，就是性能消耗比较大。ScreenSpace的方法性能相比于三维空间会更好，这类方法的基本思想是从screenspace上的直接光照信息通过后期处理计算出间接光照。 ## Screen SpaceAmbient Occulusion (SSAO)</p><p>环境光遮蔽(AO)指的是环境中的间接光由于物体的几何关系产生遮挡产生的视觉效果，AO往往能带来更真实的视觉效果。SSAO是一种在屏幕空间中对全局光照估计的一种方法。</p><p>SSAO做了以下假设 1.任意一点的间接光照的强度都是常数（类似于Phong光照模型中的ambient项） 2.我们只需要考虑在每个shading point在各个方向上的可见性 3.同样的，假定表面都是diffuse材质</p><p>在理论上为什么我们只需要考虑shadingpoint的visibility呢？首先，从rendering equation出发 <span class="math display">\[L_{o}(p.\omega_{o})=\int_{\Omega+}L_{i}(p,\omega_{i})f_{r}(p,\omega_{i},\omega_{o})V(p,\omega_{i})\cos{\theta_{i}}\mathrm{d}\omega_{i}\]</span> 利用结论 <span class="math display">\[\int_{\Omega}f(x)g(x)\mathrm{d}x\approx\frac{\int_{\Omega_{G}}f(x)\mathrm{d}x}{\int_{\Omega_{G}}\mathrm{d}x}\cdot \int_{\Omega}g(x)\mathrm{d}x\]</span> 分离visibility项</p><p><span class="math display">\[L_{o}^{\text{indir}}(p, \omega_{o}) \approx \frac{\int_{\Omega_{+}}V(p,\omega_{i})\cos{\theta_{i}}\mathrm{d}\omega_{i}}{\int_{\Omega_{+}}\cos{\theta_{i}}\mathrm{d}\omega_{i}}\cdot \int_{\Omega_{+}}L_{i}(p, \omega_{i})f_{r}(p, \omega_{i},\omega_{o})\cos{\theta_{i}}\mathrm{d}\omega_{i}\]</span> 这里利用了<span class="math inline">\(\mathrm{d}x_\perp=\cos{\theta_{i}}\mathrm{d}\omega_{i}\)</span>的结论，从半球面上的积分转化到了平面上的积分</p><p>其中第一项经过化简之后就是所有方向上的visibility cos加权平均 <span class="math display">\[k_{A}=\frac{\int_{\Omega_{+}}V(p, \omega_{i})\cos{\theta_{i}}\mathrm{d}\omega_{i}}{\pi}\]</span> 第二项是间接光照，由于SSAO作出的假设，这一项就是常数 <span class="math display">\[L_{i}^{\text{indir}}(p) \cdot \frac{\rho}{\pi} \cdot\pi=L_{i}^{\text{indir}}(p) \cdot \rho\]</span> 所以现在的问题就是我们应该如何计算shading point的遮罩<span class="math inline">\(k_{A}(p)\)</span>。</p><p>SSAO利用屏幕空间中存储的depthbuffer来解决这个问题。我们需要计算shadingpoint在各个方向上的visibility的均值，很自然的我们就可以进行采样对这个值进行估算，具体的我们会在shadingpoint的一定半径的球面或者半球面进行采样。我们可以分成shadingpoint上有法线和没有法线两种情况 - SSAO(有法线) - 在shadingpoint一定半径范围内的球内进行采样，采样点投影到camera，得到采样点的深度- 采样点的深度和屏幕空间记录的深度作对比，小于screenspace深度即为可见，大于screen space深度即为不可见 -因为没有法线信息，所以只能在整个球里进行采样。当过半的采样点在物体内部，说明有AO，否则就不需要AO<img src="https://s2.loli.net/2025/01/04/W5nKyxajANLgrvt.png" alt="image.png"> - 问题：会出现false occulusion的问题 <img src="https://s2.loli.net/2025/01/04/dkRG96uAqrQcpia.png" alt="image.png"> - Horizon based ambient occulusion (HBAO) 有法线信息- 在法线所在的半球面上进行采样 - 有了法线信息可以加入cosine权重 <img src="https://s2.loli.net/2025/01/04/2tMB87aqOJTd3Nb.png" alt="image.png"> ## Screen Space Directional Occlusion (SSDO)</p><p>SSAO中假设所有的indirect illumination是相同的，但实际上在screenspace上我们也有可以直接利用的间接光照信息，也就是从camera视角下已经渲染好的图像。SSDO就是在此基础上对SSAO的改进。SSDO的基本思想是，从shadingpoint出发，随机射出光线，击中障碍物，说明是间接光照，未击中则是直接光照。</p><figure><img src="https://s2.loli.net/2025/01/04/ZJkazHGgjCOeNv1.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>类似于SSAO，SSDO从shadingpoint所在的半球面上进行采样，从采样点到P点的visibility同样的利用深度进行估计。如果在物体外部没有遮挡，采用环境光贴图的直接光照；如果在物体内部，那么利用从摄像机出发看到的surfacepatch作为次级光源计算简介光的贡献（具体方法和RSM类似）。当然因为visibility是通过摄像机的visibility近似得到的，所以实际情况下会有不符合的情况（上图右）。</p><p>SSDO的问题是，由于采样点的半球范围限制，间接光照只能计算在一定范围内的，无法计算远距离的。这一点和SSAO刚好相反，SSAO假设可见部分可以被远距离的环境光照亮，被遮挡的无法照亮；SSDO则是被遮挡部分会贡献间接光照，远距离无间接光贡献。另一个问题是screenspace存在的问题，由于screenspace只记录了从摄像机视角看到的信息，会忽略摄像机没有看到的信息，如下图所示，当左侧的表面消失在摄像机视野内时，它在地面的间接光照贡献就会被忽略。</p><figure><img src="https://s2.loli.net/2025/01/04/kjRBFePKfQ5Jd61.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h2><span id="screen-space-reflection-ssr">Screen Space Reflection (SSR)</span></h2><p>SSR是一种在屏幕空间作的raytracing，因此不需要三维空间中的mesh信息，而是利用屏幕空间中的法线、深度、图像信息。SSR的基本思路时，对于一个shadingpoint，去trace它的反射光线。这里不需要对shadingpoint的材质作出限制，无论时specular还是glossy的材质，都可以使用pathtracing中类似的方法去sample一根光线。</p><figure><img src="https://s2.loli.net/2025/01/04/q7oT51afDYSP8Ak.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>在trace反射光线的过程中，我们需要一个合适的步长，如果步长太大或者步长太小都会导致问题。因此SSR提出了Hierarchicalray trace的方式。这种方法需要使用到Depth Mip-Map(HiZ)，和普通Mipmap不同的是HiZ在filtering的時候用的是minpooling而不是平均，这样可以保证如果一个光线没有和一个高层级的节点相交，那它肯定也不会和低层级的节点相交。具体的trace伪代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mip = 0;</span><br><span class="line">while (level &gt; -1)</span><br><span class="line">step through current cell;</span><br><span class="line">if (above Z plane) ++level;</span><br><span class="line">if (below Z plane) --level;</span><br></pre></td></tr></table></figure><p>在SSR中，由于我们仍然需要知道次级光源的出射radiance，所以次级光源表面的材质仍然假设是diffuse的。但是SSR很好的解决了shadingpoint和次级光源的可见性问题，因为是严格的进行ray trace得到的结果。</p><h1><span id="参考资料">参考资料</span></h1><ol type="1"><li><p><a href="https://advances.realtimerendering.com/s2009/Light_Propagation_Volumes.pdf">advances.realtimerendering.com/s2009/Light_Propagation_Volumes.pdf</a></p></li><li><p><a href="https://dl.acm.org/doi/10.1145/1053427.1053460">Reflective shadowmaps | Proceedings of the 2005 symposium on Interactive 3D graphics andgames</a></p></li><li><p><a href="https://research.nvidia.com/sites/default/files/publications/GIVoxels-pg2011-authors.pdf">research.nvidia.com/sites/default/files/publications/GIVoxels-pg2011-authors.pdf</a></p></li><li><p><a href="https://dl.acm.org/doi/pdf/10.1145/1507149.1507161">Approximatingdynamic global illumination in image space | Proceedings of the 2009symposium on Interactive 3D graphics and games</a></p></li><li><p><a href="https://www.ea.com/frostbite/news/stochastic-screen-space-reflections">StochasticScreen-Space Reflections - Frostbite</a></p></li><li><p>Games 202 Lecture 7, 8, 9</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 实时渲染 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Geometry Processing Project</title>
      <link href="/2024/09/22/gamegraphics/geometryprocessingproject/"/>
      <url>/2024/09/22/gamegraphics/geometryprocessingproject/</url>
      
        <content type="html"><![CDATA[<!-- toc --><ul><li><a href="#implicit-surface-reconstruction">Implicit SurfaceReconstruction</a></li><li><a href="#mesh-parameterization">Mesh Parameterization</a><ul><li><a href="#uniform-and-cotangent-laplacian">Uniform and cotangentLaplacian</a></li><li><a href="#lscm">LSCM</a></li><li><a href="#arap">ARAP</a></li></ul></li><li><a href="#shape-deformation">Shape Deformation</a></li><li><a href="#skinning-and-skeletal-animation">Skinning and SkeletalAnimation</a><ul><li><a href="#rotation-representation">Rotation Representation</a></li><li><a href="#harmonic-skinning-weights-on-selected-handles">Harmonicskinning weights on selected handles</a><ul><li><a href="#handle-selection">Handle selection</a></li><li><a href="#skinning-weights-visualization">Skinning weightsvisualization</a></li></ul></li><li><a href="#skeletal-animation">Skeletal animation</a></li><li><a href="#context-aware-per-vertex-lbs">Context-aware per-vertexLBS</a></li></ul></li></ul><!-- tocstop --><span id="more"></span><h2><span id="implicit-surfacereconstruction">Implicit SurfaceReconstruction</span></h2><ul><li>Compute an implicit MLS function approximating a 3D point cloud withgiven normals.</li><li>Sample the implicit function on a 3D volumetric grid.</li><li>Apply the marching cubes algorithm to extract a triangle mesh fromthe zero level set.</li></ul><p><img src="https://s2.loli.net/2024/09/21/zedTcXsnWpYtMxK.png" alt="Image 1" style="width: 45%; object-fit: contain;"></p><h2><span id="mesh-parameterization">Mesh Parameterization</span></h2><ul><li>Parameterize a mesh by minimizing four different distortion measureswith fixed or free boundaries.<ul><li>Spring energy (uniform Laplacian)</li><li>Dirichlet/harmonic energy (cotangent Laplacian)</li><li>Least Squares Conformal Maps (LSCM)</li><li>As-Rigid-As-Possible (ARAP)</li></ul></li><li>Visualize the distortion by color coding.</li></ul><h3><span id="uniform-and-cotangentlaplacian">Uniform and cotangentLaplacian</span></h3><p>Spring energy is defined as <span class="math display">\[\frac{1}{2}k_{i,j}\Vert \mathbf{u}_{i}-\mathbf{u}_{j} \Vert^{2}\]</span> Minimizing the spring enegy <span class="math display">\[\begin{align*}E(\mathbf{u}_{1}, \cdots, \mathbf{u}_{n})&amp;=\sum\limits\frac{1}{2}k_{i,j}\Vert \mathbf{u}_{i}-\mathbf{u}_{j} \Vert^{2}\\\frac{\partial{E(\mathbf{u}_{1},\cdots,\mathbf{u}_{n})}}{\partial\mathbf{u}_{i}}&amp;=\sum\limitsk_{i,j}(\mathbf{u}_{i}-\mathbf{u}_{j})=0 \\\sum\limits_{j \in \mathcal{N}(i)\cap \mathcal{B}}k_{ij}\mathbf{u}_{i}+\sum\limits_{j \in \mathcal{N}(i) \backslash\mathcal{B}} k_{i,j}(\mathbf{u}_{i}-\mathbf{u}_{j})&amp;= \sum\limits_{j\in \mathcal{N}(i)\cap \mathcal{B}} k_{i,j}\mathbf{u}_{j}\end{align*}\]</span></p><figure><img src="https://s2.loli.net/2024/04/25/7VlIFtjNv5zsaSR.png" alt="Solve linear system"><figcaption aria-hidden="true">Solve linear system</figcaption></figure><ul><li>Two choices of spring constants<ul><li>Uniform <span class="math inline">\(k_{i,j}=1\)</span></li><li>Cotan <span class="math inline">\(k_{i,j}=\cot{\phi_{i,j}}+\cot{\phi_{j,i}}\)</span></li></ul></li></ul><figure style="text-align: center"><img src="https://s2.loli.net/2024/09/22/tYRwjISQlyW2J1f.png" alt="Uniform Laplacian"><figcaption>Uniform Laplacian</figcaption></figure><figure style="text-align: center"><img src="https://s2.loli.net/2024/09/22/znycJjoqNCtbK19.png" alt="Cotan Laplacian"><figcaption>Cotan Laplacian</figcaption></figure><h3><span id="lscm">LSCM</span></h3>The LSCM distortion measure can be defined as <span class="math display">\[D(J) = \| J + J^T - (\text{tr}\, J) I \|_F^2\]</span><figure style="text-align: center"><img src="https://s2.loli.net/2024/09/22/Yyz2u4bKoF1q5Cw.png" alt="LSCM"><figcaption>Cotan Laplacian</figcaption></figure><h3><span id="arap">ARAP</span></h3><p>The ARAP distortion is defined as <span class="math display">\[D(J) = \| J - R\|_F^2\]</span> where <span class="math inline">\(R\)</span> is the cloestrotation matrix to <span class="math inline">\(J\)</span>. The ARAPprocedure follows the steps below: - Local step: The Jacobians for eachface of the current iterate are computed. Then for each Jacobian theclosest rotation matrix is found. This can be done using the SVD of<span class="math inline">\(J\)</span>. - Global step: Then for eachJacobian the closest rotation matrix is found, they are all assumed tobe fixed, and then minimize the ARAP distortion measure by solving alinear system.</p><figure style="text-align: center"><img src="https://s2.loli.net/2024/09/21/bQjHe6omEWdcXkS.png" alt="LSCM"><figcaption>ARAP</figcaption></figure><h2><span id="shape-deformation">Shape Deformation</span></h2><p>Implement multiresolution mesh editing algorithm to interactivelydeform 3D models. Construct a two-level multi-resolution surfacerepresentation and use naive Laplacian editing to deform it.</p><p><img src="https://s2.loli.net/2024/09/22/OXJNh1mUl3wf9v6.png"></p><p>Multiresolution mesh editing algorithm: 1. Remove high-frequencydetails by surface smoothing 2. Deform the smooth mesh 3. Transferhigh-frequency details back to the deformed surface</p><p><video src="videos/mesh_edit.mp4" controls><a href="videos/mesh_edit.mp4">Video</a></video></p><h2><span id="skinning-and-skeletalanimation">Skinning and SkeletalAnimation</span></h2><h3><span id="rotation-representation">Rotation Representation</span></h3><table><colgroup><col style="width: 7%"><col style="width: 30%"><col style="width: 30%"><col style="width: 30%"></colgroup><thead><tr><th style="text-align: center;">Representions</th><th style="text-align: center;">Short Description</th><th style="text-align: center;">pros</th><th style="text-align: center;">cons</th></tr></thead><tbody><tr><td style="text-align: center;">rotation matrix</td><td style="text-align: center;">3x3 Matrix to represent rotation in3D</td><td style="text-align: center;">Simple to use directly.</td><td style="text-align: center;">Requires 9 elements to compute. Hard tointerpolation. Direct interpolation leads to artifact.</td></tr><tr><td style="text-align: center;">euler angles</td><td style="text-align: center;">Use three angles (yaw, pitch, roll) torepresent 3D representation</td><td style="text-align: center;">Only three parameters needed torepresent rotations. Intuitive. Easy to transformed to rotationmatrix</td><td style="text-align: center;">The gimbal lock problem. Can result ininterpolation problems</td></tr><tr><td style="text-align: center;">axis angle</td><td style="text-align: center;">Rotation defined by an rotation axis andan angle</td><td style="text-align: center;">straightforward and intuitive, easily beconverted to and from a matrix</td><td style="text-align: center;">Angle choices is not unique. Cannotperform interpolation directly</td></tr><tr><td style="text-align: center;">quaternions</td><td style="text-align: center;">Use a four-tuple of real number(x,y,z,w)</td><td style="text-align: center;">very efficient for interpolation.Without gimbal lock. Only 4 parameters required.</td><td style="text-align: center;">Less intuitive. more complex totransformed to rotation matrix. Double cover problem</td></tr></tbody></table><h3><span id="harmonic-skinningweights-on-selected-handles">Harmonic skinningweights on selected handles</span></h3><h4><span id="handle-selection">Handle selection</span></h4><table><colgroup><col style="width: 5%"><col style="width: 30%"><col style="width: 32%"><col style="width: 32%"></colgroup><thead><tr><th style="text-align: center;">shape name</th><th style="text-align: center;">joint 1</th><th style="text-align: center;">joint 2</th><th style="text-align: center;">joint 3</th></tr></thead><tbody><tr><td style="text-align: center;">hand</td><td style="text-align: center;"><img align="center" src="res/handle0.png" width="300"></td><td style="text-align: center;"><img align="center" src="./res/handle10.png" width="300"></td><td style="text-align: center;"><img align="center" src="./res/handle12.png" width="300"></td></tr></tbody></table><h4><span id="skinning-weightsvisualization">Skinning weightsvisualization</span></h4><table><colgroup><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"><col style="width: 25%"></colgroup><thead><tr><th style="text-align: center;">shape name</th><th style="text-align: center;">joint 1</th><th style="text-align: center;">joint 2</th><th style="text-align: center;">joint 3</th></tr></thead><tbody><tr><td style="text-align: center;">hand</td><td style="text-align: center;"><img align="center" src="./res/weight0.png" width="300"></td><td style="text-align: center;"><img align="center" src="./res/weight10.png" width="300"></td><td style="text-align: center;"><img align="center" src="./res/weight12.png" width="300"></td></tr></tbody></table><h3><span id="skeletal-animation">Skeletal animation</span></h3><table><colgroup><col style="width: 32%"><col style="width: 32%"><col style="width: 34%"></colgroup><thead><tr><th style="text-align: center;">Linear Blend Skinning</th><th style="text-align: center;">Dual Quaternion Skinning</th><th style="text-align: center;">per-face + averaging quaternions</th></tr></thead><tbody><tr><td style="text-align: center;"><img align="center" src="./res/hand_lbs.gif" width="300"></td><td style="text-align: center;"><img align="center" src="./res/hand_dqs.gif" width="300"></td><td style="text-align: center;"><img align="center" src="./res/hand_perface.gif" width="300"></td></tr></tbody></table><h3><span id="context-aware-per-vertex-lbs">Context-aware per-vertex LBS</span></h3><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th style="text-align: center;">without context</th><th style="text-align: center;">with context</th></tr></thead><tbody><tr><td style="text-align: center;"><img align="center" src="./res/eg_lbs.gif" width="300"></td><td style="text-align: center;"><img align="center" src="./res/eg_contextaware.gif" width="300"></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门笔记5: 空间加速结构</title>
      <link href="/2024/09/18/gamegraphics/tu-xing-xue-ru-men-bi-ji-5-kong-jian-jia-su-jie-gou/"/>
      <url>/2024/09/18/gamegraphics/tu-xing-xue-ru-men-bi-ji-5-kong-jian-jia-su-jie-gou/</url>
      
        <content type="html"><![CDATA[<p>在光追渲染中，我们需要对物体和射线的相交进行判断；在物理模拟中，我们需要对物体之间的碰撞进行检测。如果我们采用暴力算法，那么每一帧都需要大量时间计算射线或者碰撞检测。所以我们需要一些更加高效的方式来进行检测，这就需要我们用空间加速结构进行加速。今天主要记录几种在渲染和模拟中比较常用的方法</p><ul><li>Spatial Hashing (Uniform Grid)</li><li>Spatial Hierarchy (Octree, Kd Tree, BSP tree)</li><li>Bounding Box Hierachy (BVH) <span id="more"></span></li></ul><h2><span id="spatial-hashing">Spatial Hashing</span></h2><p>Spatial Hashing的思路是将空间划分为UniformGrid，每个Grid中存储着与其相交的三角形或者粒子。这里我有看到两种在不同情况下使用SpatialHashing的情形，第一种是三角形，第二种是粒子。对于三角形来说，同一个三角形可能存在于多个Grid当中，而一个Grid可能也会存在多个三角形。如下图所示：<img src="https://s2.loli.net/2024/02/17/NTOxbhg9AoCRPS3.png" alt="image.png">当然，上面这种存储方式，是会造成问题的。由于很多格子中可能没有三角形，所以会造成不必要的空间分配。因此，正如名称中的哈希所表示的，我们可以将这种空间划分表示为object-cell键值对的list，然后根据cell的ID进行排序，然后就可以形成下面的结构。在查找的时候，可以直接访问cell的下标。在寻找和三角形overlap的cell的时候，可以通过三角形的boundingbox和空间中的cells进行计算。在碰撞检测时，首先计算出当前三角形所相交的区域，然后通过SpatialHashing访问到这些区域中的三角形，这些三角形就是有可能产生碰撞的三角形对，之后用于做后续的检测。<img src="https://s2.loli.net/2024/09/16/wePfqOhyt5nr7Js.png" alt="image.png">现在这种排布仍然存在一些问题。因为Cell的ID是按照顺序定义的，在访问的时候会存在cachelocality的问题。当访问左右两侧的Cell中的三角形的时候，我们在访问一些连续的内存，可以成功利用cache缓存。但是当我们访问上下的Cell的时候，SpatialLocality就比较差。为了解决这个问题，有人提出了MortonCode的方法，用一种细分的Z字型结构指定Cell的ID，可以有效提高SpatialLocality。 <img src="https://s2.loli.net/2024/09/16/ur5mfJX12dtRSOL.png" alt="image.png">现在我们的Cell的ID是我们预先确定好的，也就是整个空间是一个bounded的空间。但是在实际情况中，我们需要考虑unbounded的空间，一个理论上无限的空间。所以，我们可以使用哈希函数去生成Cell的ID，比如下面这个函数：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">hashCoords</span>(<span class="params">xi, yi, zi</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> h = (xi * <span class="number">92837111</span>) ^ (yi * <span class="number">689287499</span>) ^ (zi * <span class="number">283923481</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(h) % <span class="variable language_">this</span>.<span class="property">tableSize</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>对于具体的实现，我们同样希望能够实现一种Dense的数据结构用于存储和访问。需要创建一下数组- <code>cellStart</code>，大小为哈希表的大小+1; -<code>cellEntries</code>，大小为所有物体的数量 算法流程如下： 1.将每个Cell中的物体数量写入<code>cellStart</code>数组中 2.<code>cellStart</code>计算前缀和 3. 填入<code>cellEntries</code>数组<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h =&gt; object所在Cell的哈希值</span><br><span class="line">cellStart[h]--</span><br><span class="line">cellEntries[cellStart[h]] = object</span><br></pre></td></tr></table></figure> 访问Cell中的物体时 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h =&gt; cell id</span><br><span class="line">int start = cellStart[h]</span><br><span class="line">int end = cellStart[h+1]</span><br><span class="line">for (int i = start; i &lt; end; i++)</span><br><span class="line">object = cellEntries[i]</span><br></pre></td></tr></table></figure></p><figure><img src="https://s2.loli.net/2024/09/16/RmDnQLebFgJ8tdV.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>具体的代码实现参考<a href="https://github.com/matthias-research/pages/blob/master/tenMinutePhysics/11-hashing.html">pages/tenMinutePhysics/11-hashing.html</a></p><h2><span id="spatial-hierarchies">Spatial Hierarchies</span></h2><p>采用UniformGrid的方法在光线求交的时候效率不高，因为没有hierarchy的结构，所以在大部分场景中仍然会有很多不必要的计算。因此，我们可以将空间划分为树状结构，可以产生以下三种划分的方式</p><ul><li>Octree(八叉树)：将空间递归的细分为等大的八个子空间</li><li>Kd-tree：交替的按照轴对空间进行划分</li><li>Bsp-tree：Kd-tree在Kd-tree的基础上，移除了axis-aligned的限制，以任意方向对空间进行递归的划分<img src="https://s2.loli.net/2024/01/15/fA7ctpDxzBUqZVl.png" alt="image.png"></li></ul><h2><span id="bounding-box-hierachy-bvh">Bounding Box Hierachy (BVH)</span></h2><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20230216234700.png">BVH是一种按照物体进行划分的空间加速算法。首先找到所有物体的一个包围盒，然后递归的将物体分成两个子集，并计算新的包围盒，当包围盒中的物体达到一定的数量的时候，停止继续细分，将所有物体存储在叶子节点当中。使用BVH也可以进行碰撞检测，流程如下。从叶子节点开始，向上一层一层进行碰撞检测。<img src="https://s2.loli.net/2024/02/17/RghClODsLVZbF8e.png" alt="image.png"></p><div class="note info no-icon"><ul><li>SpatialHashing相对来说实现更容易，并且可以支持GPU并行计算，但是需要每次update之后都重新计算Hash</li><li>BVH实现起来会更复杂，并且由于其树状的递归结构，并不利于在GPU上计算，但是对于BVH，只需要更新BoundingBox即可</li><li>SpatialHierarchy的结构同样不利于在GPU上进行计算，同时，由于是以空间为基础进行划分，难免会有一个物体出现在多个子空间中的情况存在</li></ul></div><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="https://matthias-research.github.io/pages/tenMinutePhysics/11-hashing.pdf">TenMinutesPhysics-SpatialHashing</a></li><li><a href="https://www.bilibili.com/video/BV12Q4y1S73g?p=9&amp;vd_source=4363d4cc2554c5f82c74408e68eb7dc0">Games103Lecture 09 Collision Handling</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quaternion四元数详解</title>
      <link href="/2024/02/19/gamegraphics/quaternion-si-yuan-shu-xiang-jie/"/>
      <url>/2024/02/19/gamegraphics/quaternion-si-yuan-shu-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>四元数(Quaternion)是用于表示旋转的一种方式，其相比于RotationMatrix的好处在于能够更轻松的插值、不存在万向节(gimballock)的问题。其定义如下： <span class="math display">\[q=a+bi+cj+dk\]</span> 其中<span class="math inline">\(i^{2}=j^{2}=k^{2}=ijk=-1\)</span>。同时也可以用以下方式表示：<span class="math display">\[q=\left(a, \mathbf{v}\right), \text{where}\mathbf{v}=\begin{bmatrix}b\\c\\d\end{bmatrix}\]</span> <span class="math inline">\(a\)</span>是实部，<span class="math inline">\(\mathbf{v}\)</span>是向量。四元数的旋转可以理解为四维坐标在三维空间中的投影，具体可以参考<a href="https://www.youtube.com/watch?v=zjMuIxRvygQ">3b1b的视频</a><span id="more"></span></p><h1><span id="四元数的基本运算">四元数的基本运算</span></h1><ul><li><p>共轭 (Conjugate) <span class="math display">\[q^{*}=a-bi-ci-dk\]</span></p></li><li><p>逆 (Inverse) <span class="math display">\[\begin{align*}q^{-1}=\frac{q^{*}}{\Vert q \Vert}\\q^{-1}q=qq^{-1}=1\end{align*}\]</span></p></li><li><p>模 (Norm) <span class="math display">\[\Vert q \Vert=\sqrt{a^{2}+b^{2}+c^{2}+d^{2}}\]</span></p></li><li><p>乘法 <span class="math display">\[pq=\begin{bmatrix}(p_{a}\mathbf{q}_{V}+q_{a}\mathbf{p}_{V}+\mathbf{p}_{V}\times\mathbf{q}_{V})&amp;(p_{a}q_{a}-\mathbf{p}_{V}\cdot\mathbf{q}_{V})\end{bmatrix}\]</span></p></li><li><p>当<span class="math inline">\(\Vert q \Vert=1\)</span>时，<span class="math inline">\(q^{-1}=q^{*}\)</span></p></li><li><p><span class="math inline">\((pq)^{*}=q^{*}p^{*}\)</span></p></li><li><p><span class="math inline">\((pq)^{-1}=q^{-1}p^{-1}\)</span></p></li></ul><h1><span id="如何使用四元数表示旋转">如何使用四元数表示旋转</span></h1><p>四元数表示旋转时必须时unit quaternion，表示如下 <span class="math display">\[\begin{align*}q&amp;=\begin{bmatrix}q_{a}&amp;\mathbf{q}_{V}\end{bmatrix}\\&amp;=\begin{bmatrix}\cos{\frac{\theta}{2}} &amp; \mathbf{v}\sin{\frac{\theta}{2}}\end{bmatrix}\end{align*}\]</span> 其中<span class="math inline">\(a^{2}+b^{2}+c^{2}+d^{2}=1\)</span></p><p>如果想要对空间中的点进行旋转，需要先将点(或向量)的三维坐标形式转化为quaternion的形式：<span class="math display">\[v=\begin{bmatrix}0&amp;\mathbf{v}\end{bmatrix}=\begin{bmatrix}0&amp;v_{x}&amp;v_{y}&amp;v_{z}\end{bmatrix}=bi+cj+dk\]</span> 对该点的四元数旋转表示如下： <span class="math display">\[v&#39;=qvq^{-1}=qvq^{*}\]</span></p><h1><span id="四元数和旋转矩阵的相互转化">四元数和旋转矩阵的相互转化</span></h1><ul><li>Quaternion to Matrix <img src="https://s2.loli.net/2024/02/19/tdy1F3zHupTXPJV.png" alt="image.png"></li><li>Rotation Matrix to Quaternion <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// From Game Engine Architecture</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">matrixToQuaternion</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">float</span> R[<span class="number">3</span>][<span class="number">3</span>],</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">float</span>       q[<span class="comment">/*4*/</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">float</span> trace = R[<span class="number">0</span>][<span class="number">0</span>]+R[<span class="number">1</span>][<span class="number">1</span>]+R[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// check the diagonal</span></span><br><span class="line"><span class="keyword">if</span> (trace &gt; <span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">flaot s = <span class="built_in">sqrt</span>(trace + <span class="number">1.0f</span>);</span><br><span class="line">q[<span class="number">3</span>] = s * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">float</span> t = <span class="number">0.5f</span> / s;</span><br><span class="line">q[<span class="number">0</span>] = (R[<span class="number">2</span>][<span class="number">1</span>] - R[<span class="number">1</span>][<span class="number">2</span>]) * t;</span><br><span class="line">q[<span class="number">1</span>] = (R[<span class="number">0</span>][<span class="number">2</span>] - R[<span class="number">2</span>][<span class="number">0</span>]) * t;</span><br><span class="line">q[<span class="number">2</span>] = (R[<span class="number">1</span>][<span class="number">0</span>] - R[<span class="number">0</span>][<span class="number">1</span>]) * t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// diagonal is negative</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (R[<span class="number">1</span>][<span class="number">1</span>] &gt; R[<span class="number">0</span>][<span class="number">0</span>]) i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (R[<span class="number">2</span>][<span class="number">2</span>] &gt; R[i][i]) i = <span class="number">2</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NEXT[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> j = NEXT[i];</span><br><span class="line"><span class="type">int</span> k = NEXT[j];</span><br><span class="line"><span class="type">float</span> s = <span class="built_in">sqrt</span>((R[i][j] - (R[j][j]+R[k][k])) + <span class="number">1.0f</span>);</span><br><span class="line">q[i] = s * <span class="number">0.5f</span>;</span><br><span class="line"><span class="type">float</span> t;</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0.0f</span>) t = <span class="number">0.5f</span> / s;</span><br><span class="line"><span class="keyword">else</span>           t = s;</span><br><span class="line">q[<span class="number">3</span>] = (R[k][j] - R[j][k]) * t;</span><br><span class="line">q[j] = (R[j][i] - R[i][j]) * t;</span><br><span class="line">q[k] = (R[k][i] - R[i][k]) * t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1><span id="四元数的插值">四元数的插值</span></h1><ul><li>Linear Interpolation (Lerp) <span class="math display">\[q_{\text{LERP}}=\text{LERP}(\mathbf{q}_{A},\mathbf{q}_{b},\beta)=\frac{(1-\beta)\mathbf{q}_{A}+\beta\mathbf{q}_{B}}{\vert(1-\beta)\mathbf{q}_{A}+\beta \mathbf{q}_{B}\vert}\]</span></li><li>Spherical Linear Interpolation (Slerp) <span class="math display">\[\text{SLERP}(\mathbf{p},\mathbf{q},\beta)=w_{p}\mathbf{p}+w_{q}\mathbf{q}\]</span> 其中 <span class="math display">\[\begin{align*}w_{p}&amp;=\frac{\sin(1-\beta)\theta}{\sin \theta} \\w_{q}&amp;=\frac{\sin\beta\theta}{\sin \theta}\end{align*}    \]</span> <span class="math inline">\(\mathbf{p}\)</span>和<span class="math inline">\(\mathbf{q}\)</span>的夹角可以通过四元数的点乘来计算<span class="math display">\[\begin{align*}\cos \theta&amp;=\mathbf{p} \cdot\mathbf{q}=p_{x}q_{x}+p_{y}q_{y}+p_{z}q_{z}+p_{w}q_{w}\\\theta&amp;=\cos^{-1}(\mathbf{p} \cdot \mathbf{q})\end{align*}\]</span></li></ul><h1><span id="参考资料">参考资料</span></h1><ol type="1"><li><a href="https://eater.net/quaternions">Visualizing quaternions, anexplorable video series</a></li><li><a href="https://www.youtube.com/watch?v=zjMuIxRvygQ">Quaternionsand 3d rotation, explained interactively - YouTube</a></li><li>Game Engine Architecture 4.4 Quaternions</li><li>Games104 Lecture 08</li></ol>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Simulation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Postion Based Dynamics软体模拟</title>
      <link href="/2024/02/19/gamegraphics/pbdsimulator/"/>
      <url>/2024/02/19/gamegraphics/pbdsimulator/</url>
      
        <content type="html"><![CDATA[<p>在position baseddynamics中，物体由许多的粒子组成，这些粒子之间有许多约束，比如说距离约束、体积约束等等。在物体运动的过程中，通过解这些约束来更新粒子的位置。大致的伪代码如下（这是XPBD的伪代码，XPBD的区别在于XPBD使用了substep加速收敛）<span id="more"></span></p><figure><img src="https://s2.loli.net/2024/02/15/xAoRjMfCFsmJXa7.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h1><span id="solve-constraint">Solve Constraint</span></h1><p>对于每个Constraint，计算其位置的便宜量<span class="math inline">\(\Delta\mathbf{x}_{i}=\lambda w_{i} \nablaC_{i}\)</span> <span class="math display">\[\lambda=\frac{-C}{w_{1}\vert\nabla C_{1}\vert^{2}+w_{1}\vert\nablaC_{1}\vert^{2}+\cdots+w_{n}\vert\nabla C_{n}\vert^{2}+\frac{\alpha}{\Delta t^{2}}}\]</span></p><ul><li><span class="math inline">\(C\)</span> 是约束函数</li><li><span class="math inline">\(\nabla C_{i}\)</span>是约束函数关于<span class="math inline">\(x_{i}\)</span> 的gradient</li><li><span class="math inline">\(w_{i}\)</span>是粒子的质量的倒数</li><li><span class="math inline">\(\alpha\)</span> 是stiffness参数</li></ul><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th>Distance</th><th>Volume</th></tr></thead><tbody><tr><td><img src="https://s2.loli.net/2024/02/15/K5DSaifQrMbTZsy.png" alt="image.png"><br></td><td><img src="https://s2.loli.net/2024/02/15/V3NLxolERuedIt1.png" alt="image.png"><br></td></tr></tbody></table><h1><span id="碰撞检测">碰撞检测</span></h1><p>碰撞检测分为broad phase和narrow phase，在broad phase使用BVH和SpatialHash等空间加速算法排除掉大部分不需要进行检测的三角形（由于时间限制，我们并没有完成这一部分，这也就导致最后的simulator无法实时运行）。对于有可能相交的三角形进行两两检测，然后通过CollisionConstraint修正顶点的位置。</p><p>根据<a href="https://www.sciencedirect.com/science/article/pii/S1047320307000065">Paper</a>中的描述，CollisionConstraint定义为 <span class="math display">\[C(\mathbf{p})=(\mathbf{p}-\mathbf{q}_{c}) \cdot \mathbf{n}_{c}\]</span> <span class="math inline">\(\mathbf{q}_{c}\)</span>是从<span class="math inline">\(p_{t-1}\rightarrow p_{t}\)</span>的线段和triangle的相交点(entry point)，<span class="math inline">\(\mathbf{n}_{c}\)</span>是相交点处的法线。CollisionConstraint通求解显然就是<span class="math inline">\(p_{t}\)</span>在相交平面上的投影(沿着gradient方向进行移动)。</p><p>当然还有特殊情况比如说，我们在某一时刻碰撞检测失效了，那么这个时候<span class="math inline">\(p_{t-1}\)</span>和 <span class="math inline">\(p_{t}\)</span>就都在另一个mesh内部了。对于这种情况，Paper中说这个时候的Constaint就变成了<span class="math display">\[C(\mathbf{p})=(\mathbf{p}-\mathbf{q}_{s}) \cdot \mathbf{n}_{s}\]</span> <span class="math inline">\(\mathbf{q}_{s}\)</span>是<span class="math inline">\(p_{t}\)</span>最近平面的投影点，<span class="math inline">\(\mathbf{n}_{s}\)</span>是法线，类似的，也就是说我们需要找到当前顶点位置的最近平面然后投影过去。</p><p>对于判断点是否在mesh内部，可以采用射线法，计算出相交点的个数进行判断。这里就产生了一个问题，我们的Tetrahedron的生成貌似有点点问题，所以导致我们无法获得表面的三角形（在Tetrahedron内部有一些三角形的残余不知道为什么）。</p><h1><span id="tetrahedron的生成">Tetrahedron的生成</span></h1><p>Tetrahedron的生成可以使用Incremental DelaunayMethod生成。四面体可以近似的使用平面的三角形进行类比，只需要将四面体的四个顶点换成三个顶点。一个Delaunay网格中的任意一个点都不在除了他坐在的三角形其他的三角形的外接圆中。</p><blockquote><p><strong>Wiki</strong> In <a href="https://en.wikipedia.org/wiki/Mathematics" title="Mathematics">mathematics</a> and <a href="https://en.wikipedia.org/wiki/Computational_geometry" title="Computational geometry">computational geometry</a>,a <strong>Delaunay triangulation</strong> (<strong>DT</strong>), alsoknown as a <strong>Delone triangulation</strong>, for a givenset {<em>p_i</em>} of <a href="https://en.wikipedia.org/wiki/Isolated_point" title="Isolated point">discrete points</a> <em>p_i</em> in <a href="https://en.wikipedia.org/wiki/General_position" title="General position">general position</a> is a <a href="https://en.wikipedia.org/wiki/Point-set_triangulation" title="Point-set triangulation">triangulation</a> such that nopoint <em>p_i</em> is inside the <a href="https://en.wikipedia.org/wiki/Circumcircle#Triangles" title="Circumcircle">circumcircle</a> of any <a href="https://en.wikipedia.org/wiki/Triangle" title="Triangle">triangle</a> in the DT. Delaunay triangulationsmaximize the minimum of all the angles of the triangles in thetriangulation; they tend to avoid <a href="https://en.wikipedia.org/wiki/Sliver_triangle" title="Sliver triangle">sliver triangles</a>.</p></blockquote><p>Delaunay算法流程如下</p><ol type="1"><li>输入：mesh的顶点坐标</li><li>首先用四个临时坐标生成一个大的四面体将所有的点围起来</li><li>然后重复以下流程<ol type="1"><li>将一个新的vertex添加进去</li><li>移除所有的外接圆包含这个vertex的四面体</li><li>以这个vertex为中心，生成环在其周围的四面体，填补将上一步移除造成的空缺</li></ol></li><li>最后将临时点移除即可</li></ol><p>移除四面体时，需要先找到这个点在哪个tetrahedron内部。这可以通过该点发出一条到上一个添加的点的射线，找到第一个相交的surface。然后通过flood-fill去找到附近的不符合条件的四面体。# 并行化 由于Position Based Dynamics采用的是Gauss-SiedelIteration，这导致了很难将其并行化，所以无法在taichi的gpumode下运行。如果想要并行化的话，需要使用JacobiIteration。然而从效率上来说，JacobiIteration的收敛速度是远远不如Gauss-Sidel的。还有一种方式是Graph-ColoringMethods。</p><p>GraphColoring的思想是，将所有的constaint分成多个phase进行求解。在每一个phase，我们需要确保没有任何一个costraint共享一个顶点。这就对应着graphcoloring问题。</p><h1><span id="最终效果">最终效果</span></h1><p>由于Blender的Tetrahedralize算法生成的四面体似乎有点问题，导致碰撞检测并不robust。最后时间问题，并行化只实现了Jacobi，但是效果还是没有Gauss-Siedel好。BroadPhase的碰撞检测也有待完成。参数也调整的比较stiff，效果如下</p><p><img src="results.gif"></p><h1><span id="reference">Reference</span></h1><ol type="1"><li><a href="https://www.sciencedirect.com/science/article/pii/S1047320307000065">Positionbased dynamics - ScienceDirect</a></li><li><a href="https://matthias-research.github.io/pages/tenMinutePhysics/index.html">TenMinute Physics</a> Tutorial 10 and 11</li><li><a href="https://www.cs.umd.edu/class/fall2019/cmsc828X/LEC/PBD.pdf">cs.umd.edu/class/fall2019/cmsc828X/LEC/PBD.pdf</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Project </tag>
            
            <tag> Simulation </tag>
            
            <tag> Taichi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ray Tracing Renderer (Course Project)</title>
      <link href="/2023/12/24/gamegraphics/noriproject/"/>
      <url>/2023/12/24/gamegraphics/noriproject/</url>
      
        <content type="html"><![CDATA[<h1><span id="motivational-image">Motivational Image</span></h1><p>The scene that we want to render is a dimly lit, smoky bar, inspiredby the following two images. Rows of exquisite liquor bottles line theshelves, their labels veiled in the subtle play of light and shadow. Anashtray rests nearby, adorned with an unlit cigarette. A dim spotlightbathes the ashtray and the wine bottles. The scene is to capture theessence of the bar's mystique, inviting participants to let theirimagination run wild as they bring out the richness of the hiddenstories within the rendering. The following two images are ourmotivation images.</p><p><img src="https://s2.loli.net/2024/01/02/FHRUOCLqBpaJQgw.jpg"> <img src="https://s2.loli.net/2024/01/02/fexQVhryYm2gdnl.jpg"></p><h1><span id="final-images">Final Images</span></h1><p>Based on the motivation images, we rendered our final images.</p><p><img src="https://s2.loli.net/2024/01/02/SVn3gKIpMBth4ND.png"></p><span id="more"></span><h1><span id="features-implemented">Features implemented</span></h1><h2><span id="images-as-texture">Images as Texture</span></h2><p><strong>Relevant Code</strong></p><ul><li><code>imagetexture.cpp</code></li></ul><h3><span id="implementation-details">Implementation Details</span></h3><p>To load the texture from external files, I used<code>stb_image</code> to read the image data. I defined a<code>ImageData</code> class similar to <code>Bitmap</code> class, whichis drived from <code>Eigen::Array</code> to store the image data. Theread image data is probably in sRGB color space. Therefore, we providean option boolean field <code>raw</code> in the <code>img_texture</code>property to indicate whether use raw image color space or convert it tolinear color space with <code>toLinearRGB()</code> function. We alsoprovide two difference filter modes, <code>nearest</code> and<code>bilinear</code>.</p><h3><span id="validation">Validation</span></h3><p>To validate the results, we used a texture from the website <a href="https://www.artstation.com/blogs/zeeshannasir/peYz/reference-uv-map-grids">Reference:UV Map Grids</a> and the scenes in assignment for rendering. The resultslook right. We also compared our results with mitsuba. Since thecoordinate used in mitsuba is right-handed while nori's is left-handed,the up axis coordinate is inversed so that the scene representation isthe same. The results are quite similar, while the results of mitsubaseem to be more vivid than ours. I think this may due to the usage ofmipmap in mitsuba. The overall results are correct.</p><div class="twentytwenty-container" style="max-width:720px"><img src="plane-texture-nori.png" data-width="720"><img src="plane-texture-v06.png" data-width="720"></div><div class="twentytwenty-container" style="max-width:720px"><img src="floor-texture-nori-nearest.png" data-width="720"><img src="floor-texture-v06-nearest.png" data-width="720"></div><div class="twentytwenty-container" style="max-width:720px"><img src="mesh-texture-nori-bilinear.png" data-width="720"><img src="mesh-texture-v06-bilinear.png" data-width="720"></div><h2><span id="normal-mapping">Normal Mapping</span></h2><p><strong>Relevant Code</strong></p><ul><li><code>mesh.h</code></li><li><code>mesh.cpp</code></li><li><code>shape.h</code></li><li><code>shape.cpp</code></li></ul><h3><span id="implementation-details">Implementation Details</span></h3><p>Normal mapping requires us to update the mesh normal with the normalsprovided in the normal textures. Since the frame normal is calculated inthe <code>setHitInformation()</code> function in <code>Shape</code>, Idecided to read the normal map and update the normals here. I added afield of type <code>Texture&lt;Color3f&gt; m_normalMap</code>. Thenormal map can be loaded with the Image as Texture implemented before.After reading the texture evaled value, it has to be converted to range[-1, 1]. Currently, only <code>Mesh</code> supports computing shaingframe with normal mapping. In the <code>setHitInformation()</code>function in <code>Mesh</code>, the local normal read from the normalmapping needs to be converted to the world normal using the local framefirst. However, if the default frame setup is used, the result isdiscontinuous and is absolutely wrong. Therefore, I need to constructthe right local frame first. I followed the formula in <a href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping">learnopengl</a>.</p><p><span class="math display">\[\begin{bmatrix}T_{x}&amp;T_{y}&amp;T_{z}\\B_{x}&amp;B_{y}&amp;B_{z}\end{bmatrix}=\frac{1}{\Delta U_{1}\DeltaV_{2}-\Delta U_{2}\Delta V_{1}}\begin{bmatrix}\Delta V_{2}&amp;-\DeltaV_{1} \\ -\Delta U_{2} &amp; \Delta U_{1}\end{bmatrix}\begin{bmatrix}E_{1x}&amp;E_{1y}&amp;E_{1z}\\E_{2x}&amp;E_{2y}&amp;E_{2z}\end{bmatrix}\]</span></p><p>where <span class="math inline">\(E_{1}\)</span> and <span class="math inline">\(E_{2}\)</span> are two edges of the triangle, and<span class="math inline">\(\Delta U, \Delta V\)</span> are thecorresponding uv offsets of the edges. <span class="math inline">\(T\)</span> and <span class="math inline">\(B\)</span> is <code>dpdv</code> and<code>dpdu</code>. Then, we can construct the local frame correctly with<code>dpdv</code> and <code>dpdu</code>.</p><h3><span id="validation">Validation</span></h3><p>To validate the results, the results of nori are compared to theresults of mitsuba.</p><div class="twentytwenty-container" style="max-width:720px"><img src="plane-normalmap-c-nori.png" data-width="720" data-height="720"><img src="plane-normalmap-c-v06.png" data-width="720" data-height="720"></div><div class="twentytwenty-container" style="max-width:720px"><img src="plane-normalmap-t-nori.png" data-width="720" data-height="720"><img src="plane-normalmap-t-v06.png" data-width="720" data-height="720"></div><div class="twentytwenty-container" style="max-width:720px"><img src="floor-normalmap-c-nori.png" data-width="720" data-height="720"><img src="floor-normalmap-c-v06.png" data-width="720" data-height="720"></div><div class="twentytwenty-container" style="max-width:720px"><img src="floor-normalmap-t-nori.png" data-width="720" data-height="720"><img src="floor-normalmap-t-v06.png" data-width="720" data-height="720"></div><div class="twentytwenty-container" style="max-width:720px"><img src="sphere-mesh-normalmap-c-nori.png" data-width="720" data-height="720"><img src="sphere-mesh-normalmap-c-v06.png" data-width="720" data-height="720"></div><div class="twentytwenty-container" style="max-width:720px"><img src="sphere-mesh-normalmap-t-nori.png" data-width="720" data-height="720"><img src="sphere-mesh-normalmap-t-v06.png" data-width="720" data-height="720"></div><h2><span id="emitter-spotlight-5pt">Emitter (Spotlight) (5pt)</span></h2><p><strong>Relevant Code</strong></p><ul><li><code>spotlight.cpp</code></li><li><code>path_mis.cpp</code></li><li><code>direct_mis.cpp</code></li></ul><h3><span id="implementation-details">Implementation Details</span></h3><p>The implementation of the spotlight follows the mistuba designs. Ithas three properties, <code>intensity</code>, <code>maxAngle</code> and<code>beamAngle</code>. <code>intensity</code> is the max irridiance ofemitter at the center. All the ray emitted within the beamAngle has anirridiance of <code>intensity</code>. The emitted intensity of the raybegins to attenuate linearly between beamAngle and maxAngle. All the rayoutside <code>maxAngle</code> is evaluated to be zero, meaning no lightcan be emitted in that direction. The <code>FallOff</code> functioncalculates that attenuation giving the sampled outgoing light direction.I also implemented the <code>samplePhoton</code> function in order toapply spotlight in photon mapper. The sampled power is simply<code>I * falloff / pdf</code>, following implementation in mitsuba. Pdfof the sampled photon uses<code>Warp::squareToUniformSphereCapPdf(cosMaxAngle)</code> since thesampled ray can only exist in the cone area contrained by<code>maxAnlge</code>.</p><p>One problem is that since the spotlight is a delta emitter, theoriginal implementation of multiple importance sampling does not work onspotlight. So I added a flag <code>isDeltaEmitter</code> in<code>EmitterRecord</code>. Everytime a delta emitter is sampled, theweight of the emitter sampling should be 1 while weight of bsdf is 0. Imodified <code>direct_mis</code> and <code>path_mis</code> based on thisrule to fix the problem.</p><h3><span id="validation">Validation</span></h3><p>To validate the correctness of the spotlight and the modification onthe integrator, I compared several rendered scenes in differentintegrator with mitsuba. The first scene is a simple floor withspotlight shooting from the above, rendered in direct integrator.</p><div class="twentytwenty-container" style="max-width:720px"><img src="floor-spotlight-nori.png" data-width="720"><img src="floor-spotlight-v06.png" data-width="720"></div><p>To validate the correctness in direct, path and photonmapperintegrator, I put a spotlight in the cbox scene. The noise level may beslightly different from mitsuba, but the overall brightness is correct.This can successfully validate the correctness of spotlight</p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_spotlight_direct_nori.png" data-width="600" data-height="600"><img src="cbox_spotlight_direct_v06.png" data-width="600" data-height="600"></div><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_spotlight_path_nori.png" data-width="600" data-height="600"><img src="cbox_spotlight_path_v06.png" data-width="600" data-height="600"></div><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_spotlight_pm_nori.png" data-width="600" data-height="600"><img src="cbox_spotlight_pm_v06.png" data-width="600" data-height="600"></div><h2><span id="stratified-sampling">Stratified Sampling</span></h2><p><strong>Relevant Code</strong></p><ul><li><code>stratified.cpp</code></li><li><code>render.cpp</code></li></ul><h3><span id="implementation-details">Implementation Details</span></h3><p><code>Stratified</code> class is derived from <code>Sampler</code>and implemented the stratified sampling. <code>prepare()</code> functionis used to initialize the sampler before start sampling. It is calledbefore the first sample starts. <code>generate()</code> function is usedto prepare for the sampling of the next image pixel.<code>advanced()</code> function is called every time before the nextsampling starts. <code>next1D</code> and <code>next2D</code> is used toretrieve the next 1d or 2d samples.</p><p>To enable sampling multiple dimensions, a <code>dimensionIndex</code>is maintained in the class. Similarly, <code>sampleIndex</code> and<code>pixelIndex</code> records the number of samples that are alreadysampled and the number of pixels sampled. When a sample is needed, firsta seed will be calculated based on a permutation base seed, dimensionindex and pixel index. The permutation sequences are thus the same forall the samples with the same <code>dimensionIndex</code> and<code>pixelIndex</code>, while different <code>dimensionIndex</code> and<code>pixelIndex</code> will have different sequences. Then, theposition of the current sampled region is retrieved with<code>sampleIndex</code>. Then a random offset is added according towhether the sampled is jittered or not.</p><p>In the <code>prepare()</code> function, I initialize the<code>sampleIndex</code> and the random number generators. A basepermutation seed is generated randomly. It can then be used to generatea permuation sequence of size <code>sampleCount</code>.<code>generate()</code> resets the dimension index and increment thepixelIndex. <code>advance</code> resets the pixel index and incrementthe sample index.</p><h3><span id="validation">Validation</span></h3><p>In th warptest, I visualize the results of the stratified sampler andgrid sampler to show the difference between them. The result is shownbelow.</p><div class="twentytwenty-container" style="max-width:700px"><img src="stratified-sampler.png" data-width="700"><img src="grid-sampler.png" data-width="700"></div><p>I also rendered a simple scene which consists of a plane and a sphereto see the actual effects of the stratified sampler. The result is shownbelow. The stratified sampler can reduce the noise level in .</p><div class="twentytwenty-container" style="max-width:720px"><img src="sphere-independent-nori.png" data-width="720"><img src="sphere-stratified-nori.png" data-width="720"></div><h2><span id="disneybsdf-metallic-specular-roughness-specular-tint-clearcoat">DisneyBSDF (metallic, specular, roughness, specular tint, clearcoat)</span></h2><p><strong>Relevant Code</strong></p><ul><li><code>disney.cpp</code></li><li><code>warp.h</code></li><li><code>warp.cpp</code></li><li><code>warptest.cpp</code></li></ul><h3><span id="implementation-details">Implementation Details:</span></h3><p>The disney BSDF is implemented based on the paper <a href="https://media.disneyanimation.com/uploads/production/publication_asset/48/asset/s2012_pbs_disney_brdf_notes_v3.pdf">Physically-BasedShading at Disney</a>. The code basically refers to the implementationof <a href="https://github.com/wdas/brdf/blob/main/src/brdfs/disney.brdf">DisneyBRDF explorer</a>.</p><p>There are ten parameters in Disney BRDF. Five of them, metallic,specular, roughness, specular tint and clearcoat graded. Disney BRDF isconsisted of three parts, which are diffuse, specular and clearcoat.Diffuse is influenced by metallic and roughness. Specular is influencedby specular, metallic, roughness and specular tint. Clearcoat isinfluenced by clearcoat. (Only graded ones are listed here) The specularand clearcoat are two microfacet models. The normal distribution ofspecular is GGX (GTR2), and the normal distribution of clearcoat isGTR1. The <code>squareToGTR2()</code>, <code>squareToGTR1()</code> andtheir pdf uses the formula derived in the appendix of the paper. The pdfare essentially the cosine weighted pdf of the normal distribution. The<code>eval()</code> function follows exactly the same as BRDF explorer.The choice of the sampling lobe refers to the implementation inmitsuba.</p><h3><span id="validation">Validation</span></h3><p>The GTR1 and GTR2 are tested in the warptest. The results are shownbelow.</p><p><img src="warptest-GTR1-v.png"> <img src="warptest-GTR1.png"><img src="warptest-GTR2-v.png"> <img src="warptest-GTR2.png"></p><p>To validate the correctness of disney BSDF, I used the scene<code>cbox</code> for test. For each test, only the parameter beingtested is changed, with all other graded parameters fixed and all otherungraded parameters being 0. The results are shown below.</p><p><strong>Metallic=0 vs Metallic=1</strong></p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_disney_nori-m0.png" data-width="600"><img src="cbox_disney_nori-m1.png" data-width="600"></div><p><strong>Roughness=0 vs Roughness=1</strong></p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_disney_nori-r0.png" data-width="600"><img src="cbox_disney_nori-r1.png" data-width="600"></div><p><strong>Specular=0.1 vs Specular=1</strong></p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_disney_nori-s01.png" data-width="600"><img src="cbox_disney_nori-s1.png" data-width="600"></div><p><strong>Specular tint=0 vs Specular tint=1</strong></p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_disney_nori-st0.png" data-width="600"><img src="cbox_disney_nori-st1.png" data-width="600"></div><p><strong>Clearcoat=0 vs Clearcoat=1</strong></p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_disney_nori-c0.png" data-width="600"><img src="cbox_disney_nori-c1.png" data-width="600"></div><h2><span id="progressive-photon-mapping">Progressive Photon Mapping</span></h2><p><strong>Relevant Code</strong></p><ul><li><code>progressivepm.cpp</code></li></ul><h3><span id="implementation-details">Implementation Details</span></h3><p>The implementation of progressive photon mapping is basically basedon the paper <a href="http://graphics.ucsd.edu/~henrik/papers/progressive_photon_mapping/progressive_photon_mapping.pdf">ProgressivePhoton Mapping</a>. The algorithm is consisted of two passes. In thefirst pass, we need to generate the visible hit points from the cameraand store them. In the second pass, we need to generate the photon maprepeated. After each photon map generation, we need to update the hitpoints with radius reduction and flux correction. A new rendered imagecan be generated right after eahc photon map generation process.</p><p>To make use of the current multiple thread rendering framework, theexecution process of the progressive photon mapper is a little differentfrom other integrators. In the <code>process()</code> function, weiterate all the image pixels and shoot <code>sampleCount</code> rays andperform path tracing for each ray and get the hit point on the diffusesurfaces. I define a function <code>persamplePreprocess()</code>. Thisfunction is called everytime a new sample starts. In this way, the<code>sampleCount</code> defined in the <code>sampler</code> is actuallythe number of photon map generation passes, while the actual number ofsamples for each pixel is the <code>sampleCount</code> defined in theprogressive photon mapper. Then in the<code>persamplePreprocess()</code> function, a new photon map isgenerated. Then, a new image is rendered in <code>Li()</code> function.Since now the pixel is needed to find the corresponding hit pointsstored, a new parameter <code>pixel</code> is added to the<code>Li()</code> function. First, the hit points information is updatedwith the new photon map. Then, the image is rendered with the updatedhit points. Doing these two steps at the same time in <code>Li()</code>function can make the best of the rendering framework to accelerate therendering process and is easy to implement even though it is a littleunintuitive.</p><h3><span id="validation">Validation</span></h3><p>To validate the progressive photon mapper, I rendered cbox withprogressive photon mapper of 1 photon map generation pass and 1000photon map generation passes. I also used the same setting on mitsubafor comparison. Even though the results are not exactly the same, itproves that the progressive photon mapper is converging to the correctresults.</p><p><strong>My results</strong></p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_pmap_nori_mp1.png" data-width="600"><img src="cbox_pmap_nori_mp100.png" data-width="600"></div><p><strong>Mistuba results</strong></p><div class="twentytwenty-container" style="max-width:600px"><img src="cbox_pmap_v06_mp1.png" data-width="600"><img src="cbox_pmap_v06_mp100.png" data-width="600"></div>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graphics </tag>
            
            <tag> Project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GAN论文精读</title>
      <link href="/2023/07/09/computervision/gan-lun-wen-jing-du/"/>
      <url>/2023/07/09/computervision/gan-lun-wen-jing-du/</url>
      
        <content type="html"><![CDATA[<h2><span id="introduction">Introduction</span></h2><p>GAN的全称是Generative AdversarialNets，是一种生成模型，目的是为了训练出一个生成器，使得生成器能够生成我们想要的数据，比如说一张图片。GAN在刚推出的时候成功生成了简单的手写数字和人脸照片，虽然现在看来生成的图片质量也比较一般，但是也开创了一个生成模型的新时代。</p><p>在以前的生成网络中，需要有大量的概率计算, 极大似然估计,比较麻烦i。GAN就成功的避免了概率计算的问题，不需要马尔科夫链、极大似然估计等等。GAN的思想非常简单，总的来说就是一个生成器和一个判别器进行对抗，最终达到一个纳什均衡的状态。</p><span id="more"></span><h2><span id="gan和对抗样本adversarialexamples的区别">GAN和对抗样本(Adversarialexamples)的区别</span></h2><p>对抗样本是指通过添加噪声的方式迷惑深度神经网络，让VGG等判别模型错误的对图像进行判断。下图中在熊猫的图片上增加了一个噪声，尽管生成的图片在人眼看来还是一个熊猫很难看出区别，但是使用深度神经网络进行判断的话就会错误的将熊猫判断为长臂猿。对抗样本通过训练（反向传播梯度下降）可以找到能够误导网络的噪声图。GAN和对抗样本的区别在于，对抗样本不是用来训练生成模型的，而是用来直接修改输入来达到误导网络的目的，二者的目的是不一样的。<img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20221204204717.png"></p><h2><span id="adversarial-nets">Adversarial Nets</span></h2><p>GAN首次提出了对抗损失函数，如下所示 <span class="math display">\[\min_G \max_D V(D, G)=\mathbb{E_{x\sim p_{data}(x)}}[\logD(x)]+\mathbb{E_{z\sim p_{z}(z)}}[\log(1-D(G(z)))]\]</span>其中G代表使用多层感知器的生成器，D代表使用另一个多层感知器的判别器，z代表输入的噪声，<span class="math inline">\(p_z(z)\)</span>表示z的分布函数，x是真实的数据，<span class="math inline">\(D(x)\)</span>代表判别器判断x来自真实数据的概率。通过训练D来最大化判别成功的可能性（max判别器），第一项表示判别器输入真实数据时，判别器的输出越大越好，后一项代表判别器输入假数据时判别器输出越小越好。同时通过训练G来最小化第二项，使得生成器生成的图片更加不容易被判别器辨别。这个过程就像是一个双人极大极小博弈游戏(two-player minimax game)，G和D在互相对抗的同时共同进步。 <img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20221204212017.png">在训练过程中，GAN采用了同时训练生成器和判别器的方式，如上图所示。其中蓝色虚线代表判别器的分布，黑色虚线代表真实数据分布，绿色虚线代表生成器生成的数据分布，z代表输入的噪声。在图(a)中，噪声z映射到绿色线上，判别器目前分辨出假数据和真数据的能力并不好。通过一次判别器的训练，来到(b)状态，此时的判别器可以比较好的分辨出真实数据和假数据，接着训练生成器，生成器的分布会向着辨别器判定真数据的分布上靠拢，这样子不断迭代之后，最终我们可以达到(d)状态，达到一个平衡状态，判别器判定真假数据的概率都为1/2，无法再区分出真假数据。下图是GAN算法的伪代码。<img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20221204212814.png"></p><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="https://www.bilibili.com/video/BV1oi4y1m7np/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=4363d4cc2554c5f82c74408e68eb7dc0">GAN论文精读-同济子豪兄</a></li><li><a href="https://proceedings.neurips.cc/paper/2014/hash/5ca3e9b122f61f8f06494c97b1afccf3-Abstract.htmla">GAN论文原文地址</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerVision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CycleGAN论文精读</title>
      <link href="/2023/07/09/computervision/cyclegan-lun-wen-jing-du/"/>
      <url>/2023/07/09/computervision/cyclegan-lun-wen-jing-du/</url>
      
        <content type="html"><![CDATA[<h2><span id="目的">目的</span></h2><p>CycleGAN主要解决的问题是一个Image to ImageTranslation的问题，也就是从一个图像域转化到另一个图像域的问题，比如说给一张人脸图片，生成对应的动漫头像，还有比如说我们给一个cartoon的图像，需要生成对应的像素化后的图像(pixel image)。 其次，传统的Image to ImageTranslation的算法通常需要我们有配对的图像组，但是很显然这是很耗费时间的，也很难获得配对图像。所以CycleGAN提出了一种使用unpairedtrainingset的方法，只需要给定对应两个图像域而不需要配对的图像，我们就可以实现Imageto Image的转化。</p><span id="more"></span><h2><span id="算法">算法</span></h2><p>CycleGAN在GAN的基础上提出了循环一致性损失 (cycle consistencyloss)[[GAN论文精读]]，不同于GAN从噪声生成相应的图片，CycleGAN的做法是准备非配对的两个图像域的数据集，训练两个GAN网络，一个用来将图像从A域转化到B域，另一个用来将图像从B域转化到A域。在训练过程中，有正反两个过程(ForwardBackward)，正向过程首先将图片从A域转化为B域，然后在用另一个网络将生成的假B域的图片再转化成A域的图片，然后用生成回去的图像和原来的输入图像作差，也就是cycleconsistencyloss，我们希望这个loss尽可能小，也就是经过两次转化之后的图像能够和原来的图像尽可能相像。同样的，在反向过程中，我们从B到A，再A到B，再做一次cycleconsistency loss。数学表示就是 <span class="math display">\[\begin{align}\text{forward: }&amp;x\rightarrow G(x)\rightarrow F(Gx)\approx x \\\text{backward: }&amp;y\rightarrow F(y)\rightarrow G(F(y))\approx y\end{align}\]</span></p><p>为什么要这么做呢？如果说我们不采用正反两个过程和cycle consistencyloss，我们就用一个GAN网络从A生成到B，那么可能会造成生成的图片虽然看着确实是B域的图片，但是它实际上和输入的图片已经没有关系了，甚至可能任何A域中的图片输入到网络中得到的B域图片都是一样的，也就造成了模式崩溃问题(Mode collapse)。而使用cycle consistencyloss可以保证生成的图片的内容和原来的图片是相符的。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20221204215142.png"></p><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="https://openaccess.thecvf.com/content_iccv_2017/html/Zhu_Unpaired_Image-To-Image_Translation_ICCV_2017_paper.html">CycleGAN论文原文</a></li><li><a href="https://junyanz.github.io/CycleGAN/">CycleGAN Project Page(junyanz.github.io)</a></li><li><a href="https://www.bilibili.com/video/BV1Ya411a78P/?spm_id_from=333.788&amp;vd_source=4363d4cc2554c5f82c74408e68eb7dc0">精读CycleGAN论文-拍案叫绝的非配对图像风格迁移-同济子豪兄</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> ComputerVision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE5插件CommonUI使用及原理剖析(Input)</title>
      <link href="/2023/06/10/gamegraphics/ue5-cha-jian-commonui-shi-yong-ji-yuan-li-pou-xi-input/"/>
      <url>/2023/06/10/gamegraphics/ue5-cha-jian-commonui-shi-yong-ji-yuan-li-pou-xi-input/</url>
      
        <content type="html"><![CDATA[<p>CommonUI是UE5新推出的一款UI插件，原本是堡垒之夜里使用的插件，Epic就将其作为插件引入到了UE5中。他主要的功能在于两点：一是对于复杂的UI使用LayerStack的思想，对于不同层级的UI进行相应的管理，并使用栈的方式解决UI层级的响应问题；二是使用InputRouting实现对不同输入的统一适配，对于开发多平台游戏来说比较方便，通过配置配置表即可实现多平台的UI和输入适配。本篇主要着重在Input部分进行使用的详解和源码的简要剖析。</p><span id="more"></span><h3><span id="commonui-input的使用">CommonUI Input的使用</span></h3><p>CommonUI的使用参考<a href="https://docs.unrealengine.com/5.0/zh-CN/common-ui-quickstart-guide-for-unreal-engine/">虚幻引擎CommonUI快速指南 | 虚幻引擎5.0文档</a>，主要分为四个步骤： 1.设置Viewport为CommonUIClientViewport。在Project Settings -&gt; GeneralSettings -&gt; GameViewportClientClass 修改为CommonGameViewportClient 2.创建<strong>InputActionDataTable</strong>进行控制器操作映射的配置。 <img src="https://s2.loli.net/2023/08/14/ZWoLkTa5DqVKAfm.png"></p><ol start="3" type="1"><li><p>设置 <strong>Default NavigationActions</strong>，支持全局的点击和返回按钮功能。创建一个CommonUIInputData的蓝图类，设置ClickAction和BackAction的InputAction映射，其中BackActionHandler可以在CommonUI的Widget中Override（设置一个布尔值IsBackHandler）<img src="https://s2.loli.net/2023/08/14/XucEgY4PHMtx2ZV.png"></p></li><li><p>创建 <strong>Controller Data Assets</strong>并且将其分配到特定平台上的特定控制器类型，可以为每个Button添加特定的Brush，通过这个设置就可以用CommonActionWidget来显示对应的Action的Icon了。<img src="https://s2.loli.net/2023/08/14/rlxmqL5RTfbaCw6.png">通过以上四个步骤可以实现CommonUIInput的基本设置。要让一些功能生效，最好还是要使用CommonUI提供的Widget，比如CommonActivatableWidget、CommonButtonBase等等。详细可以参考<a href="https://www.youtube.com/watch?v=TTB5y-03SnE&amp;t=4740s">InsideUnreal的教程</a>，或者阅读CommonUI的源码进行理解。### CommonUI Input源码流程梳理通过阅读源码发现，其实CommonUI提供的不是一个完整的解决方案，我个人觉得更多的是一种思路。对于InputActionDataTable的使用，主要是在<code>UCommonUserWidget</code>中的<code>RegisterUIActionBinding()</code>函数中。在这个函数中进行InputAction的注册绑定，通过查找发现主要是三种操作:<code>CommonActivatableWidget</code>的Back操作，<code>CommonButtonBase</code>的Trigger操作，以及<code>CommonTabListWidgetBase</code>的Tab操作。在这些Widget中可以自定义是否Handle对应的操作。所以单单一个CommonUI对于Input的处理还是比较局限的。</p></li></ol><p><img src="https://s2.loli.net/2023/08/15/tAXBTyI17VY8PHm.png"></p><p>调用的流程是从<code>UCommonGameViewportClient</code>开始。在这个类中<code>UCommonGameViewportClient::InputKey</code>这个函数首先处理KeyInput，然后在<code>UCommonGameViewportClient::HandleRerouteInput</code>中在ActionRouter里处理Input<img src="https://s2.loli.net/2023/08/15/G6OHbLnVPuvQTSj.png"></p><p>在ActionRouter中，会将Input传递给CommonUIWidget中当前的ActiveRootNode进行处理。CommonUI会将所有的ActivatableWidget按照层级进行建树。每个节点会被抽象成为<code>FActivatableRootNode</code>。然后从根节点开始遍历，对于每个Child执行<code>ProcessNormalInput</code>，直到Input被Consume。</p><blockquote><p>Activatable Widgets are abstracted as nodes in a tree using<code>FActivatableRootNode</code>. Nodes are arranged in a hierarchybased on the hierarchy of Activatable Widgets in the UI's widget tree.Parent nodes act as <strong>root nodes</strong>, while their childrenare considered <strong>child</strong> or <strong>leafnodes</strong>.</p></blockquote><p><img src="https://s2.loli.net/2023/08/15/SxfgBUuKONc9rDh.jpg"></p><p>ProcessInputNorma函数如下 <img src="https://s2.loli.net/2023/08/15/M2ygsvznqeFulh9.png"></p><p>这里就是通过查找绑定的ActionBindings制定绑定的相应的操作。在IDE中查找后发现，追根溯源，ActionBindings的绑定就是在上面所说<code>UCommonUserWidget</code>中的<code>RegisterUIActionBinding()</code>函数中进行的。Click(确认) 和 Back(取消)两种操作上。但是他提供了一种通用Input的处理方法，在LyraStarterGame中，就通过这种方法又自定义了一些通用的ActionBindings。### 参考资料 <a href="https://docs.unrealengine.com/5.0/zh-CN/common-ui-quickstart-guide-for-unreal-engine/">虚幻引擎CommonUI快速指南 | 虚幻引擎5.0文档</a> <a href="https://www.youtube.com/watch?v=TTB5y-03SnE&amp;t=4740s">InsideUnrealCommonUI Tutorial</a> <a href="https://zhuanlan.zhihu.com/p/553170706">游戏引擎应用——UnrealEngine的CommonUI插件分析 - 知乎</a></p>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal Engine </tag>
            
            <tag> UI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门笔记4: 实时阴影</title>
      <link href="/2023/06/04/gamegraphics/tu-xing-xue-ru-men-bi-ji-4-shi-shi-yin-ying/"/>
      <url>/2023/06/04/gamegraphics/tu-xing-xue-ru-men-bi-ji-4-shi-shi-yin-ying/</url>
      
        <content type="html"><![CDATA[<h3><span id="shadow-map">Shadow Map</span></h3><p>ShadowMap的思想非常简单，就是通过两个Pass将阴影渲染出来。在第一个Pass中，从光源的视角去渲染场景，记录片元的深度，得到一张深度图。然后进行第二个Pass，从摄像机的视角去渲染场景，对于渲染的每一个片元，将其坐标转化为以光源为参照的坐标，可以得到当前的深度，将这个深度值和存储在深度图中的深度值进行比较，如果说当前深度大于深度图中的深度，说明这个位置的光源被物体遮挡了，是一个阴影。</p><p>但是，ShadowMap会造成摩尔纹的问题，如下图所示。这是由于采样率不足，多个不同位置但临近的片元有可能映射到同一个ShadowMap的像素上，如第二张图所示，这就会导致有些像素会被误认为是阴影（产生了错误的自遮挡）。为了解决这个问题我们可以增加一个非常小的bias，就好像让地面稍微悬空一点，让那些自遮挡的部分不被误判为阴影，这样子就可以解决摩尔纹的问题了。但同时，这样子做又会引出新的问题，就是物体看起来像是和地面悬空了一样。实际上有很多不同设置bias大小的办法。</p><figure><img src="https://s2.loli.net/2023/07/16/lm5TDGQndikEFe8.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p><img src="https://s2.loli.net/2023/07/16/oa3bpAV8tGkEcdZ.png" alt="img">比较简单的一种自适应bias方法是通过法线和入射光的夹角来确定。当入射光非常倾斜的时候，我们需要的bias是比较大的，反之会比较小。所以我们可以通过设定一个bias的最大值和最小值，然后通过法线和入射光的夹角使bias取一个合适的值。</p><figure><img src="https://s2.loli.net/2023/07/16/aE9FG1uUdBkwXme.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>更具体的，还可以采用更加细致的数学计算，可以参考<a href="https://zhuanlan.zhihu.com/p/370951892">自适应Shadow Bias算法 -知乎</a>中给出的公式。注意以上两种方法中，要考虑法线方向和光线方向在不同侧，会有负值，所以需要加一个abs（比如说小女孩的背面）。</p><h3><span id="pcf">PCF</span></h3><p>PCF全称是Percentage CloserFiltering，是为了解决锯齿问题的一种最简单的处理方法。顾名思义，这种方法是采用了filtering的方法，当计算某个像素是否被遮挡时，首先先采样以该像素为中心周围一些点的遮挡情况，最后的Visibility值为被遮挡的采样点的比率。也就是说，对于每一个shadingpoint，我们都要在shadowmap上这个点周围一个范围内采样深度，并且判断和渲染视角深度的关系</p><p>Note</p><p>注意这里的filtering操作是在计算可见度的时候进行的操作，并非是直接在深度图上进行的操作（直接在深度图上进行卷积最终计算的结果还是硬阴影，没有意义）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">PCF</span><span class="params">(sampler2D shadowMap, vec4 coords, <span class="type">float</span> biasC, <span class="type">float</span> filterRadiusUV)</span> &#123;</span><br><span class="line">  <span class="comment">//uniformDiskSamples(coords.xy);</span></span><br><span class="line">  poissonDiskSamples(coords.xy); <span class="comment">//使用xy坐标作为随机种子生成</span></span><br><span class="line">  <span class="type">float</span> visibility = <span class="number">0.0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_SAMPLES; i++)&#123;</span><br><span class="line">    vec2 offset = poissonDisk[i] * filterRadiusUV;</span><br><span class="line">    <span class="type">float</span> shadowDepth = useShadowMap(shadowMap, coords + vec4(offset, <span class="number">0.</span>, <span class="number">0.</span>), biasC, filterRadiusUV);</span><br><span class="line">    <span class="keyword">if</span>(coords.z &gt; shadowDepth + EPS)&#123;</span><br><span class="line">      visibility++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> - visibility / <span class="type">float</span>(NUM_SAMPLES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="pcss">PCSS</span></h3><p>在PCF中，filtering的范围大小是预先确定的，然而在实际情况中，距离更近的阴影更影，远处则更远，如下图<img src="https://i.sstatic.net/75AbS.jpg" alt="img"></p><p>在PCF的基础上，PCSS会根据阴影距离物体的远近调整filtering的大小。PCSS分为三个步骤：</p><ol type="1"><li>Blocker Search，在某个特定范围内得出平均遮挡物的深度；</li><li>估计半影 (Penumbra)区域的大小，根据相似三角形得出；</li><li>使用计算得到的半影大小作为FilterRadius进行PCF</li></ol><figure><img src="https://s2.loli.net/2023/07/15/eFwgaTP76LSBcvu.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>那么在第一步中，在哪一块区域中计算那遮挡物的平均深度呢？这块区域取决于光源的大小和阴影接收平面距离光源的距离。同样类似的，根据相似三角形，在shadowmap上可以得到对应的区域，如下图所示</p><figure><img src="https://s2.loli.net/2024/12/30/iYXOmlW24Q7tvS9.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>对应的代码实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">findBlocker</span><span class="params">(sampler2D shadowMap, vec2 uv, <span class="type">float</span> zReceiver)</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> blockerNum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">float</span> blockDepth = <span class="number">0.</span>;</span><br><span class="line">  <span class="type">float</span> posZFromLight = vPositionFromLight.z;</span><br><span class="line">  <span class="comment">// blocker search的大小</span></span><br><span class="line">  <span class="comment">// NEAR_PLANE是近平面，即shadow map所在的平面</span></span><br><span class="line">  <span class="type">float</span> searchRadius = LIGHT_SIZE_UV * (posZFromLight - NEAR_PLANE) / posZFromLight;</span><br><span class="line"></span><br><span class="line">  poissonDiskSamples(uv);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_SAMPLES; i++)&#123;</span><br><span class="line">    <span class="type">float</span> shadowDepth = unpack(texture2D(shadowMap, uv + poissonDisk[i] * searchRadius));</span><br><span class="line">    <span class="keyword">if</span>(zReceiver &gt; shadowDepth)&#123;</span><br><span class="line">      blockerNum++;</span><br><span class="line">      blockDepth += shadowDepth;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(blockerNum == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1.</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> blockDepth / <span class="type">float</span>(blockerNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">PCSS</span><span class="params">(sampler2D shadowMap, vec4 coords, <span class="type">float</span> biasC)</span>&#123;</span><br><span class="line">  <span class="type">float</span> zReceiver = coords.z;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// STEP 1: avgblocker depth</span></span><br><span class="line">  <span class="type">float</span> avgBlockerDepth = findBlocker(shadowMap, coords.xy, zReceiver);</span><br><span class="line">  <span class="keyword">if</span>(avgBlockerDepth &lt; -EPS)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// STEP 2: penumbra size</span></span><br><span class="line">  <span class="type">float</span> penumbra = (zReceiver - avgBlockerDepth) * LIGHT_SIZE_UV / avgBlockerDepth;</span><br><span class="line">  <span class="type">float</span> filterRadiusUV = penumbra;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// STEP 3: filtering</span></span><br><span class="line">  <span class="keyword">return</span> PCF(shadowMap, coords, biasC, filterRadiusUV);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="variance-soft-shadow-mappingvssm">Variance Soft Shadow Mapping(VSSM)</span></h3><p>VSSM在PCF和PCSS的基础上通过统计学方法进行了改进。</p><h4><span id="step-3">Step 3</span></h4><p>在PCSS中第三步即PCF中，我们需要对任意一个shadingpoint通过卷积计算其visibility。这一步通常比较耗时。我们可以将其转化为一个概率，其中可以代表shadowmap的采样值，可以表示shadingpoint的深度。我们可以将深度的概率分布粗略的估计为一个Gaussiandistribution，更进一步的，我们甚至可以直接采用Chebyshev不等式进行估计</p><p>接下来的问题就是如何计算均值和方差，对于方差我们可以利用公式，这样就只需要知道均值以及平方的均值就可以计算方差</p><h4><span id="step-1">Step 1</span></h4><p>在PCSS第一步Blocker search中，我们也需要对shadowmap进行采样来计算遮挡物的平均深度，同样也是非常耗时的步骤。这里同样可以用概率进行估计以提高效率。首先定义以下相关变量</p><ul><li><p>遮挡物 ()的平均深度</p></li><li><p>非遮挡物 ()的平均深度</p></li><li><p>总样本数量</p></li><li><p>遮挡物的样本数量</p></li><li><p>非遮挡物的样本数量</p></li><li><p>区域平均深度</p><p>因此我们有以下公式</p><p>使用概率作以下估计和假设</p></li><li></li><li></li><li><p>然后就可以用Chebyshev不等式解决。另外这里使用的假设直接假定非遮挡物都和shadingpoint在同一平面上，可以理解为因为绝大部分阴影接收者都是一个平面，所以这样的假设也具有一定的合理性。</p></li></ul><p>到此为止，用统计学方法，我们可以解决PCSS中两步采样较为耗时的问题。</p><h4><span id="mipmap-andsummed-area-variance-shadow-maps">MIPMAP andSummed-Area Variance Shadow Maps</span></h4><p>在具体实现算法的时候，我们需要计算shadowmap中一块区域的方差和均值，可以通过Mipmap或者SAT(Summed AreaTable)实现。</p><ul><li>Mipmap可以快速的对Texture进行范围查询，在查询某块方形范围时，需要根据方形大小选择对应的Level，根据方形中心位置选择周围四个像素进行插值，以及上下Level之间作三线性插值(Trillinearinterpolation)。由于多次插值，所以得到的结果是不准确的。另外，Mipmap不适合做非方形区域的范围查询。</li></ul><figure><img src="https://s2.loli.net/2024/12/30/LenHG8ImYyxZDok.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><ul><li>SAT使用了类似前缀和的思想，维护一个table，每个位置上存储从原点到当前位置的矩形区域的和，如下图所示，可以很方便的得到某一块区域的范围之和。预计算和存储所需要的额外复杂度都是(逐行逐列累加)，可以采用并行计算进行加速。SAT得到的结果对比Mipmap是准确的，但缺点就是预处理比较耗时。</li></ul><figure><img src="https://s2.loli.net/2024/12/09/ZHKiDFk2qsy1VxA.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h4><span id="问题">问题</span></h4><p>由于VSSM中使用了大量的假设，在这些估计不准确的时候，会造成渲染的结果存在明显的artifact。比如由于我们假设了在filtering的范围内的深度是一个正态分布，但如果在并不是的情况下，就会造成估计的结果不准确。通常有两种情况，过大或者过小。过小会导致画面偏黑，而过大会导致漏光的现象，比如下面一个例子</p><figure><img src="https://s2.loli.net/2024/12/31/YxyJIZXDBzg8Uoi.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>假设右图中三块板从上到下A、B、C的深度分别为a、b、c，那么在Filterregion中我们计算得到深度的均值和方差</p><p>因此，根据Chebyshev不等式，B板的Visibility就是</p><p>C板的Visibility是</p><p>可以看出当很小时，也就是多个遮挡物体之间的深度变化很大的时候，本来应该很小的Visibility在上面的例子中会接近0.5，就会造成漏光问题。</p><p>除了这个问题以外，另一个假设，也就是假设未造成遮挡的物体和阴影接收平面处于同一个平面上，在一些并不符合的情况下就会造成漏光的问题，如下图。</p><figure><img src="https://s2.loli.net/2024/12/31/qWf3zmNd5kHQxiV.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h3><span id="moment-shadow-map">Moment Shadow Map</span></h3><p>为了解决VSSM中存在的问题，Moment Shadowmap使用了更高阶的矩(Moment)去拟合一个分布的CDF。Moment shadowmapping使用矩的最简单的形式 VSSM在本质上就是使用了两阶的Moment,</p><figure><img src="https://s2.loli.net/2024/12/31/mERcCMS71IoKL6V.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>从图中可以看到，通常情况下四阶moment已经可以很好的拟合一个CDF了。但是虽然Moment Shadow Mapping 效果相当不错，很好的解决了 VSSM绝大部分缺陷，但是它仍需要相当的额外空间开销和重建矩的额外性能开销。</p><figure><img src="https://s2.loli.net/2024/12/31/FsWZ8ErpS5dAeio.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><h3><span id="distance-field-soft-shadow">Distance Field Soft Shadow</span></h3><p>Distance Field Shadow Map采用了Signed Distance Function(SDF)进行阴影的计算。使用SDF可以有效解决Shadowmap存在的诸多问题，比如摩尔纹，peter panning，锯齿等等问题。</p><p>SDF用一个VolumeTexture存储每个点到最近的mesh表面的距离，如果在mesh外则为正，在mesh内部则为负。</p><p>SDF的性质可以用于进行raytracing。从起点出发，每一次trace步进当前点查询到的最近距离，这样子可以确保每一次步进都不会穿过物体。下图展示了从起点不断trace光线直到找到了光线和树的交点的过程。</p><figure><img src="https://s2.loli.net/2024/12/31/WVRJ76l3rdBKYcX.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>使用这个性质，可以通过raymarching的方式可以大致估算出visibility。如下图所示，假设有一个面光源，从shadingpoint出发，trace一根光线，使用SDF可以计算出这根光线在多大角度的范围内没有被遮挡，越小的角度代表越小的visibility。具体做法是，从起点出发，按照上面的办法不断的trace光线，在这个过程中计算角度，也就是</p><figure><img src="https://s2.loli.net/2024/12/31/hYkRr5JtuGAvyUi.png" alt="image.png"><figcaption aria-hidden="true">image.png</figcaption></figure><p>但在实际情况下，由于计算比较耗时，可以粗略的通过简单的线性关系表示遮挡程度，而并非严格的计算未遮挡角度和光源最大角度的比值</p><p>其中用来控制阴影的软硬程度，如下图所示 <img src="https://s2.loli.net/2024/12/31/Kwvc1HPAW6q7o4E.png" alt="image.png"></p><p>shader代码实现如下，来源<a href="https://iquilezles.org/articles/rmshadows/">Inigo Quilez ::computer graphics, mathematics, shaders, fractals, demoscene andmore</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )</span><br><span class="line">&#123;</span><br><span class="line">    float res = 1.0;</span><br><span class="line">    float t = mint;</span><br><span class="line">    for( int i=0; i&lt;256 &amp;&amp; t&lt;maxt; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        float h = map(ro + rd*t);</span><br><span class="line">        if( h&lt;0.001 )</span><br><span class="line">            return 0.0;</span><br><span class="line">        res = min( res, k*h/t );</span><br><span class="line">        t += h;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="参考资料">参考资料</span></h3><ol type="1"><li><a href="https://zhuanlan.zhihu.com/p/595039591">GAMES202-作业1：实时阴影 -知乎</a></li><li><a href="https://blog.csdn.net/qq_36242312/article/details/117562881">GAMES202 - 作业 1: 实时阴影_games202作业1_CCCCCCros____的博客-CSDN博客</a></li><li><a href="https://zhuanlan.zhihu.com/p/370951892">自适应ShadowBias算法 - 知乎</a></li><li><a href="https://developer.nvidia.com/gpugems/gpugems3/part-ii-light-and-shadows/chapter-8-summed-area-variance-shadow-maps">Chapter8. Summed-Area Variance Shadow Maps | NVIDIA Developer</a></li><li><a href="https://www.cnblogs.com/KillerAery/p/15201310.html">实时阴影技术（1）ShadowMapping - KillerAery - 博客园</a></li><li><a href="https://dev.epicgames.com/documentation/en-us/unreal-engine/mesh-distance-fields-in-unreal-engine">MeshDistance Fields in Unreal Engine | Unreal Engine 5.5 Documentation |Epic Developer Community</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++反射机制详解（一） 动态反射</title>
      <link href="/2023/01/06/cpp/c-fan-she-ji-zhi-dong-tai-fan-she/"/>
      <url>/2023/01/06/cpp/c-fan-she-ji-zhi-dong-tai-fan-she/</url>
      
        <content type="html"><![CDATA[<p>在实际的项目开发中，我们有时候需要进行一些操作比如说序列化。而如果我们对所有的内容都进行hardcode，显然这样的工作比较繁琐。因此，使用反射可以让我们在运行时获得类型信息，从而更方便的进行开发。在C++中原生不能提供反射机制，因此，通常需要我们手动去实现。</p><p>在C++中，常见的反射实现通常分为动态反射和静态反射。静态反射将类型信息在编译时进行导出，通常情况下使用parser在编译时期生成一些辅助代码，通过对类型、字段和函数的标记，生成相应的反射类型信息，如UnrealEngine、Qt等都是通过静态反射去实现反射的功能。动态反射是在运行时将类型信息记录下来，通常需要我们手动去register所需要的反射信息。</p><h2><span id="一种简单的反射实现">一种简单的反射实现</span></h2><p>首先，我们可以从简单开始，考虑一个最基本的问题，我们如何通过一个类名的字符串创建出对应的类。我们可以通过一个Class工厂类，存储我们注册的类名和类的构造信息。在创建类的同时，我们实现一个类的回调构造函数，这就是我们在工厂类中保存的类的构造信息，这样我们就可以使用类名字符串创建对应的类了。代码如下(源自 <a href="https://blog.csdn.net/K346K346/article/details/51698184">我所理解的C++反射机制</a> )</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span>* (*PTRCreateObject)(<span class="type">void</span>);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassFactory</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    map&lt;string, PTRCreateObject&gt; m_classMap ;  </span><br><span class="line"><span class="built_in">ClassFactory</span>()&#123;&#125;; <span class="comment">//构造函数私有化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:   </span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="title">getClassByName</span><span class="params">(string className)</span></span>;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">registClass</span><span class="params">(string name, PTRCreateObject method)</span> </span>;  </span><br><span class="line">    <span class="function"><span class="type">static</span> ClassFactory&amp; <span class="title">getInstance</span><span class="params">()</span> </span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">ClassFactory::getClassByName</span><span class="params">(string className)</span></span>&#123;  </span><br><span class="line">    map&lt;string, PTRCreateObject&gt;::const_iterator iter;  </span><br><span class="line">    iter = m_classMap.<span class="built_in">find</span>(className) ;  </span><br><span class="line">    <span class="keyword">if</span> ( iter == m_classMap.<span class="built_in">end</span>() )  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span> ;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> iter-&gt;<span class="built_in">second</span>() ;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ClassFactory::registClass</span><span class="params">(string name, PTRCreateObject method)</span></span>&#123;  </span><br><span class="line">    m_classMap.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, PTRCreateObject&gt;(name, method)) ;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="function">ClassFactory&amp; <span class="title">ClassFactory::getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">static</span> ClassFactory sLo_factory;  </span><br><span class="line">    <span class="keyword">return</span> sLo_factory ;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RegisterAction</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">RegisterAction</span>(string className,PTRCreateObject ptrCreateFn)&#123;</span><br><span class="line">ClassFactory::<span class="built_in">getInstance</span>().<span class="built_in">registClass</span>(className,ptrCreateFn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REGISTER(className)                                             \</span></span><br><span class="line"><span class="meta">    className* objectCreator##className()&#123;                              \</span></span><br><span class="line"><span class="meta">        return new className;                                           \</span></span><br><span class="line"><span class="meta">    &#125;                                                                   \</span></span><br><span class="line"><span class="meta">    RegisterAction g_creatorRegister##className(                        \</span></span><br><span class="line"><span class="meta">        #className,(PTRCreateObject)objectCreator##className)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestClass</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">m_print</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;hello TestClass&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">REGISTER</span>(TestClass);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">TestClass* ptrObj=(TestClass*)ClassFactory::<span class="built_in">getInstance</span>().<span class="built_in">getClassByName</span>(<span class="string">&quot;TestClass&quot;</span>);</span><br><span class="line">ptrObj-&gt;<span class="built_in">m_print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="taichi-反射库">Taichi 反射库</span></h2><p>Taichi Training类似于RTTR实现了一套动态反射库作为教程，教程链接<a href="https://www.bilibili.com/video/BV1MY4y1c7hU?vd_source=3ba69f5a040f08d144671fe461ae8b68">40分钟搓一个 C++反射库【原理、用法、实现都在这里了！】_哔哩哔哩_bilibili</a></p><p>首先，我们可以先看一段测试代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PassByValue</span><span class="params">(std::string s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Foo::PassByValue(`&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;`)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">PassByConstRef</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Foo::PassByConstRef(const `&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot;` &amp;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::string <span class="title">Concat</span><span class="params">(<span class="type">const</span> std::string &amp;head, <span class="type">const</span> std::string &amp;tail)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> res = head + tail;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::unique_ptr will result in compile-time error</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;<span class="type">float</span>&gt; <span class="title">MakeFloatPtr</span><span class="params">(<span class="type">float</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;<span class="type">float</span>&gt;(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">MakeReflectable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    reflect::<span class="built_in">AddClass</span>&lt;Foo&gt;(<span class="string">&quot;Foo&quot;</span>)</span><br><span class="line">        .<span class="built_in">AddMemberVar</span>(<span class="string">&quot;name&quot;</span>, &amp;Foo::name)</span><br><span class="line">        .<span class="built_in">AddMemberVar</span>(<span class="string">&quot;x_&quot;</span>, &amp;Foo::x_)</span><br><span class="line">        .<span class="built_in">AddMemberFunc</span>(<span class="string">&quot;PassByValue&quot;</span>, &amp;Foo::PassByValue)</span><br><span class="line">        .<span class="built_in">AddMemberFunc</span>(<span class="string">&quot;PassByConstRef&quot;</span>, &amp;Foo::PassByConstRef)</span><br><span class="line">        .<span class="built_in">AddMemberFunc</span>(<span class="string">&quot;Concat&quot;</span>, &amp;Foo::Concat)</span><br><span class="line">        .<span class="built_in">AddMemberFunc</span>(<span class="string">&quot;MakeFloatPtr&quot;</span>, &amp;Foo::MakeFloatPtr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line"></span><br><span class="line">  std::string name;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> x_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注册类型信息的代码就在<code>MakeReflectable</code>中，可以看到这里采用了一个建造者模式，可以链式的对成员函数和成员变量进行register。首先，在<code>AddClass</code>中会创建出这样的一个Builder</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">details::TypeDescriptorBuilder&lt;T&gt; <span class="title">AddClass</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> </span>&#123;</span><br><span class="line">  details::TypeDescriptorBuilder&lt;T&gt; b&#123;name&#125;;</span><br><span class="line">  <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的Builder最终想要创建的就是一个<code>TypeDescriptor</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeDescriptor</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::vector&lt;MemberVariable&gt; &amp;<span class="title">member_vars</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> member_vars_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::vector&lt;MemberFunction&gt; &amp;<span class="title">member_funcs</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> member_funcs_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">MemberVariable <span class="title">GetMemberVar</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;mv : member_vars_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mv.<span class="built_in">name</span>() == name) &#123;</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MemberVariable&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">MemberFunction <span class="title">GetMemberFunc</span><span class="params">(<span class="type">const</span> std::string &amp;name)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;mf : member_funcs_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mf.<span class="built_in">name</span>() == name) &#123;</span><br><span class="line">        <span class="keyword">return</span> mf;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MemberFunction&#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">RawTypeDescriptorBuilder</span>;</span><br><span class="line"></span><br><span class="line">  std::string name_;</span><br><span class="line">  std::vector&lt;MemberVariable&gt; member_vars_;</span><br><span class="line">  std::vector&lt;MemberFunction&gt; member_funcs_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="成员变量">成员变量</span></h3><p>在<code>MemberVariable</code>的实现中，使用了C++中的一种TypeEraser的方法，这样在编译时我们不需要类型信息，将类型信息的处理放在了运行时进行，也就是将类型的处理交给了使用者。也就是说这里MemberVariable本身不包含任何模板，类型的传递在构造函数以及getter和setter中使用模板进行推导。<code>getter_</code>和<code>setter_</code>的参数和返回值都使用<code>std::any</code>，也就是任意类型，在更古老的版本中可以用<code>void*</code>。在<code>getter_</code>和<code>setter_</code>的具体实现中，使用<code>std::any_cast</code>对类型进行强制类型转化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemberVariable</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MemberVariable</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="built_in">MemberVariable</span>(T C::*var) &#123;</span><br><span class="line">    getter_ = [var](std::any obj) -&gt; std::any &#123;</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">any_cast</span>&lt;<span class="type">const</span> C *&gt;(obj)-&gt;*var;</span><br><span class="line">    &#125;;</span><br><span class="line">    setter_ = [var](std::any obj, std::any val) &#123;</span><br><span class="line">      <span class="comment">// Syntax: https://stackoverflow.com/a/670744/12003165</span></span><br><span class="line">      <span class="comment">// `obj.*member_var`</span></span><br><span class="line">      <span class="keyword">auto</span> *self = std::<span class="built_in">any_cast</span>&lt;C *&gt;(obj);</span><br><span class="line">      self-&gt;*var = std::<span class="built_in">any_cast</span>&lt;T&gt;(val);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> C&gt;</span><br><span class="line">  <span class="function">T <span class="title">GetValue</span><span class="params">(<span class="type">const</span> C &amp;c)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">any_cast</span>&lt;T&gt;(<span class="built_in">getter_</span>(&amp;c));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(C &amp;c, T val)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setter_</span>(&amp;c, val);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">RawTypeDescriptorBuilder</span>;</span><br><span class="line"></span><br><span class="line">  std::string name_;</span><br><span class="line">  std::function&lt;std::any(std::any)&gt; getter_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">  std::function&lt;<span class="type">void</span>(std::any, std::any)&gt; setter_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="成员函数">成员函数</span></h3><p>成员函数中，类似的，也采用了TypeEraser的策略。这里的构造函数从一个变成了四个，分别对应 -<code>void func(params...)</code> -<code>return_type func(params...)</code> -<code>void func(params...) const</code> -<code>return_type func(params...) const</code>四种情况。具体的实现中，<code>C::*func</code>中<code>C</code>时类的类型，<code>func</code>时成员函数，<code>Args...</code>时参数列表。绑定函数到<code>fn_</code>上调用时，首先会将类<code>C</code>和参数列表<code>Args...</code>转化成一个<code>tuple</code>的指针，然后调用<code>std::apply</code>函数执行函数返回结果。</p><p>另外，在调用的时候，使用<code>std::reference_wrapper</code>对类型进行了引用封装，用于确保该对象是作为一个引用保存在<code>tuple</code>中而不是值。</p><blockquote><p><a href="https://en.cppreference.com/w/cpp/utility/tuple/make_tuple">std::make_tuple</a>Creates a tuple object, deducing the target type from the types ofarguments. For each <code>Ti</code> in <code>Types...</code>, thecorresponding type <code>Vi</code> in <code>VTypes...</code> is <a href="http://en.cppreference.com/w/cpp/types/decay">std::decay</a>&lt;Ti&gt;::type unlessapplication of <a href="https://en.cppreference.com/w/cpp/types/decay" title="cpp/types/decay">std::decay</a> results in <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper">std::reference_wrapper</a>&lt;X&gt; forsome type <code>X</code>, in which case the deduced typeis <code>X&amp;</code>.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemberFunction</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MemberFunction</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(R (C::*func)(Args...))</span> </span>&#123;</span><br><span class="line">    fn_ = [<span class="keyword">this</span>, func](std::any obj_args) -&gt; std::any &#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="type">tuple_t</span> = std::tuple&lt;C &amp;, Args...&gt;;</span><br><span class="line">      <span class="comment">// How to debug compile-time types...</span></span><br><span class="line">      <span class="comment">// static_assert(std::is_same&lt;tuple_t, void&gt;::value, &quot;Hoi!&quot;);</span></span><br><span class="line">      <span class="keyword">auto</span> *tp_ptr = std::<span class="built_in">any_cast</span>&lt;<span class="type">tuple_t</span> *&gt;(obj_args);</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">apply</span>(func, *tp_ptr);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(<span class="type">void</span> (C::*func)(Args...))</span> </span>&#123;</span><br><span class="line">    fn_ = [<span class="keyword">this</span>, func](std::any obj_args) -&gt; std::any &#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="type">tuple_t</span> = std::tuple&lt;C &amp;, Args...&gt;;</span><br><span class="line">      <span class="keyword">auto</span> *tp_ptr = std::<span class="built_in">any_cast</span>&lt;<span class="type">tuple_t</span> *&gt;(obj_args);</span><br><span class="line">      std::<span class="built_in">apply</span>(func, *tp_ptr);</span><br><span class="line">      <span class="keyword">return</span> std::any&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span> R, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(R (C::*func)(Args...) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">    fn_ = [<span class="keyword">this</span>, func](std::any obj_args) -&gt; std::any &#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="type">tuple_t</span> = std::tuple&lt;<span class="type">const</span> C &amp;, Args...&gt;;</span><br><span class="line">      <span class="comment">// How to debug compile-time types...</span></span><br><span class="line">      <span class="comment">// static_assert(std::is_same&lt;tuple_t, void&gt;::value, &quot;Hoi!&quot;);</span></span><br><span class="line">      <span class="keyword">auto</span> *tp_ptr = std::<span class="built_in">any_cast</span>&lt;<span class="type">tuple_t</span> *&gt;(obj_args);</span><br><span class="line">      <span class="keyword">return</span> std::<span class="built_in">apply</span>(func, *tp_ptr);</span><br><span class="line">    &#125;;</span><br><span class="line">    is_const_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">MemberFunction</span><span class="params">(<span class="type">void</span> (C::*func)(Args...) <span class="type">const</span>)</span> </span>&#123;</span><br><span class="line">    fn_ = [<span class="keyword">this</span>, func](std::any obj_args) -&gt; std::any &#123;</span><br><span class="line">      <span class="keyword">using</span> <span class="type">tuple_t</span> = std::tuple&lt;<span class="type">const</span> C &amp;, Args...&gt;;</span><br><span class="line">      <span class="keyword">auto</span> *tp_ptr = std::<span class="built_in">any_cast</span>&lt;<span class="type">tuple_t</span> *&gt;(obj_args);</span><br><span class="line">      std::<span class="built_in">apply</span>(func, *tp_ptr);</span><br><span class="line">      <span class="keyword">return</span> std::any&#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    is_const_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> std::string &amp;<span class="title">name</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_const</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> is_const_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> C, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function">std::any <span class="title">Invoke</span><span class="params">(C &amp;c, Args &amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_const_) &#123;</span><br><span class="line">      <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(std::<span class="built_in">reference_wrapper</span>&lt;<span class="type">const</span> C&gt;(c), args...);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">fn_</span>(&amp;tp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> tp = std::<span class="built_in">make_tuple</span>(std::<span class="built_in">reference_wrapper</span>&lt;C&gt;(c), args...);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fn_</span>(&amp;tp);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">RawTypeDescriptorBuilder</span>;</span><br><span class="line"></span><br><span class="line">  std::string name_;</span><br><span class="line">  <span class="type">bool</span> is_const_&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">  std::function&lt;std::any(std::any)&gt; fn_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3><span id="最终的测试和使用">最终的测试和使用</span></h3><p>测试代码如下，这里需要注意一点，对于constreference和reference的参数传递，需要手动添加一个<code>std::ref</code>和<code>std::cref</code>的包装，否则会crash。这是因为否则存在tuple中的类型不是一个引用类型，这和我们希望的是冲突的，所以会产生问题。</p><p>这里还有另一个解决办法，作者通过一层中间层<code>ArgWrap</code>对形参到实参的转化作了处理，细节参考代码和视频</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TestFoo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&gt;&gt;&gt; TestFoo\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Foo::<span class="built_in">MakeReflectable</span>();</span><br><span class="line">  <span class="keyword">auto</span> <span class="type">foo_t</span> = reflect::<span class="built_in">GetByName</span>(<span class="string">&quot;Foo&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;mv : <span class="type">foo_t</span>.<span class="built_in">member_vars</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;member var: &quot;</span> &lt;&lt; mv.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;mf : <span class="type">foo_t</span>.<span class="built_in">member_funcs</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;member func: &quot;</span> &lt;&lt; mf.<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;, is_const=&quot;</span> &lt;&lt; mf.<span class="built_in">is_const</span>()</span><br><span class="line">              &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  Foo f;</span><br><span class="line">  <span class="comment">// Test member variables</span></span><br><span class="line">  <span class="keyword">auto</span> name_var = <span class="type">foo_t</span>.<span class="built_in">GetMemberVar</span>(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">  name_var.<span class="built_in">SetValue</span>(f, std::string&#123;<span class="string">&quot;taichi&quot;</span>&#125;);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;f.name=&quot;</span> &lt;&lt; f.name &lt;&lt; std::endl;</span><br><span class="line">  <span class="keyword">auto</span> x_var = <span class="type">foo_t</span>.<span class="built_in">GetMemberVar</span>(<span class="string">&quot;x_&quot;</span>);</span><br><span class="line">  x_var.<span class="built_in">SetValue</span>(f, <span class="number">42</span>);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;f.x=&quot;</span> &lt;&lt; f.<span class="built_in">x</span>() &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Test member functions</span></span><br><span class="line">  <span class="keyword">auto</span> foo_make_float_ptr = <span class="type">foo_t</span>.<span class="built_in">GetMemberFunc</span>(<span class="string">&quot;MakeFloatPtr&quot;</span>);</span><br><span class="line">  <span class="keyword">auto</span> res = foo_make_float_ptr.<span class="built_in">Invoke</span>(f, <span class="number">123.4f</span>);</span><br><span class="line">  <span class="keyword">auto</span> float_sptr = std::any_cast&lt;std::shared_ptr&lt;<span class="type">float</span>&gt;&gt;(res);</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;MakeFloatPtr res: &quot;</span> &lt;&lt; *float_sptr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::string hello_s&#123;<span class="string">&quot;hello&quot;</span>&#125;;</span><br><span class="line">  std::string world_s&#123;<span class="string">&quot; world&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> foo_pass_by_val = <span class="type">foo_t</span>.<span class="built_in">GetMemberFunc</span>(<span class="string">&quot;PassByValue&quot;</span>);</span><br><span class="line">  foo_pass_by_val.<span class="built_in">Invoke</span>(f, hello_s);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> foo_pass_by_cref = <span class="type">foo_t</span>.<span class="built_in">GetMemberFunc</span>(<span class="string">&quot;PassByConstRef&quot;</span>);</span><br><span class="line">  <span class="comment">// foo_pass_by_cref.Invoke(f, hello_s);  // Crash, value</span></span><br><span class="line">  <span class="comment">// foo_pass_by_cref.Invoke(f, std::ref(hello_s));  // Crash, non-const ref</span></span><br><span class="line">  foo_pass_by_cref.<span class="built_in">Invoke</span>(f, std::<span class="built_in">cref</span>(hello_s));  <span class="comment">// OK: const ref</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> foo_concat = <span class="type">foo_t</span>.<span class="built_in">GetMemberFunc</span>(<span class="string">&quot;Concat&quot;</span>);</span><br><span class="line">  <span class="comment">// foo_concat.Invoke(f, hello_s, world_s);</span></span><br><span class="line">  res = foo_concat.<span class="built_in">Invoke</span>(f, std::<span class="built_in">cref</span>(hello_s), std::<span class="built_in">cref</span>(world_s));</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Concat got: &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(res) &lt;&lt; std::endl;</span><br><span class="line">  std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;&lt;&lt;&lt; TestFoo OK\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料</span></h2><ul><li><a href="https://blog.csdn.net/K346K346/article/details/51698184">我所理解的C++ 反射机制_恋喵大鲤鱼的博客-CSDN博客_c++ 反射</a></li><li><a href="https://www.bilibili.com/video/BV1MY4y1c7hU?vd_source=3ba69f5a040f08d144671fe461ae8b68">40分钟搓一个 C++反射库【原理、用法、实现都在这里了！】_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> GameEngine </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门笔记3: Path Tracing</title>
      <link href="/2022/10/05/gamegraphics/tu-xing-xue-ru-men-bi-ji-3-path-tracing/"/>
      <url>/2022/10/05/gamegraphics/tu-xing-xue-ru-men-bi-ji-3-path-tracing/</url>
      
        <content type="html"><![CDATA[<p>Path tracing笔记以及Games101作业7代码相关解读以及实现。笔记包括</p><ol type="1"><li>辐射度量学相关概念</li><li>渲染方程</li><li>蒙特卡洛积分</li><li>Path Tracing逻辑。</li></ol><p><span id="more"></span></p><h3><span id="辐射度量学-radiometry">辐射度量学 (Radiometry)</span></h3><ul><li><p>辐射通量 (Radiant flux (power)) <span class="math inline">\(\Phi=\frac{\mathrm{d}Q}{\mathrm{d}t}\)</span>Energy per unit time，表示单位时间内光穿过一个截面的光能。</p></li><li><p>辐射强度 (Radiant intensity)，<span class="math inline">\(I(\omega)=\frac{\mathrm{d}\Phi}{\mathrm{d}\omega}\)</span>Power per unit solid angle，表示单位立体角上的辐射通量。</p></li><li><p>辐射率 (Radiance)，<span class="math inline">\(L(\mathrmp,\omega)=\frac{\mathrm d^2\Phi(p,\omega)}{\mathrm d \omega\cdot\mathrmdA\cos\theta}\)</span> Power emitted, reflected, transmitted or receivedby a surface, per unit solid angle, per projected unitarea，表示单位立体角，单位投影面积上的辐射通量。这里多出来一个<span class="math inline">\(\cos \theta\)</span>是因为Lamber's CosineLaw，即阳光在斜照的时候强度会由于倾角变成原来的<span class="math inline">\(\cos \theta\)</span>倍。</p></li><li><p>辐照度 (Irradiance)，<span class="math inline">\(E(\mathrm{x})=\frac{\mathrm d\Phi(\mathrmx)}{\mathrm d A}\)</span> Power per unit area incident on a surfacepoint，表示单位面积上的辐射通量。这里有一种记忆方法，在Games104上学到的，将Irradiance拆分成Ir(In)和Radiance记为进入到表面的光照强度。</p></li><li><p>立体角 (Solid Angles)</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005201356513.png"></p></li></ul><h3><span id="bidirectionalreflectance-distribution-function-brdf">BidirectionalReflectance Distribution Function (BRDF)</span></h3><ul><li>渲染方程 (Rendering Equation) <span class="math display">\[L_o(p,\omega_0)=L_e(p,\omega_0)+\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_0)(n\cdot\omega_i)\mathrmd\omega_i\]</span>其中第一项表示物体本身的发出的光照强度，第二项的积分所包括的内容就是我们的反射函数(Reflection Function)，即 <span class="math display">\[L_r(\mathrm p,\omega_r)=\int_{\Omega+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_0)\cos\theta_i\mathrmd\omega_i\]</span>其中第一项为入射方向的Radiance，代表从单位立体角方向入射到单位面积上的光照强度，第二项就是双向反射分布函数，他表示以下比值<span class="math display">\[f_r(\omega_i\rightarrow\omega_r)=\frac{\mathrm dL_r(\omega_r)}{\mathrmdE_i(\omega_i)}=\frac{\mathrmdL_r(\omega_r)}{L_i(\omega_i)\cos\theta_i\mathrmd\omega_i}~~[\frac{1}{\text{sr}}]\]</span>也就是出射光Radiance与入射光Irradiance的比值，也就是代表了在各个方向上多少光照会被反射出去。这里的积分是对入射光的Radiance进行积分，得到的就是入射光在半球面上的Irradiance，然后和BRDF相乘得到的就是反射出的在单位立体角上的Radiance。</li></ul><h3><span id="蒙特卡洛积分-monte-carlointegration">蒙特卡洛积分 (Monte CarloIntegration)</span></h3><ul><li>Monte Carlo estimator <span class="math inline">\(F_N=\frac{1}{N}\sum^N_{i=1}\frac{f(X_i)}{p(X_i)}\)</span>,Example, Basic (Uniform) Monte Carlo estimator <span class="math inline">\(F_N=\frac{b-a}{N}\sum_{i=1}^Nf(X_i)\)</span></li><li>Monte Carlo Integration <span class="math inline">\(\int f(x)\mathrmdx=\frac{1}{N}\sum_{i=1}^N\frac{f(X_i)}{p(X_i)}\)</span> The moresamples, the less variance.</li></ul><h3><span id="路径追踪-path-tracing">路径追踪 (Path Tracing)</span></h3><p>Whitted-style光线追踪始终采用镜面反射，在光线与diffuse表面相交时停止反射，这一假设会造成一些问题。首先，比如说诸如Glossy(感觉类似磨砂)的效果就无法表现出来。其次，由于不在diffuse表面进行反射，物体之间由于光线反射形成的现象比如说康奈尔Box中的墙面会映射出左右两面墙的红绿两种颜色(如下图)就无法表现出来。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005213331204.png"></p><p>Path tracing使用Rendering Equation进行光照的计算。在计算RenderingEquation中的积分部分时，我们就可以使用Monte CarloIntegration计算。一个简单的Monte Carlo的方法如下图所示 (DirectIllumination)，其中的pdf最直观的办法我们可以视为uniform的，也就是<span class="math inline">\(\mathrm{pdf}=\frac{1}{2\pi}\)</span>。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005214101763.png"></p><p>以上是最简单的直接光照的蒙特卡洛积分，然后我们再加上递归的间接光照以及控制递归深度就完成了最终的PathTracing。为了控制深度，我们使用一种叫做俄罗斯轮盘赌 (RussianRoulette)的方法。非常简单，这种方法就是在每次光线进行反射的时候进行一次随机选择，p的概率继续递归，(1-p)的概率停止，如果继续反射，则我们计算反射的光照强度为<span class="math inline">\(\frac{L_r(p,\omega_r)}{p}\)</span>，这样我们最后根据数学期望得到的光照强度仍然是<span class="math inline">\(L_r(p,\omega_r)\)</span>。使用后RR的PathTracing伪代码如下所示。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005225016368.png"></p><p>最后还有一个问题需要解决，使用以上方法进行采样的效率实际上是不高的，因为很多光线实际上是反射不到光源上的，那样就会造成很多浪费。因此，我们可以使用另外一种采样方式，SamplingtheLight，从光源处采样。为了实现光源采样，我们可以重写反射方程，将对入射角度<span class="math inline">\(\omega\)</span>的积分转化为对光源面积<span class="math inline">\(A\)</span>的积分，由于<span class="math inline">\(\mathrm d\omega=\frac{\mathrmdA\cos\theta&#39;}{\Vert x&#39;-x\Vert^2}\)</span>(由立体角的定义得出)，因此 <span class="math display">\[\begin{align}L_r(\mathrmp,\omega_r)&amp;=\int_{\Omega+}L_i(x,\omega_i)f_r(x,\omega_i,\omega_0)\cos\theta_i\mathrmd\omega_i \\    &amp;=\int_{A}L_i(x,\omega_i)f_r(p,\omega_i,\omega_0)\frac{\cos\theta_i\cos\theta&#39;_i}{\Vertx&#39;-x\Vert^2}\mathrm d\omega_i\end{align}\]</span> <img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005230600428.png"></p><p>最终版的Path Tracing伪代码如下</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20221005230708399.png"></p><h3><span id="作业7">作业7</span></h3><p>首先，我们需要将上一次作业的几个函数的实现复制粘贴到这里来，包括<code>Triangle::getIntersection()</code>inTriangle.hpp，<code>IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir, const std::array&lt;int, 3&gt;&amp; dirIsNeg)</code>inBounds3.hpp以及<code>getIntersection(BVHBuildNode* node, const Ray ray)</code>in BVH.cpp。代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Triangle.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Intersection <span class="title">Triangle::getIntersection</span><span class="params">(Ray ray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Intersection inter;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dotProduct</span>(ray.direction, normal) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    <span class="type">double</span> u, v, t_tmp = <span class="number">0</span>;</span><br><span class="line">    Vector3f pvec = <span class="built_in">crossProduct</span>(ray.direction, e2);</span><br><span class="line">    <span class="type">double</span> det = <span class="built_in">dotProduct</span>(e1, pvec);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(det) &lt; EPSILON)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> det_inv = <span class="number">1.</span> / det;</span><br><span class="line">    Vector3f tvec = ray.origin - v0;</span><br><span class="line">    u = <span class="built_in">dotProduct</span>(tvec, pvec) * det_inv;</span><br><span class="line">    <span class="keyword">if</span> (u &lt; <span class="number">0</span> || u &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    Vector3f qvec = <span class="built_in">crossProduct</span>(tvec, e1);</span><br><span class="line">    v = <span class="built_in">dotProduct</span>(ray.direction, qvec) * det_inv;</span><br><span class="line">    <span class="keyword">if</span> (v &lt; <span class="number">0</span> || u + v &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    t_tmp = <span class="built_in">dotProduct</span>(e2, qvec) * det_inv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find ray triangle intersection</span></span><br><span class="line">    <span class="keyword">if</span> (t_tmp &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    inter.happened = <span class="literal">true</span>;</span><br><span class="line">    inter.distance = t_tmp;</span><br><span class="line">    inter.coords = <span class="built_in">ray</span>(t_tmp);</span><br><span class="line">    inter.normal = normal;</span><br><span class="line">    inter.obj = <span class="keyword">this</span>;</span><br><span class="line">    inter.m = m;</span><br><span class="line">    <span class="keyword">return</span> inter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bounds3.hpp</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">Bounds3::IntersectP</span><span class="params">(<span class="type">const</span> Ray&amp; ray, <span class="type">const</span> Vector3f&amp; invDir,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">const</span> std::array&lt;<span class="type">int</span>, <span class="number">3</span>&gt;&amp; dirIsNeg)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply is faster that Division</span></span><br><span class="line">    <span class="comment">// dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], use this to simplify your logic</span></span><br><span class="line">    <span class="comment">// test if ray bound intersects</span></span><br><span class="line">    Vector3f t_min = (<span class="keyword">this</span>-&gt;pMin - ray.origin) * invDir;</span><br><span class="line">    Vector3f t_max = (<span class="keyword">this</span>-&gt;pMax - ray.origin) * invDir;</span><br><span class="line">    <span class="keyword">if</span> (!dirIsNeg[<span class="number">0</span>]) std::<span class="built_in">swap</span>(t_min.x, t_max.x);</span><br><span class="line">    <span class="keyword">if</span> (!dirIsNeg[<span class="number">1</span>]) std::<span class="built_in">swap</span>(t_min.y, t_max.y);</span><br><span class="line">    <span class="keyword">if</span> (!dirIsNeg[<span class="number">2</span>]) std::<span class="built_in">swap</span>(t_min.z, t_max.z);</span><br><span class="line">    <span class="type">float</span> t_enter = <span class="built_in">fmax</span>(t_min.x, <span class="built_in">fmax</span>(t_min.y, t_min.z));</span><br><span class="line">    <span class="type">float</span> t_exit = <span class="built_in">fmin</span>(t_max.x, <span class="built_in">fmin</span>(t_max.y, t_max.z));</span><br><span class="line">    <span class="keyword">return</span> t_enter &lt;= t_exit &amp;&amp; t_exit &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BVH.cpp</span></span><br><span class="line"><span class="function">Intersection <span class="title">BVHAccel::getIntersection</span><span class="params">(BVHBuildNode* node, <span class="type">const</span> Ray&amp; ray)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Intersection inter;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 3&gt; dirIsNeg = &#123;<span class="built_in">int</span>(ray.direction.x &gt; <span class="number">0</span>), <span class="built_in">int</span>(ray.direction.y &gt; <span class="number">0</span>), <span class="built_in">int</span>(ray.direction.z &gt; <span class="number">0</span>)&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!node-&gt;bounds.<span class="built_in">IntersectP</span>(ray, ray.direction_inv, dirIsNeg))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> inter; <span class="comment">// No intersection in the current node</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;object == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;NULL Object Error&quot;</span>);</span><br><span class="line">        inter = node-&gt;object-&gt;<span class="built_in">getIntersection</span>(ray);</span><br><span class="line">        <span class="keyword">return</span> inter;</span><br><span class="line">    &#125;</span><br><span class="line">    Intersection left_inter = <span class="built_in">getIntersection</span>(node-&gt;left, ray);</span><br><span class="line">    Intersection right_inter = <span class="built_in">getIntersection</span>(node-&gt;right, ray);</span><br><span class="line">    <span class="keyword">return</span> left_inter.distance &lt; right_inter.distance ? left_inter : right_inter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完成后确保编译运行都没有问题后，我们再正式开始这次作业的实现，我们只需要对<code>castRay(const Ray ray, int depth)</code>in Scene.cpp进行实现，代码如下所示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector3f <span class="title">Scene::castRay</span><span class="params">(<span class="type">const</span> Ray &amp;ray, <span class="type">int</span> depth)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector3f L_dir = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, L_indir = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    Intersection intersection = Scene::<span class="built_in">intersect</span>(ray);</span><br><span class="line">    <span class="keyword">if</span> (!intersection.happened)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (intersection.m-&gt;<span class="built_in">hasEmission</span>())</span><br><span class="line">        <span class="keyword">return</span> intersection.m-&gt;<span class="built_in">getEmission</span>();</span><br><span class="line"></span><br><span class="line">    Intersection light_pos;</span><br><span class="line">    <span class="type">float</span> light_pdf = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="built_in">sampleLight</span>(light_pos, light_pdf);</span><br><span class="line">    Vector3f collision_light = light_pos.coords - intersection.coords;</span><br><span class="line">    <span class="type">float</span> dis = <span class="built_in">dotProduct</span>(collision_light, collision_light);</span><br><span class="line">    Vector3f collision_light_dir = collision_light.<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="function">Ray <span class="title">light_to_object_ray</span><span class="params">(intersection.coords, collision_light_dir)</span></span>;</span><br><span class="line">    Intersection light_ray_inter = Scene::<span class="built_in">intersect</span>(light_to_object_ray);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> f_r = intersection.m -&gt; <span class="built_in">eval</span>(ray.direction, collision_light_dir, intersection.normal);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Pay attention to the precision here</span></span><br><span class="line">    <span class="keyword">if</span> (light_ray_inter.distance - collision_light.<span class="built_in">norm</span>() &gt; <span class="number">-0.005</span>)&#123;</span><br><span class="line">        L_dir = light_pos.emit * f_r * <span class="built_in">dotProduct</span>(collision_light_dir, intersection.normal)</span><br><span class="line">                * <span class="built_in">dotProduct</span>(-collision_light_dir, light_pos.normal) / dis / light_pdf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">get_random_float</span>() &gt; RussianRoulette)</span><br><span class="line">        <span class="keyword">return</span> L_dir;</span><br><span class="line"></span><br><span class="line">    Vector3f w0 = intersection.m -&gt; <span class="built_in">sample</span>(ray.direction, intersection.normal).<span class="built_in">normalized</span>();</span><br><span class="line">    <span class="function">Ray <span class="title">object_to_object_ray</span><span class="params">(intersection.coords, w0)</span></span>;</span><br><span class="line">    Intersection islight = Scene::<span class="built_in">intersect</span>(object_to_object_ray);</span><br><span class="line">    <span class="keyword">if</span> (islight.happened &amp;&amp; !islight.m-&gt;<span class="built_in">hasEmission</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> pdf = intersection.m-&gt;<span class="built_in">pdf</span>(ray.direction, w0, intersection.normal);</span><br><span class="line">        f_r = intersection.m-&gt;<span class="built_in">eval</span>(ray.direction, w0, intersection.normal);</span><br><span class="line">        L_indir = <span class="built_in">castRay</span>(object_to_object_ray, depth + <span class="number">1</span>) * f_r * <span class="built_in">dotProduct</span>(w0, intersection.normal) / pdf / RussianRoulette;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L_dir + L_indir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终生成的图片，这里为了效果好一点我跑了128的SPP，大概需要跑几个小时，如下图</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/output-128.jpg"></p><h3><span id="多线程部分">多线程部分</span></h3><p>多线程部分只需要把<code>render()</code>函数中部分渲染相关代码修改为以下内容，对多行像素进行同时渲染。C++多线程教程可以参考<a href="https://blog.csdn.net/sjc_0910/article/details/118861539">C++11多线程（std::thread）详解_std::thread查线程名称_sjc_0910的博客-CSDN博客</a>。使用多线程的速度可以看到显著提升<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> spp = <span class="number">64</span>;  </span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;SPP: &quot;</span> &lt;&lt; spp &lt;&lt; <span class="string">&quot;\n&quot;</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> thread_num = <span class="number">16</span>;  </span><br><span class="line">std::thread th[thread_num];  </span><br><span class="line">std::atomic_int process = <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> times = scene.height / thread_num;  </span><br><span class="line"><span class="keyword">auto</span> func = [&amp;](<span class="type">uint32_t</span> y_min, <span class="type">uint32_t</span> y_max) &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> j = y_min; j &lt; y_max; ++j) &#123;  </span><br><span class="line">        <span class="type">int</span> m = j * scene.width;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; scene.width; ++i) &#123;  </span><br><span class="line">            <span class="comment">// generate primary ray direction  </span></span><br><span class="line">            <span class="keyword">auto</span> x = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;((<span class="number">2</span> * (i + <span class="number">0.5</span>) / (<span class="type">double</span>) scene.width - <span class="number">1</span>) * imageAspectRatio * scale);  </span><br><span class="line">            <span class="keyword">auto</span> y = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;((<span class="number">1</span> - <span class="number">2</span> * (j + <span class="number">0.5</span>) / (<span class="type">double</span>) scene.height) * scale);  </span><br><span class="line">  </span><br><span class="line">            Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(-x, y, <span class="number">1</span>));  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; spp; k++) &#123;  </span><br><span class="line">                framebuffer[m] += scene.<span class="built_in">castRay</span>(<span class="built_in">Ray</span>(eye_pos, dir), <span class="number">0</span>) / spp;  </span><br><span class="line">            &#125;  </span><br><span class="line">            m++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        mtx.<span class="built_in">lock</span>();  </span><br><span class="line">        process++;  </span><br><span class="line">        <span class="built_in">UpdateProgress</span>((<span class="type">float</span>) process / (<span class="type">float</span>) scene.height);  </span><br><span class="line">        mtx.<span class="built_in">unlock</span>();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; thread_num; ++i) &#123;  </span><br><span class="line">    th[i] = std::<span class="built_in">thread</span>(func, i * times, (i + <span class="number">1</span>) * times);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; thread_num; ++i) &#123;  </span><br><span class="line">    th[i].<span class="built_in">join</span>();  </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Join thread &quot;</span> &lt;&lt; i &lt;&lt; std::endl;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="built_in">UpdateProgress</span>(<span class="number">1.f</span>);</span><br></pre></td></tr></table></figure></p><h3><span id="微表面模型">微表面模型</span></h3><p>另外，除了多线程还有一个提高部分是微表面模型，这个模型应该只需要去改一下Material相关的部分，只不过这部分目前还是有点不太熟悉，打算等到Games202之后才回过头来做完。</p><h3><span id="参考资料">参考资料</span></h3><p><a href="https://blog.csdn.net/qq_41765657/article/details/121942469">GAMES101:作业7_南酒猫的博客-CSDN博客_games101作业7</a><a href="https://blog.csdn.net/sjc_0910/article/details/118861539">C++11多线程（std::thread）详解_std::thread查线程名称_sjc_0910的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Latex的使用详解笔记(常用数学符号、图片表格等)持续更新</title>
      <link href="/2022/09/30/other/late-yu-fa-bi-ji/"/>
      <url>/2022/09/30/other/late-yu-fa-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>本篇笔记用来记录在使用LaTeX过程中经常碰到的LaTeX数学符号以及一些基础的常用的操作比如添加图片，添加代码，如果有的话还会收藏一些比较实用的模板比如CV模板，作业模板论文模板等等。持续更新……</p><p><span id="more"></span></p><h1><span id="latex数学"><span class="math inline">\(\LaTeX\)</span>数学</span></h1><p>为了使用 AMS-LaTeX 提供的数学功能，我们需要在导言区加载<code>amsmath</code> 宏包：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\usepackage</span>&#123;amsmath&#125;</span><br></pre></td></tr></table></figure><p>LaTeX 的数学模式有两种：行内模式 (inline) 和行间模式(display)。前者在正文的行文中，插入数学公式；后者独立排列单独成行，并自动居中。</p><p>在行文中，使用<strong><code>$ ... $</code>可以插入行内公式</strong>，使用 <code>\[ ... \]</code>可以插入行间公式，如果需要对行间公式进行编号，则可以使用<code>equation</code> 环境：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><h2><span id="一些比较常用的特殊符号整理">一些比较常用的特殊符号整理</span></h2><ul><li><p>各类希腊字母编辑表</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>α</td><td>β</td><td>ω</td><td><span class="math inline">\(\Theta\)</span></td><td><span class="math inline">\(\Gamma\)</span></td><td><span class="math inline">\(\Omega\)</span></td></tr></tbody></table></li><li><p>上下标</p><p>​ 上标： ^ 如 <span class="math inline">\(x^2\)</span> ​ 下标： _ 如<span class="math inline">\(x_2\)</span> ​上下标如果多于一个字母或符号,需要用一对 {} 括起来。</p></li><li><p>根号： 如<code>$sqrt[n]&#123;5&#125;</code>为<span class="math inline">\(\sqrt[n]5\)</span></p></li><li><p>省略号：<code>$\dots \cdots$</code>分别为<span class="math inline">\(\dots \cdots\)</span></p></li><li><p>运算符 小的运算符(operator)例如 + - */等可以直接输入，其他特殊的有</p><table><colgroup><col style="width: 7%"><col style="width: 11%"><col style="width: 7%"><col style="width: 9%"><col style="width: 7%"><col style="width: 7%"><col style="width: 7%"><col style="width: 7%"><col style="width: 7%"><col style="width: 13%"><col style="width: 11%"></colgroup><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>±</td><td>×</td><td>÷</td><td>⋅</td><td>∩</td><td>∪</td><td>≥</td><td>≤</td><td>≠</td><td>≈</td><td>≡</td></tr></tbody></table><p>求和：<code>\sum_1^n</code>: <span class="math inline">\(\sum_1^n\)</span> 积分：<code>\int_1^n</code>:<span class="math inline">\(\int_1^n\)</span>极限：<code>lim_&#123;x \to \infty&#125;</code>: <span class="math inline">\(lim_{x \to \infty}\)</span>分数的表示：<code>\frac&#123;&#125;&#123;&#125;</code>如 <span class="math inline">\(\frac{3}{8}\)</span></p></li><li><p>字母的特殊标记</p><p>平均数: <code>\overline&#123;mean&#125;</code> or <code>\bar x</code>: <span class="math inline">\(\overline{mean} \text{ or } \bar m\)</span></p><p>Hat: <code>\hat&#123;\theta&#125;</code>: <span class="math inline">\(\hat{\theta}\)</span></p></li><li><p>矩阵与行列式<code>$$\begin&#123;matrix&#125;…\end&#123;matrix&#125;$$</code>，使用&amp;分隔同行元素，。如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">    1 <span class="built_in">&amp;</span> x <span class="built_in">&amp;</span> x<span class="built_in">^</span>2 <span class="keyword">\\</span></span><br><span class="line">    1 <span class="built_in">&amp;</span> y <span class="built_in">&amp;</span> y<span class="built_in">^</span>2 <span class="keyword">\\</span></span><br><span class="line">    1 <span class="built_in">&amp;</span> z <span class="built_in">&amp;</span> z<span class="built_in">^</span>2 <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{matrix}    1 &amp; x &amp; x^2 \\\\    1 &amp; y &amp; y^2 \\\\    1 &amp; z &amp; z^2 \\\\\end{matrix}\]</span> 行列式</p><p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">X=<span class="keyword">\left</span>|</span><br><span class="line">    <span class="keyword">\begin</span>&#123;matrix&#125;</span><br><span class="line">        x<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;12&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;1d&#125;<span class="keyword">\\</span></span><br><span class="line">        x<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;22&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;2d&#125;<span class="keyword">\\</span></span><br><span class="line">        <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\ddots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span><span class="keyword">\\</span></span><br><span class="line">        x<span class="built_in">_</span>&#123;m1&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;m2&#125; <span class="built_in">&amp;</span> <span class="keyword">\cdots</span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;md&#125;<span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\end</span>&#123;matrix&#125;</span><br><span class="line"><span class="keyword">\right</span>|</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure></p><p><span class="math display">\[X=\left|\begin{matrix}x_{11} &amp; x_{12} &amp; \cdots &amp; x_{1d}\\\\x_{21} &amp; x_{22} &amp; \cdots &amp; x_{2d}\\\\\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\\\x_{m1} &amp; x_{m2} &amp; \cdots &amp; x_{md}\\\\\end{matrix}\right|\]</span></p></li><li><p>分隔符 各种括号用 <code>() [] &#123;&#125;</code> <code>\langle</code><code>\rangle</code> (<span class="math inline">\(\langle\rangle\)</span>)等命令表示,注意花括号通常用来输入命令和环境的参数,所以在数学公式中它们前面要加\。可以在上述分隔符前面加 \big \Big \bigg \Bigg等命令来调整大小。</p></li><li><p>方程</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">E=mc<span class="built_in">^</span>2</span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{equation}E=mc^2\end{equation}\]</span></p></li><li><p>分段函数</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f(n) =</span><br><span class="line"><span class="keyword">\begin</span>&#123;cases&#125;</span><br><span class="line">n/2,  <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if <span class="built_in">$</span>n<span class="built_in">$</span> is even&#125; <span class="keyword">\\</span></span><br><span class="line">3n+1, <span class="built_in">&amp;</span> <span class="keyword">\text</span>&#123;if <span class="built_in">$</span>n<span class="built_in">$</span> is odd&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;cases&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[f(n) =\begin{cases}n/2,  &amp; \text{if $n$ is even} \\\\3n+1, &amp; \text{if $n$ is odd}\end{cases}\]</span></p></li><li><p>方程组</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span> </span><br><span class="line"><span class="keyword">\begin</span>&#123;array&#125;&#123;c&#125;</span><br><span class="line">    a<span class="built_in">_</span>1x+b<span class="built_in">_</span>1y+c<span class="built_in">_</span>1z=d<span class="built_in">_</span>1 <span class="keyword">\\</span> </span><br><span class="line">    a<span class="built_in">_</span>2x+b<span class="built_in">_</span>2y+c<span class="built_in">_</span>2z=d<span class="built_in">_</span>2 <span class="keyword">\\</span> </span><br><span class="line">    a<span class="built_in">_</span>3x+b<span class="built_in">_</span>3y+c<span class="built_in">_</span>3z=d<span class="built_in">_</span>3</span><br><span class="line"><span class="keyword">\end</span>&#123;array&#125;</span><br><span class="line"><span class="keyword">\right</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\left\{\begin{array}{c}     a_1x+b_1y+c_1z=d_1 \\\\     a_2x+b_2y+c_2z=d_2 \\\\     a_3x+b_3y+c_3z=d_3\end{array}\right.\]</span></p></li></ul><h2><span id="常用公式">常用公式</span></h2><ul><li><p>线性模型</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h(<span class="keyword">\theta</span>) = <span class="keyword">\sum</span><span class="built_in">_</span>&#123;j = 0&#125; <span class="built_in">^</span>n <span class="keyword">\theta</span><span class="built_in">_</span>j x<span class="built_in">_</span>j</span><br></pre></td></tr></table></figure><p><span class="math display">\[h(\theta) = \sum_{j = 0} ^n \theta_j x_j\]</span></p></li><li><p>均方误差</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">J(<span class="keyword">\theta</span>) = <span class="keyword">\frac</span>&#123;1&#125;&#123;2m&#125;<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i = 0&#125; <span class="built_in">^</span>m(y<span class="built_in">^</span>i - h<span class="built_in">_</span><span class="keyword">\theta</span> (x<span class="built_in">^</span>i))<span class="built_in">^</span>2</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[J(\theta) = \frac{1}{2m}\sum_{i = 0} ^m(y^i - h_\theta (x^i))^2\]</span></p></li><li><p>批量梯度下降</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> J(<span class="keyword">\theta</span>)&#125;&#123;<span class="keyword">\partial</span><span class="keyword">\theta</span><span class="built_in">_</span>j&#125;=<span class="keyword">\frac</span>1m<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=0&#125;<span class="built_in">^</span>m(y<span class="built_in">^</span>i-h<span class="built_in">_</span><span class="keyword">\theta</span>(x<span class="built_in">^</span>i))x<span class="built_in">^</span>i<span class="built_in">_</span>j</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{\partialJ(\theta)}{\partial\theta_j}=-\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j\]</span></p></li><li><p>推导过程：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;align&#125;</span><br><span class="line"><span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span> J(<span class="keyword">\theta</span>)&#125;&#123;<span class="keyword">\partial</span><span class="keyword">\theta</span><span class="built_in">_</span>j&#125;</span><br><span class="line"><span class="built_in">&amp;</span> = -<span class="keyword">\frac</span>1m<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=0&#125;<span class="built_in">^</span>m(y<span class="built_in">^</span>i-h<span class="built_in">_</span><span class="keyword">\theta</span>(x<span class="built_in">^</span>i)) <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#125;&#123;<span class="keyword">\partial</span><span class="keyword">\theta</span><span class="built_in">_</span>j&#125;(y<span class="built_in">^</span>i-h<span class="built_in">_</span><span class="keyword">\theta</span>(x<span class="built_in">^</span>i)) <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> = -<span class="keyword">\frac</span>1m<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=0&#125;<span class="built_in">^</span>m(y<span class="built_in">^</span>i-h<span class="built_in">_</span><span class="keyword">\theta</span>(x<span class="built_in">^</span>i)) <span class="keyword">\frac</span>&#123;<span class="keyword">\partial</span>&#125;&#123;<span class="keyword">\partial</span><span class="keyword">\theta</span><span class="built_in">_</span>j&#125;(<span class="keyword">\sum</span><span class="built_in">_</span>&#123;j=0&#125;<span class="built_in">^</span>n<span class="keyword">\theta</span><span class="built_in">_</span>jx<span class="built_in">_</span>j<span class="built_in">^</span>i-y<span class="built_in">^</span>i) <span class="keyword">\\</span></span><br><span class="line"><span class="built_in">&amp;</span> = -<span class="keyword">\frac</span>1m<span class="keyword">\sum</span><span class="built_in">_</span>&#123;i=0&#125;<span class="built_in">^</span>m(y<span class="built_in">^</span>i-h<span class="built_in">_</span><span class="keyword">\theta</span>(x<span class="built_in">^</span>i))x<span class="built_in">^</span>i<span class="built_in">_</span>j</span><br><span class="line"><span class="keyword">\end</span>&#123;align&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\begin{align}\frac{\partial J(\theta)}{\partial\theta_j}&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))\frac{\partial}{\partial\theta_j}(y^i-h_\theta(x^i)) \\\\&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))\frac{\partial}{\partial\theta_j}(\sum_{j=0}^n\theta_jx_j^i-y^i) \\\\&amp; = -\frac1m\sum_{i=0}^m(y^i-h_\theta(x^i))x^i_j\end{align}\]</span></p></li><li><p>组合数：<span class="math inline">\(\tbinom{n}{m}\)</span><code>$\tbinom&#123;n&#125;&#123;m&#125;$</code>或者 <span class="math inline">\(C^m_n\)</span></p></li><li><p>线性回归的解析解 <span class="math display">\[\begin{align}\theta_1 &amp;=\frac{\sum_{i=1}^m{(x^{(i)}-\bar{x})(y^{(i)}-\bar{y})}}{\sum^m_{i=1}{(x^{(i)}-\bar{x})^2}}\\\theta_0 &amp;= \bar{y}-\theta_1\bar{x}\end{align}\]</span></p><p><span class="math display">\[\hat{\Theta}=\Theta^*=(\mathbf{X}^T\mathbf{X})^{-1}X^TY\]</span></p></li></ul><h2><span id="参考资料">参考资料</span></h2><ol type="1"><li><p><a href="https://liam.page/2014/09/08/latex-introduction/">一份其实很短的LaTeX 入门文档</a></p></li><li><p><a href="https://blog.csdn.net/baidu_38060633/article/details/79183905">试试LaTeX插入数学公式</a></p></li><li><p><a href="https://www.cnblogs.com/Sinte-Beuve/p/6160905.html">在博客中使用LaTeX插入数学公式</a></p></li><li><p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJaxbasic tutorial and quick reference</a></p></li></ol><h1><span id="在latex中插入图片">在<span class="math inline">\(\LaTeX\)</span>中插入图片</span></h1><h2><span id="单张图片插入">单张图片插入</span></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[H]</span><br><span class="line">    <span class="keyword">\centering</span><span class="comment">% 设置居中</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=10cm]&#123;fig/Figure<span class="built_in">_</span>2.png&#125;<span class="comment">% 图片路径和大小设置</span></span><br><span class="line">    <span class="keyword">\caption</span>&#123;PDF derived from CHNS&#x27;s data &#125;<span class="comment">% 图片下文字(caption)</span></span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/taCXRdc7gUiYHb6.png"></p><p>[注]：</p><ol type="1"><li><p>所需要的宏包：<code>\usepackage&#123;graphicx&#125;</code></p></li><li><p>[htbp] 为调整图片排版位置选项，说明如下：</p><p>[h]当前位置。将图形放置在正文文本中给出该图形环境的地方。如果本页所剩的页面不够，这一参数将不起作用。[t]顶部。将图形放置在页面的顶部。 [b]底部。将图形放置在页面的底部。[p]浮动页。将图形放置在一只允许有浮动对象的页面上。</p></li><li><p>[htbp]选项是<span class="math inline">\(\LaTeX\)</span>自动排版的，会导致后来写的文本自动紧接着前面的文本。如果需要指定图片在当前位置，就需要</p><ol type="1"><li>引入宏包<code>\usepackage&#123;float&#125;</code></li><li><code>\begin&#123;figure&#125;[H]</code></li></ol></li></ol><h2><span id="排版两张图片在同一行">排版两张图片在同一行</span></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[H]</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.48<span class="keyword">\textwidth</span>&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=6cm]&#123;fig/Figure3-Female-Height.png&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig<span class="built_in">_</span>22&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Female Height&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line">    <span class="keyword">\begin</span>&#123;minipage&#125;[t]&#123;0.48<span class="keyword">\textwidth</span>&#125;</span><br><span class="line">    <span class="keyword">\centering</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=6cm]&#123;fig/Figure2-Male-Height.png&#125;</span><br><span class="line">    <span class="keyword">\caption</span>&#123;Male Height&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;fig<span class="built_in">_</span>23&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;minipage&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/Wk1q9j3bBhGlT2Y.png"></p><p>基本用法和插入单张图片非常相似，主要的区别是多了<code>minipage</code>的使用。</p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/qq_38526623/article/details/103737589">Latex如何插入图片</a></p><p><a href="https://blog.csdn.net/weixin_42141390/article/details/103773143">Latex并排插入两张图片</a></p><p><a href="https://blog.csdn.net/weixin_39278265/article/details/108781140">[LaTeX]用minipage来排版多张图片（子图片）！（以及用subfigure而不是subfloat来排版代码型图片）</a></p><h1><span id="latex定理-引理-证明"><span class="math inline">\(\LaTeX\)</span>定理、引理、证明</span></h1><h2><span id="定理">定理</span></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\newtheorem</span>&#123;thm&#125;&#123;<span class="keyword">\bf</span> Theorem&#125;[section]</span><br><span class="line"><span class="keyword">\begin</span>&#123;thm&#125;<span class="keyword">\label</span>&#123;thm1&#125;</span><br><span class="line">    Let <span class="built_in">$</span>f<span class="built_in">_</span>1<span class="built_in">$</span> and <span class="built_in">$</span>f<span class="built_in">_</span>2<span class="built_in">$</span> be normal densities with respective means <span class="built_in">$</span><span class="keyword">\mu</span><span class="built_in">_</span>1<span class="built_in">$</span> and <span class="built_in">$</span><span class="keyword">\mu</span><span class="built_in">_</span>2<span class="built_in">$</span> and common variance <span class="built_in">$</span><span class="keyword">\sigma</span><span class="built_in">^</span>2<span class="built_in">$</span>, and let <span class="built_in">$</span>f<span class="built_in">$</span> be the </span><br><span class="line">    mixture density <span class="built_in">$</span>0.5 f<span class="built_in">_</span>1+0.5 f<span class="built_in">_</span>2<span class="built_in">$</span>. Then <span class="built_in">$</span>f<span class="built_in">$</span> is unimodal if and only if <span class="built_in">$</span>|<span class="keyword">\mu</span><span class="built_in">_</span>2-<span class="keyword">\mu</span><span class="built_in">_</span>1 | <span class="keyword">\leq</span>  2<span class="keyword">\sigma</span><span class="built_in">$</span>. [4]</span><br><span class="line"><span class="keyword">\end</span>&#123;thm&#125; </span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/jko9lMg8feHp4zA.png"></p><h2><span id="证明">证明</span></h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;proof&#125;</span><br><span class="line">    A normal density is concave down between its inflection points <span class="built_in">$</span><span class="keyword">\mu</span> <span class="keyword">\pm</span> <span class="keyword">\sigma</span><span class="built_in">$</span> and concave up elsewhere. Note that <span class="built_in">$</span>f<span class="built_in">$</span> is symmetric </span><br><span class="line">    around <span class="built_in">$</span>m=(<span class="keyword">\mu</span><span class="built_in">_</span>1+<span class="keyword">\mu</span><span class="built_in">_</span>2)/2<span class="built_in">$</span> . Now if <span class="built_in">$</span>|<span class="keyword">\mu</span><span class="built_in">_</span>2-<span class="keyword">\mu</span><span class="built_in">_</span>1 |&gt;2<span class="keyword">\sigma</span><span class="built_in">$</span>, then both <span class="built_in">$</span>f<span class="built_in">_</span>1<span class="built_in">$</span> and <span class="built_in">$</span>f<span class="built_in">_</span>2<span class="built_in">$</span> are concave up at <span class="built_in">$</span>m<span class="built_in">$</span>, hence so is <span class="built_in">$</span>f<span class="built_in">$</span>. Therefore f has a </span><br><span class="line">    local minimum at <span class="built_in">$</span>m<span class="built_in">$</span>, which implies that <span class="built_in">$</span>f<span class="built_in">$</span> is bimodal. Conversely, if <span class="built_in">$</span>|<span class="keyword">\mu</span><span class="built_in">_</span>2-<span class="keyword">\mu</span><span class="built_in">_</span>1 |&lt;2<span class="keyword">\sigma</span><span class="built_in">$</span>, then both <span class="built_in">$</span>f<span class="built_in">_</span>1<span class="built_in">$</span> and <span class="built_in">$</span>f<span class="built_in">_</span>2<span class="built_in">$</span> are concave down </span><br><span class="line">    at <span class="built_in">$</span>m<span class="built_in">$</span>, hence so is <span class="built_in">$</span>f<span class="built_in">$</span>. Thus, <span class="built_in">$</span>f<span class="built_in">$</span> has a local maximum at <span class="built_in">$</span>m<span class="built_in">$</span> and is therefore unimodal. In the borderline case <span class="built_in">$</span>|<span class="keyword">\mu</span><span class="built_in">_</span>2-<span class="keyword">\mu</span><span class="built_in">_</span>1 |=2<span class="keyword">\sigma</span><span class="built_in">$</span> the </span><br><span class="line">    second derivative of <span class="built_in">$</span>f<span class="built_in">$</span> vanishes, but the fourth derivative can be used to show that <span class="built_in">$</span>f<span class="built_in">$</span> has a maximum at <span class="built_in">$</span>m<span class="built_in">$</span> and thus is unimodal. [2]</span><br><span class="line">    <span class="keyword">\begin</span>&#123;figure&#125;[H]</span><br><span class="line">        <span class="keyword">\centering</span></span><br><span class="line">        <span class="keyword">\includegraphics</span>[width=14cm]&#123;fig/proof.png&#125;</span><br><span class="line">        <span class="keyword">\caption</span>&#123;Two cases in the theorem &#123;[2]&#125;&#125;</span><br><span class="line">    <span class="keyword">\end</span>&#123;figure&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;proof&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/06/QHlbVTNd6vcpeK9.png"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://blog.csdn.net/miracle_fans/article/details/78255650">Latex中定理、引理、证明、假设</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> Latex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：最小生成树(Minimum Spanning Tree)</title>
      <link href="/2022/09/28/algorithms/suan-fa-minimum-spanning-tree/"/>
      <url>/2022/09/28/algorithms/suan-fa-minimum-spanning-tree/</url>
      
        <content type="html"><![CDATA[<p>生成树指的是一个连通图G的覆盖所有顶点的无环子图，最小生成树指的是所有生成树中加权和最小的生成树。</p><blockquote><p>最小生成树的应用：聚类分析、网络架构设计、VLSI布线设计等诸多实际应用问题，都可转化并描述为最小支撑树的构造问题。在这些应用中，边的权重大多对应于某种可量化的成本，因此作为对应优化问题的基本模型，最小支撑树的价值不言而喻。——《数据结构C++版》</p></blockquote><p>求最小支撑树的算法主要采用贪心算法，最著名的两个算法分别是Prim算法和Kruskal算法。</p><p>本篇主要参考<a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">Kruskal’sMinimum Spanning Tree Algorithm | Greedy Algo-2 -GeeksforGeeks</a>以及以及<a href="https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/?ref=lbp">Prim’sMinimum Spanning Tree (MST) | Greedy Algo-5 -GeeksforGeeks</a>，GeeksforGeeks上的数据结构今天刚好搜到了，确实讲的不错，转载收藏一下作为笔记。</p><p><span id="more"></span></p><h3><span id="prim算法">Prim算法</span></h3><p>使用Prim算法之前，需要了解图论中的一个概念。割(Cut or Cross edges)指的是连接两个子图的边。Prim算法从图中的任意一个点出发，选出所有割中的最小边加入到MST中，直到所有的顶点都在MST中。算法的思想很简单，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A C++ program for Prim&#x27;s Minimum</span></span><br><span class="line"><span class="comment">// Spanning Tree (MST) algorithm. The program is</span></span><br><span class="line"><span class="comment">// for adjacency matrix representation of the graph</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Number of vertices in the graph</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> V 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to find the vertex with</span></span><br><span class="line"><span class="comment">// minimum key value, from the set of vertices</span></span><br><span class="line"><span class="comment">// not yet included in MST</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minKey</span><span class="params">(<span class="type">int</span> key[], <span class="type">bool</span> mstSet[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize min value</span></span><br><span class="line">    <span class="type">int</span> min = INT_MAX, min_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line">        <span class="keyword">if</span> (mstSet[v] == <span class="literal">false</span> &amp;&amp; key[v] &lt; min)</span><br><span class="line">            min = key[v], min_index = v;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min_index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A utility function to print the</span></span><br><span class="line"><span class="comment">// constructed MST stored in parent[]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMST</span><span class="params">(<span class="type">int</span> parent[], <span class="type">int</span> graph[V][V])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Edge \tWeight\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; V; i++)</span><br><span class="line">        cout &lt;&lt; parent[i] &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; \t&quot;</span></span><br><span class="line">             &lt;&lt; graph[i][parent[i]] &lt;&lt; <span class="string">&quot; \n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to construct and print MST for</span></span><br><span class="line"><span class="comment">// a graph represented using adjacency</span></span><br><span class="line"><span class="comment">// matrix representation</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">primMST</span><span class="params">(<span class="type">int</span> graph[V][V])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Array to store constructed MST</span></span><br><span class="line">    <span class="type">int</span> parent[V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key values used to pick minimum weight edge in cut</span></span><br><span class="line">    <span class="type">int</span> key[V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// To represent set of vertices included in MST</span></span><br><span class="line">    <span class="type">bool</span> mstSet[V];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize all keys as INFINITE</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; V; i++)</span><br><span class="line">        key[i] = INT_MAX, mstSet[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Always include first 1st vertex in MST.</span></span><br><span class="line">    <span class="comment">// Make key 0 so that this vertex is picked as first</span></span><br><span class="line">    <span class="comment">// vertex.</span></span><br><span class="line">    key[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    parent[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">// First node is always root of MST</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// The MST will have V vertices</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> count = <span class="number">0</span>; count &lt; V - <span class="number">1</span>; count++) &#123;</span><br><span class="line">        <span class="comment">// Pick the minimum key vertex from the</span></span><br><span class="line">        <span class="comment">// set of vertices not yet included in MST</span></span><br><span class="line">        <span class="type">int</span> u = <span class="built_in">minKey</span>(key, mstSet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the picked vertex to the MST Set</span></span><br><span class="line">        mstSet[u] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update key value and parent index of</span></span><br><span class="line">        <span class="comment">// the adjacent vertices of the picked vertex.</span></span><br><span class="line">        <span class="comment">// Consider only those vertices which are not</span></span><br><span class="line">        <span class="comment">// yet included in MST</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; V; v++)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// graph[u][v] is non zero only for adjacent</span></span><br><span class="line">            <span class="comment">// vertices of m mstSet[v] is false for vertices</span></span><br><span class="line">            <span class="comment">// not yet included in MST Update the key only</span></span><br><span class="line">            <span class="comment">// if graph[u][v] is smaller than key[v]</span></span><br><span class="line">            <span class="keyword">if</span> (graph[u][v] &amp;&amp; mstSet[v] == <span class="literal">false</span></span><br><span class="line">                &amp;&amp; graph[u][v] &lt; key[v])</span><br><span class="line">                parent[v] = u, key[v] = graph[u][v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the constructed MST</span></span><br><span class="line">    <span class="built_in">printMST</span>(parent, graph);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Driver&#x27;s code</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Let us create the following graph</span></span><br><span class="line"><span class="comment">        2 3</span></span><br><span class="line"><span class="comment">    (0)--(1)--(2)</span></span><br><span class="line"><span class="comment">    | / \ |</span></span><br><span class="line"><span class="comment">    6| 8/ \5 |7</span></span><br><span class="line"><span class="comment">    | / \ |</span></span><br><span class="line"><span class="comment">    (3)-------(4)</span></span><br><span class="line"><span class="comment">            9 */</span></span><br><span class="line">    <span class="type">int</span> graph[V][V] = &#123; &#123; <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">5</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">7</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">6</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">9</span> &#125;,</span><br><span class="line">                        &#123; <span class="number">0</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">0</span> &#125; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print the solution</span></span><br><span class="line">    <span class="built_in">primMST</span>(graph);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This code is contributed by rathbhupendra</span></span><br></pre></td></tr></table></figure><p>这里的代码主要使用的是图的邻接矩阵表示，采用的思想是维护一个与剩余的子图相连的割的数组，在添加边的时候更新这个数组，每次添加的时候就可以从这个数组中寻找最小的割，时间复杂度为O(V^2)，还有另外一种邻接表的表示方法，使用邻接表和优先队列可以将时间复杂度降为O(Elog V)，更加复杂一些，参考<a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/">Prim’sMST for Adjacency List Representation | Greedy Algo-6 -GeeksforGeeks</a>。</p><h3><span id="kruskal算法">Kruskal算法</span></h3><p>首先，将G中的所有边E按照权重从小到大进行排序，然后依次遍历，如果将当前的边加入当前的子图中不会产生环，那么就加入当前的边，否则继续遍历下一个最小边，直到所有的边都被遍历。这里产生的一个问题就是如何判断是否是有环图，这里我们可以是用压缩路径的并查集算法，参考<a href="https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/">Union-FindAlgorithm | Set 2 (Union By Rank and Path Compression) -GeeksforGeeks</a>，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">    <span class="type">int</span> rank;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Union</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    node *nodes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> node[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            nodes[i].rank = <span class="number">1</span>;</span><br><span class="line">            nodes[i].parent = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Union</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[i].parent != i)</span><br><span class="line">            nodes[i].parent = <span class="built_in">find</span>(nodes[i].parent);</span><br><span class="line">        <span class="keyword">return</span> nodes[i].parent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i_root = <span class="built_in">find</span>(i);</span><br><span class="line">        <span class="type">int</span> j_root = <span class="built_in">find</span>(j);</span><br><span class="line">        <span class="keyword">if</span> (nodes[i_root].rank &lt; nodes[j_root].rank) &#123;</span><br><span class="line">            nodes[i_root].parent = nodes[j_root].parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodes[i_root].rank &gt; nodes[j_root].rank) &#123;</span><br><span class="line">            nodes[j_root].parent = nodes[i_root].parent;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodes[i_root].parent != nodes[j_root].parent) &#123;</span><br><span class="line">            nodes[j_root].parent = nodes[i_root].parent;</span><br><span class="line">            nodes[i_root].rank += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edgelist;</span><br><span class="line">    <span class="type">int</span> V;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Graph</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123; <span class="keyword">this</span>-&gt;V = v; &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">get_edgelist</span>() <span class="type">const</span> &#123; <span class="keyword">return</span> edgelist; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> V; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> source, <span class="type">int</span> destination, <span class="type">int</span> weight)</span> </span>&#123; edgelist.<span class="built_in">push_back</span>(&#123;weight, source, destination&#125;); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; edge)</span> </span>&#123; edgelist.<span class="built_in">push_back</span>(edge); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_total_weights</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; edge : edgelist) &#123;</span><br><span class="line">           sum += edge[<span class="number">0</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> Graph <span class="title">kruskals_mst</span><span class="params">(<span class="type">const</span> Graph&amp; graph)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edgelist = graph.<span class="built_in">get_edgelist</span>();</span><br><span class="line">        <span class="built_in">sort</span>(edgelist.<span class="built_in">begin</span>(), edgelist.<span class="built_in">end</span>());</span><br><span class="line">        <span class="function">Union <span class="title">s</span><span class="params">(graph.get_size())</span></span>;</span><br><span class="line">        Graph mst = <span class="built_in">Graph</span>(graph.<span class="built_in">get_size</span>());</span><br><span class="line">        <span class="keyword">for</span> (vector&lt;<span class="type">int</span>&gt; edge: edgelist) &#123;</span><br><span class="line">            <span class="comment">// determine whether put the edge into mst will cause a cycle</span></span><br><span class="line">            <span class="comment">// if the two vertices do not belong to the same root</span></span><br><span class="line">            <span class="comment">// they will introduce a cycle</span></span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(edge[<span class="number">1</span>]) != s.<span class="built_in">find</span>(edge[<span class="number">2</span>])) &#123;</span><br><span class="line">                <span class="comment">// merge the two subsets together</span></span><br><span class="line">                s.<span class="built_in">merge</span>(edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">                mst.<span class="built_in">add_edge</span>(edge);</span><br><span class="line">                cout &lt;&lt; edge[<span class="number">1</span>] &lt;&lt; <span class="string">&quot; -- &quot;</span> &lt;&lt; edge[<span class="number">2</span>] &lt;&lt; <span class="string">&quot; == &quot;</span> &lt;&lt; edge[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* Let us create following weighted graph</span></span><br><span class="line"><span class="comment">                   10</span></span><br><span class="line"><span class="comment">              0--------1</span></span><br><span class="line"><span class="comment">              |  \     |</span></span><br><span class="line"><span class="comment">             6|   5\   |15</span></span><br><span class="line"><span class="comment">              |      \ |</span></span><br><span class="line"><span class="comment">              2--------3</span></span><br><span class="line"><span class="comment">                  4       */</span></span><br><span class="line">    <span class="function">Graph <span class="title">g</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">    g.<span class="built_in">add_edge</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Function call</span></span><br><span class="line">    Graph::<span class="built_in">kruskals_mst</span>(g);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="参考资料">参考资料</span></h3><ol type="1"><li>《数据结构C++版-邓俊辉》6.11 最小支撑树</li><li><a href="https://www.geeksforgeeks.org/kruskals-minimum-spanning-tree-algorithm-greedy-algo-2/">Kruskal’sMinimum Spanning Tree Algorithm | Greedy Algo-2 - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/prims-minimum-spanning-tree-mst-greedy-algo-5/?ref=lbp">Prim’sMinimum Spanning Tree (MST) | Greedy Algo-5 - GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/union-find-algorithm-set-2-union-by-rank/">Union-FindAlgorithm | Set 2 (Union By Rank and Path Compression) -GeeksforGeeks</a></li><li><a href="https://www.geeksforgeeks.org/prims-mst-for-adjacency-list-representation-greedy-algo-6/">Prim’sMST for Adjacency List Representation | Greedy Algo-6 -GeeksforGeeks</a></li><li><a href="https://zhuanlan.zhihu.com/p/93647900">算法学习笔记(1) :并查集 - 知乎 (zhihu.com)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyTorch Inplace Operation Notes</title>
      <link href="/2022/09/25/bug/pytorch-inplace-operation-notes/"/>
      <url>/2022/09/25/bug/pytorch-inplace-operation-notes/</url>
      
        <content type="html"><![CDATA[<p>最近在跑实验的时候遇到了这样一个Bug花了很久才解决，记录一下学习一波以免以后再遇到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.FloatTensor [3</span><br><span class="line">, 64, 7, 7]] is at version 2; expected version 1 instead. Hint: enable anomaly detection to find the operation that failed to compute it</span><br><span class="line">s gradient, with torch.autograd.set_detect_anomaly(True).</span><br></pre></td></tr></table></figure><p><span id="more"></span></p><h3><span id="关于inplace-operation">关于Inplace Operation</span></h3><p>首先，这个问题从报错中可以看到是由于inplaceoperation导致的。经过查找，inplaceoperation指的就是PyTorch在计算一个值的时候不创建新的变量进行复制，而是直接改变原来的变量的值。比如以下代码，第一个就不是inplaceoperation而后两个就是inplace operation。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = torch.rand(<span class="number">2</span>)</span><br><span class="line">y = torch.rand(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># non-inplace operation</span></span><br><span class="line">z = x + y</span><br><span class="line"><span class="comment"># inplace operation</span></span><br><span class="line">x.add_(y)</span><br><span class="line">x += y</span><br></pre></td></tr></table></figure><h3><span id="解决过程">解决过程</span></h3><p>首先在网上搜到的资料都是说尽量移除掉所有的inplaceoperation，包括把ActivationLayer的<code>inplace=True</code>去掉等等，但是都无法解决。然后就根据报错中的提示，使用<code>torch.autograd.set_detect_anomaly(True)</code>查找在哪里发生了inplaceoperation (参考<a href="https://github.com/pytorch/pytorch/issues/15803">Debugging featurefor "modified by an inplace operation" errors · Issue #15803 ·pytorch/pytorch · GitHub</a>)，最后提示如下报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[W python_anomaly_mode.cpp:104] Warning: Error detected in CudnnConvolutionBackward. Traceback of forward call that caused the error:</span><br><span class="line">  File &quot;./train.py&quot;, line 44, in &lt;module&gt;</span><br><span class="line">    model.optimize_parameters()</span><br><span class="line">  File &quot;xxxx.py&quot;, line 374, in optimize_parameters</span><br><span class="line">    self.backward_all_net()</span><br><span class="line">  File &quot;xxxx.py&quot;, line 273, in backward_all_net</span><br><span class="line">    _, _, _, fake_B_x6_processed = self.pixelnet(fake_B_x6)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/module.py&quot;, line 1051, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;xxxx.py&quot;, line 282, in forward</span><br><span class="line">    output = self.model_3(feature_256)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/module.py&quot;, line 1051, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/container.py&quot;, line 139, in forward</span><br><span class="line">    input = module(input)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/module.py&quot;, line 1051, in _call_impl</span><br><span class="line">    return forward_call(*input, **kwargs)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/conv.py&quot;, line 443, in forward</span><br><span class="line">    return self._conv_forward(input, self.weight, self.bias)</span><br><span class="line">  File &quot;/usr/local/lib/python3.6/dist-packages/torch/nn/modules/conv.py&quot;, line 440, in _conv_forward</span><br><span class="line">    self.padding, self.dilation, self.groups)</span><br><span class="line"> (function _print_stack)</span><br><span class="line">RuntimeError: one of the variables needed for gradient computation has been modified by an inplace operation: [torch.cuda.FloatTensor [3</span><br><span class="line">, 64, 7, 7]] is at version 2; expected version 1 instead. Hint: the backtrace further above shows the operation that failed to compute i</span><br><span class="line">ts gradient. The variable in question was changed in there or anywhere later. Good luck!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后发现貌似是在conv层发生了inplaceoperation，但是实在没有头绪，最后又找到一篇博文与我的情况非常类似(<a href="https://www.cnblogs.com/js2hou/p/13923089.html">RuntimeError: oneof the variables needed for gradient computation has been modified by aninplace operation - Js2Hou - 博客园(cnblogs.com)</a>)，最后发现是代码执行的顺序问题，原本的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">optimize_parameters</span>(<span class="params">self</span>):</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.backward_all_net()        </span><br><span class="line">    </span><br><span class="line">    <span class="variable language_">self</span>.optimizer_gridnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.loss_gridnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_gridnet.step()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.optimizer_pixelnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.loss_pixelnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_pixelnet.step()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.optimizer_depixelnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.loss_depixelnet.backward()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_depixelnet.step()<span class="comment"># 出错处</span></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_gridnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.backward_D_gridnet()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_gridnet.step()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_pixelnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.backward_D_pixelnet()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_pixelnet.step()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_depixelnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.backward_D_depixelnet()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_depixelnet.step()</span><br></pre></td></tr></table></figure><p>修改后的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">optimize_parameters</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_gridnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_pixelnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_depixelnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_gridnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_pixelnet.zero_grad()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_depixelnet.zero_grad()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.backward_all_net()        </span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.loss_gridnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    <span class="variable language_">self</span>.loss_pixelnet.backward(retain_graph=<span class="literal">True</span>)</span><br><span class="line">    <span class="variable language_">self</span>.loss_depixelnet.backward()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.optimizer_gridnet.step()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_pixelnet.step()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_depixelnet.step()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.backward_D_gridnet()</span><br><span class="line">    <span class="variable language_">self</span>.backward_D_pixelnet()</span><br><span class="line">    <span class="variable language_">self</span>.backward_D_depixelnet()</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_gridnet.step()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_pixelnet.step()</span><br><span class="line">    <span class="variable language_">self</span>.optimizer_D_depixelnet.step()</span><br></pre></td></tr></table></figure><p>终于顺利解决！！！</p><h3><span id="参考资料">参考资料</span></h3><ol type="1"><li><p><a href="https://zhuanlan.zhihu.com/p/38475183">关于 pytorchinplace operation, 需要知道的几件事 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://blog.csdn.net/york1996/article/details/81835873">在PyTorch中in-placeoperation的含义_York1996的博客-CSDN博客_inplace operation</a></p></li><li><p><a href="https://github.com/pytorch/pytorch/issues/15803">Debugging featurefor "modified by an inplace operation" errors · Issue #15803 ·pytorch/pytorch · GitHub</a></p></li><li><p><a href="https://www.cnblogs.com/js2hou/p/13923089.html">RuntimeError: oneof the variables needed for gradient computation has been modified by aninplace operation - Js2Hou - 博客园 (cnblogs.com)</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> CV </tag>
            
            <tag> PyTorch </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图像像素画生成方法总结（图像下采样）</title>
      <link href="/2022/07/10/computervision/tu-pian-xia-cai-yang-duo-chong-fang-fa-zong-jie/"/>
      <url>/2022/07/10/computervision/tu-pian-xia-cai-yang-duo-chong-fang-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<p>图片的上采样和下采样分别对应图片的放大和缩小，在对图像进行采样的过程中会造成不同程度的模糊。图像的像素画生成采用的方法就是图片下采用的方法。本文会对图像像素化的方法进行总结。</p><span id="more"></span><h1><span id="传统的插值方法">传统的插值方法</span></h1><p>首先，从<code>OpenCV</code>中的<code>cv2.resize()</code>中所采用的方法来看，传统的图片采样方法主要分为以下几种(括号中为在<code>OpenCV</code>中的插值Flag)： 1. Nearest Neighbor(INTER_NEAREST) 2. Linear Interpolation (INTER_LINEAR) 3. BicubicInterpolation (INTER_CUBIC) 4. Area Interpolation (INTER_AREA) 5.Lanczos interpolation (INTER_LANCZOS4)</p><p>我们定义一张图片为一个<code>ndarray</code>，image width <span class="math inline">\(= W\)</span>, image height <span class="math inline">\(= H\)</span>,所以<code>image.shape = (W, H, 3)</code>, 目标图片的image width <span class="math inline">\(= TW\)</span>, image height <span class="math inline">\(= TH\)</span>,<code>output.shape = (TW, TH, 3)</code>。得出长和宽的缩放比分别为<span class="math inline">\(TW/W, TH/H\)</span>。 ## 最近插值 (NearestNeighbor)最简单直观的一种插值方法。只需要从目标图像的坐标映射到原图像后，找到临近的坐标即可。比如对于targetimage的<span class="math inline">\((i,j)\)</span>像素，映射到原图像上就是<span class="math inline">\((i\times\frac{W}{TW},j\times\frac{H}{TH})\)</span>，然后四舍五入就是对应的原图像的像素坐标。</p><h2><span id="线性插值-linearinterpolation">线性插值 (LinearInterpolation)</span></h2><p>比较常见的插值算法。得到原图像上对应的坐标后，使用双线性插值，得到对应的像素值。下图为双线性插值的示意图。<img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220710205724.png">## 双三次插值 (Bicubic Interpolation)双三次插值就更加复杂一些。比起线性插值的根据周围四个点进行插值，双三次插值需要用到周围的16个点进行加权。使用的插值公式也不是线性的，而是一个三次方程。## 区域插值法 (Area Interpolation) AreaInterpolation对我个人来说实际上更加符合直觉，也就是根据图片的缩放比，找到生成的目标的图像所对应的一块区域，对该区域进行加权平均，事实上这种方法在缩放普通图像的时候感觉能够较好的保留原本图像的特征，缺点就是边缘会显得非常模糊，所以不是很利于对图像进行像素化。## Lanczos重采样Lanczos在形式上和双三次插值有着相似之处，通过一个内核函数计算每个像素对应的权重。<a href="https://en.wikipedia.org/wiki/Lanczos_resampling">Lanczosresampling-维基百科</a>。</p><h1><span id="其他进行像素画的方法">其他进行像素画的方法</span></h1><p>除了传统的插值方法，还有以下几种方法进行图片下采样生成像素画。 1.Content-Adaptive <a href="https://johanneskopf.de/publications/downscaling"><sup>2</sup></a>2. Perceptual based downscaling <a href="https://dl.acm.org/doi/10.1145/2766891"><sup>3</sup></a> 3. ImageAbstraction Method <a href="https://gfx.cs.princeton.edu/pubs/Gerstner_2012_PIA/index.php"><sup>4</sup></a>4. Deep Unsupervised Downscaling <a href="https://www.cse.cuhk.edu.hk/~ttwong/papers/pixel/pixel.html"><sup>5</sup></a>，使用深度学习GAN的方式进行图片生成，可以较好的保留图片的边缘，减少由于边界所造成的模糊效果。</p><h1><span id="参考资料">参考资料</span></h1><ol type="1"><li><a href="https://docs.opencv.org/4.5.1/da/d54/group__imgproc__transform.html#ga5bb5a1fea74ea38e1a5445ca803ff121">OpenCV-GeometricImage Transformations</a></li><li><a href="https://johanneskopf.de/publications/downscaling/">Content-AdaptiveImage Downscaling</a></li><li><a href="https://dl.acm.org/doi/10.1145/2766891">Perceptually baseddownscaling of images</a></li><li><a href="https://gfx.cs.princeton.edu/pubs/Gerstner_2012_PIA/index.php">PixelatedImage Abstraction</a></li><li><a href="https://www.cse.cuhk.edu.hk/~ttwong/papers/pixel/pixel.html">DeepUnsupervised Pixelization</a></li><li><a href="https://blog.csdn.net/u010468553/article/details/79359488">Lanczos重采样 - CSDN</a></li><li><a href="https://zh.m.wikipedia.org/zh-hans/%E5%8F%8C%E4%B8%89%E6%AC%A1%E6%8F%92%E5%80%BC">双三次插值-维基百科</a></li><li><a href="https://www.youtube.com/watch?v=poY_nGzEEWM">一个Bicubic讲的很清楚的youtube-BicubicInterpolation - Computerphile</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> ComputerVision </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CV </tag>
            
            <tag> python </tag>
            
            <tag> 图像处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Rider和Emmylua进行UnLua配置</title>
      <link href="/2022/06/27/gamegraphics/shi-yong-rider-he-emmylua-jin-xing-unlua-pei-zhi/"/>
      <url>/2022/06/27/gamegraphics/shi-yong-rider-he-emmylua-jin-xing-unlua-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>在Rider中配置UnLua环境就可以使用同一个IDE同时进行c++和Lua的开发，不用切换vscode和VisualStudio，并且Rider更加美观，操作逻辑和代码提示也比VisualStudio加番茄插件更加好用。所以还是非常推荐使用Rider进行UE的开发的。</p><span id="more"></span><h3><span id="emmylua配置intellisence">Emmylua配置IntelliSence</span></h3><p>首先在Rider中下载插件EmmyLua，EmmyLua提供了代码提示语法检查等功能。然后打开项目，如果按照UnLua仓库中的指示正确安装插件后，UE的界面就会出现下图中的图标，点击GenerateIntelliSense，UnLua就会生成出代码智能提示文件夹。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220627232545.png"></p><p>然后，在Rider中点击Solution面板中的Show AllFiles按钮即可显示所有文件，</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220627232907.png"></p><p>找到项目的Lua文件夹(Content/Scipts)以及IntelliSense文件夹(Plugins/Unlua/Intermediate/IntelliSense)，分别右键，Tools-&gt;AttachtoSolution就可以添加到Solution中进行Index，这样子代码自动补全功能就配置完成了。之后取消ShowAll Files就可以再次隐藏不需要的文件但是Scripts文件夹还是在的。</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/20220627233258.png"></p><h3><span id="使用emmylua进行debug">使用EmmyLua进行Debug</span></h3><p>目前还没有成功用EmmyLua进行Debug过orz，不知道为什么就是没法Debug，最后还是放弃了，换回了VSCode+LuaHelper，使用LuaPanda进行Debug，没有那么麻烦。似乎LuaHelper的注解功能好像有增强，用下来还是不错的，不过在一个IDE里写代码的想法破灭了lol。</p><p>（2022.7.10更新）最后发现Luahelper的代码提示时不时会抽搐，会显示错误或者显示不出来，vscode就只用来debug用了，实际开发写代码的时候还是选择使用Rider在一个IDE中写代码还是更爽！</p>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unreal Engine </tag>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门笔记2: Ray Tracing</title>
      <link href="/2022/02/28/gamegraphics/tu-xing-xue-ru-men-bi-ji-2-ray-tracing/"/>
      <url>/2022/02/28/gamegraphics/tu-xing-xue-ru-men-bi-ji-2-ray-tracing/</url>
      
        <content type="html"><![CDATA[<p>Games101作业5实现笔记以及Witted Style Ray Tracing和Moller TrumboreAlgorithm笔记</p><h2><span id="witted-style-光线追踪">Witted Style 光线追踪</span></h2><p>最基础最原始的光线追踪算法。根据光路的可逆性，我们从眼睛处朝着像素点发射一道光线，这道光线与场景中的物体相交会发生反射和折射，这里我们默认反射是镜面反射，产生的两道光线会继续和场景中的物体相交产生新的折射光线和反射光线，这就是光线追踪的基本原理。如果不加以限制，光路的反射和折射会不断进行下去，所以我们需要设置一个反射深度限制。</p><span id="more"></span><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220912001300536.png"></p><p>接下来就是如何与场景中的物体求交的问题了，光线的方程为<span class="math inline">\(\mathbf{r}(t)=\mathbf{o}+t\mathbf{d}\)</span>，<span class="math inline">\(\mathbf{o}\)</span>表示发射出光线的点，<span class="math inline">\(\mathbf{d}\)</span>表示光线发射的方向单位向量，<span class="math inline">\(t(t&gt;0)\)</span>可以理解为“时间”，代表从发射光线的点到交点的距离。如果是和规则的可以用方程表示出来的物体比如说球型等进行求交，那么可以直接联立光线和物体表面的方程算出解即可。但是实际情况中大部分的物体都是采用Mesh的方式，所以我们的光线就需要和场景中的一个个三角形表面进行求交，这个时候就需要用到MollerTrumbore Algorithm。 $$ <span class="math display">\[\begin{align}\vec{\mathbf{O}}+t\vec{\mathbf{D}}&amp;=(1-b_1-b_2)\vec{\mathbf{P_0}}+b_1\vec{\mathbf{P_1}}+b_2\vec{\mathbf{P_2}}\\\left[      \begin{matrix}        t \\        b_1 \\        b_2    \end{matrix}\right] &amp;=\frac{1}{\mathbf{\vec{S_1}\cdot\vec{E_1}}}\left[    \begin{matrix}        \mathbf{\vec{S_2}\cdot\vec{E_2}} \\        \mathbf{\vec{S_1}\cdot\vec{S}} \\        \mathbf{\vec{S_2}\cdot\vec{D}} \\    \end{matrix}\right], \\\text{where } \vec{\mathbf{E_1}} &amp;=\mathbf{\vec{P_1}-\vec{P_0}}, \\\vec{\mathbf{E_2}} &amp;= \vec{\mathbf{P_2}}-\vec{\mathbf{P_0}},\\\vec{\mathbf{S}} &amp;= \vec{\mathbf{O}}-\vec{\mathbf{P_0}},\\\vec{\mathbf{S_1}} &amp;= \vec{\mathbf{D}}-\vec{\mathbf{E_2}},\\\vec{\mathbf{S_2}} &amp;= \vec{\mathbf{S}}-\vec{\mathbf{E_1}},\\\end{align}\]</span> $$</p><p>其中<span class="math inline">\(P_0, P_1,P_2\)</span>是三角形的三个顶点，这里使用了重心坐标来表示三角形内的任意一点。利用这个等式解出正数<span class="math inline">\(t\)</span>，就可以得到交点坐标，这也就是作业5中我们需要实现的算法。</p><h2><span id="作业5相关代码实现">作业5相关代码实现</span></h2><p>本次作业主要实现两个函数</p><ol type="1"><li><p><code>Triangle.hpp</code>的<code>rayTriangleIntersect()</code>函数，这个函数就是用来计算光线和三角形求交的，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">rayTriangleIntersect</span><span class="params">(<span class="type">const</span> Vector3f&amp; v0, <span class="type">const</span> Vector3f&amp; v1, <span class="type">const</span> Vector3f&amp; v2, <span class="type">const</span> Vector3f&amp; orig,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="type">const</span> Vector3f&amp; dir, <span class="type">float</span>&amp; tnear, <span class="type">float</span>&amp; u, <span class="type">float</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Implement this function that tests whether the triangle</span></span><br><span class="line">    <span class="comment">// that&#x27;s specified bt v0, v1 and v2 intersects with the ray (whose</span></span><br><span class="line">    <span class="comment">// origin is *orig* and direction is *dir*)</span></span><br><span class="line">    <span class="comment">// Also don&#x27;t forget to update tnear, u and v.</span></span><br><span class="line">    <span class="keyword">auto</span> S = orig - v0;</span><br><span class="line">    <span class="keyword">auto</span> E_1 = v1 - v0;</span><br><span class="line">    <span class="keyword">auto</span> E_2 = v2 - v0;</span><br><span class="line">    <span class="keyword">auto</span> S_1 = <span class="built_in">crossProduct</span>(dir, E_2);</span><br><span class="line">    <span class="keyword">auto</span> S_2 = <span class="built_in">crossProduct</span>(S, E_1);</span><br><span class="line">    <span class="keyword">auto</span> S<span class="number">1E1</span>  = <span class="built_in">dotProduct</span>(S_1, E_1);</span><br><span class="line">    <span class="type">float</span> t = <span class="built_in">dotProduct</span>(S_2, E_2) / S<span class="number">1E1</span>;</span><br><span class="line">    <span class="type">float</span> b_1 = <span class="built_in">dotProduct</span>(S_1, S) / S<span class="number">1E1</span>;</span><br><span class="line">    <span class="type">float</span> b_2 = <span class="built_in">dotProduct</span>(S_2, dir) / S<span class="number">1E1</span>;</span><br><span class="line">    <span class="keyword">if</span> (t &gt;= <span class="number">0.0f</span> &amp;&amp; b_1 &gt;= <span class="number">0.0f</span> &amp;&amp; b_2 &gt;= <span class="number">0.0f</span> &amp;&amp; (<span class="number">1</span> - b_1 - b_2) &gt;= <span class="number">0.0f</span>) &#123;</span><br><span class="line">        tnear = t;</span><br><span class="line">        u = b_1;</span><br><span class="line">        v = b_2;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二个函数是<code>Renderer.cpp</code>中的<code>Render()</code>，主要是考察屏幕空间和世界空间之间的转化问题，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [comment]</span></span><br><span class="line"><span class="comment">// The main render function. This where we iterate over all pixels in the image, generate</span></span><br><span class="line"><span class="comment">// primary rays and cast these rays into the scene. The content of the framebuffer is</span></span><br><span class="line"><span class="comment">// saved to a file.</span></span><br><span class="line"><span class="comment">// [/comment]</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Renderer::Render</span><span class="params">(<span class="type">const</span> Scene&amp; scene)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::vector&lt;Vector3f&gt; <span class="title">framebuffer</span><span class="params">(scene.width * scene.height)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> scale = std::<span class="built_in">tan</span>(<span class="built_in">deg2rad</span>(scene.fov * <span class="number">0.5f</span>));</span><br><span class="line">    <span class="type">float</span> imageAspectRatio = scene.width / (<span class="type">float</span>)scene.height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use this variable as the eye position to start your rays.</span></span><br><span class="line">    <span class="function">Vector3f <span class="title">eye_pos</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; scene.height; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; scene.width; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// generate primary ray direction</span></span><br><span class="line">            <span class="comment">// Find the x and y positions of the current pixel to get the direction</span></span><br><span class="line">            <span class="comment">// vector that passes through it.</span></span><br><span class="line">            <span class="comment">// Also, don&#x27;t forget to multiply both of them with the variable *scale*, and</span></span><br><span class="line">            <span class="comment">// x (horizontal) variable with the *imageAspectRatio*</span></span><br><span class="line">            <span class="type">float</span> x = (<span class="number">2</span> * (i + <span class="number">0.5f</span>) / (<span class="type">float</span>)(scene.width<span class="number">-1</span>) - <span class="number">1.0f</span>) * imageAspectRatio * scale;</span><br><span class="line">            <span class="type">float</span> y = (<span class="number">1</span> - <span class="number">2</span> * (j + <span class="number">0.5f</span>) / (<span class="type">float</span>)(scene.height<span class="number">-1</span>)) * scale;</span><br><span class="line"></span><br><span class="line">            Vector3f dir = <span class="built_in">normalize</span>(<span class="built_in">Vector3f</span>(x, y, <span class="number">-1</span>)); <span class="comment">// Don&#x27;t forget to normalize this direction!</span></span><br><span class="line">            framebuffer[m++] = <span class="built_in">castRay</span>(eye_pos, dir, scene, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">UpdateProgress</span>(j / (<span class="type">float</span>)scene.height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// save framebuffer to file</span></span><br><span class="line">    FILE* fp = <span class="built_in">fopen</span>(<span class="string">&quot;binary-test.ppm&quot;</span>, <span class="string">&quot;wb&quot;</span>);</span><br><span class="line">    (<span class="type">void</span>)<span class="built_in">fprintf</span>(fp, <span class="string">&quot;P6\n%d %d\n255\n&quot;</span>, scene.width, scene.height);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; scene.height * scene.width; ++i) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> color[<span class="number">3</span>];</span><br><span class="line">        color[<span class="number">0</span>] = (<span class="type">char</span>)(<span class="number">255</span> * <span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].x));</span><br><span class="line">        color[<span class="number">1</span>] = (<span class="type">char</span>)(<span class="number">255</span> * <span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].y));</span><br><span class="line">        color[<span class="number">2</span>] = (<span class="type">char</span>)(<span class="number">255</span> * <span class="built_in">clamp</span>(<span class="number">0</span>, <span class="number">1</span>, framebuffer[i].z));</span><br><span class="line">        <span class="built_in">fwrite</span>(color, <span class="number">1</span>, <span class="number">3</span>, fp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fclose</span>(fp);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>最终生成的结果如下</p><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/output.jpg"></p><h2><span id="参考资料">参考资料</span></h2><p><a href="https://zhuanlan.zhihu.com/p/431092843">Games101-作业5 -知乎 (zhihu.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cpp </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode编译.cpp文件出现中文乱码解决方案</title>
      <link href="/2022/02/25/bug/g-bian-yi.cpp-wen-jian-chu-xian-zhong-wen-luan-ma-jie-jue-fang-an/"/>
      <url>/2022/02/25/bug/g-bian-yi.cpp-wen-jian-chu-xian-zhong-wen-luan-ma-jie-jue-fang-an/</url>
      
        <content type="html"><![CDATA[<h1><span id="vscode编译cpp文件出现中文乱码解决方案">vscode编译.cpp文件出现中文乱码解决方案</span></h1><p>在vscode中编译.cpp文件，可以使用vscode中的插件coderunner点击按钮运行，如果熟悉如何使用g++的命令也可以直接使用命令行语句编译运行。但是如果文件中出现了中文字符，就会出现编译之后生成乱码的问题。比如这一段代码（来源于<a href="https://www.runoob.com/cplusplus/cpp-data-types.html">菜鸟教程</a>）</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;type: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;************size**************&quot;</span>&lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bool: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">bool</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">bool</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;char: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">char</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">char</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;signed char: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">signed</span> <span class="type">char</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">signed</span> <span class="type">char</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">signed</span> <span class="type">char</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned char: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">char</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span> <span class="type">char</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wchar_t: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">wchar_t</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">wchar_t</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">wchar_t</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">short</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">short</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">int</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">int</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">long</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">long</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;unsigned long: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">unsigned</span> <span class="type">long</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">double</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">double</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long double: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">double</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">long</span> <span class="type">double</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>); </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">float</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">float</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size_t: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">size_t</span>);  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最大值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">size_t</span>&gt;::max)();  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\t最小值：&quot;</span> &lt;&lt; (numeric_limits&lt;<span class="type">size_t</span>&gt;::min)() &lt;&lt; endl;  </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: \t&quot;</span> &lt;&lt; <span class="string">&quot;所占字节数：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(string) &lt;&lt; endl;  </span><br><span class="line">    <span class="comment">// &lt;&lt; &quot;\t最大值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::max)() &lt;&lt; &quot;\t最小值：&quot; &lt;&lt; (numeric_limits&lt;string&gt;::min)() &lt;&lt; endl;  </span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;type: \t\t&quot;</span> &lt;&lt; <span class="string">&quot;************size**************&quot;</span>&lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接运行的话结果是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type:           ************size**************</span><br><span class="line">bool:           鎵€鍗犲瓧鑺傛暟锛?</span><br></pre></td></tr></table></figure><p>程序运行到乱码的部分就直接结束了，这个问题可以通过以下方法解决。</p><h3><span id="1-更改文件编码类型">1. 更改文件编码类型</span></h3><p>在vscode左下角有一个选择编码的按钮，默认是<code>utf-8</code>编码，点击之后再点击通过编码重新打开，一般情况下第一个选项后面会有'通过文件内容猜测'，如果没有，可以搜索GBK，将编码设置为GBK（汉字编码），注意：这个时候如果再更改回utf-8，所有的中文在编辑器中显示都会是乱码，但是编译还是没有问题的。还有一种改变编码的方式，就是用记事本打开，然后另存为，在编码一栏里选择ANSI，然后编译运行就可以了。（这个时候在vscode中的代码还是会乱码的，所以还是建议使用上一种方法）</p><h3><span id="2-命令行操作">2. 命令行操作</span></h3><p>如果不改变代码的编码类型，可以在编译的时候设置编译的编码类型。在运行时使用一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -fexec-charset=GBK test.cpp -o test</span><br></pre></td></tr></table></figure><p>使用GBK编码生成一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test.exe</span><br></pre></td></tr></table></figure><p>运行这个可执行文件</p><p>得到结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">type:         ************size**************</span><br><span class="line">bool:         所占字节数：1    最大值：1        最小值：0</span><br><span class="line">char:         所占字节数：1    最大值：        最小值：?</span><br><span class="line">signed char:     所占字节数：1    最大值：        最小值：?</span><br><span class="line">unsigned char:     所占字节数：1    最大值：?        最小值：</span><br><span class="line">wchar_t:     所占字节数：4    最大值：2147483647        最小值：-2147483648</span><br><span class="line">short:         所占字节数：2    最大值：32767        最小值：-32768</span><br><span class="line">int:         所占字节数：4    最大值：2147483647    最小值：-2147483648</span><br><span class="line">unsigned:     所占字节数：4    最大值：4294967295    最小值：0</span><br><span class="line">long:         所占字节数：8    最大值：9223372036854775807    最小值：-9223372036854775808</span><br><span class="line">unsigned long:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">double:     所占字节数：8    最大值：1.79769e+308    最小值：2.22507e-308</span><br><span class="line">long double:     所占字节数：16    最大值：1.18973e+4932    最小值：3.3621e-4932</span><br><span class="line">float:         所占字节数：4    最大值：3.40282e+38    最小值：1.17549e-38</span><br><span class="line">size_t:     所占字节数：8    最大值：18446744073709551615    最小值：0</span><br><span class="line">string:     所占字节数：24</span><br><span class="line">type:         ************size**************</span><br></pre></td></tr></table></figure><p>参考博客：<a href="https://blog.csdn.net/weixin_33720452/article/details/85970159">g++编译后中文显示乱码解决方案(c++)</a></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Three.js使用贝塞尔曲线绘制心形</title>
      <link href="/2022/02/10/gamegraphics/three-js-shi-yong-bei-sai-er-qu-xian-hui-zhi-xin-xing/"/>
      <url>/2022/02/10/gamegraphics/three-js-shi-yong-bei-sai-er-qu-xian-hui-zhi-xin-xing/</url>
      
        <content type="html"><![CDATA[<p>贝塞尔曲线是图形学中非常重要的知识，是绘制曲线以及曲面的基础，在很多地方都有着非常广泛的应用，比如Photoshop里的钢笔工具，字体设计，各种过渡动画等等。本文将记录贝塞尔曲线的原理公式，以及使用Three.js中的贝塞尔曲线API进行简单的心形绘制。</p><span id="more"></span><h3><span id="贝塞尔曲线详解">贝塞尔曲线详解</span></h3><p>贝塞尔曲线就是在起始点和终止点之间，设置控制点，通过控制点的移动来控制曲线的形状。根据控制点数量的不同，可以将贝塞尔曲线分为一阶曲线、二阶曲线、三阶曲线……等等。</p><h4><span id="一阶曲线">一阶曲线</span></h4><p>一阶曲线非常简单，因为没有控制点，所以就是一条从起始点到终止点的线段。</p><h4><span id="二阶曲线">二阶曲线</span></h4><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220210111040096.png" alt="image-20220210111040096"><figcaption aria-hidden="true">image-20220210111040096</figcaption></figure><p>二阶曲线由起始点、终止点和一个控制点组成。贝塞尔曲线由以下规则形成：对于[0,1]内任何t，在<span class="math inline">\(b_0b_1\)</span>上取一个点<span class="math inline">\(b_0^1\)</span>，满足<span class="math inline">\(b_0b_0^1\)</span>和<span class="math inline">\(b_0^1b_1\)</span>的关系为<span class="math inline">\(t : 1-t\)</span>，同样的，在在<span class="math inline">\(b_1b_2\)</span>上取一个点<span class="math inline">\(b_1^1\)</span>，满足<span class="math inline">\(b_1b_1^1\)</span>和<span class="math inline">\(b_1^1b_2\)</span>的关系为<span class="math inline">\(t : 1-t\)</span>。最后将<span class="math inline">\(b_0^1b_1^1\)</span>相连，在<span class="math inline">\(b_0^1b_1^1\)</span>上继续取一点满足<span class="math inline">\(b_0^1b_0^2:b_0^2b_1^1=t:1-t\)</span>。所有的t所形成的<span class="math inline">\(b_0^2\)</span>形成一道曲线，这道曲线就是贝塞尔曲线。对应的点的坐标在向量表示下很容易表示出来：<span class="math display">\[\vec{b^1_0}(t)=(1-t)\vec{b_0}+t\vec b_1 \\\vec{b^1_1}(t)=(1-t)\vec{b_1}+t\vec b_2 \\\vec{b^2_0}(t)=(1-t)\vec{b_0^1}+t\vec b_1^1 \\\Rightarrow \vec{b_0^2}(t)=(1-t)^2\vec b_0 + 2t(1-t)\vec{b_1}+t^2\vecb_2\]</span></p><h4><span id="三阶以及多阶曲线">三阶以及多阶曲线</span></h4><p>类似于二阶曲线，三阶以及多阶贝塞尔曲线也是采用同样的方法，不断进行迭代，每一个t确定一个点，最后形成一条曲线。</p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220210112920807.png" alt="image-20220210112920807"><figcaption aria-hidden="true">image-20220210112920807</figcaption></figure><p>计算贝塞尔曲线有一个对于任意阶通用的公式：<strong>德卡斯特里奥算法</strong>(De Casteljau's algorithm)，是一种递归的计算贝塞尔曲线的方法： <span class="math display">\[\vec b^n(t)=\vec b_0^n(t)=\sum_{j=0}^n\vec b_jB_j^n(t)\text{, where}\vec b_j \text{ is the Bernstein polynomial} \\\text{Bernstein polynomial: }B^n_t(t)=\tbinom{n}{t}t^i(1-t)^{n-i}\]</span></p><h3><span id="使用threejs中的贝塞尔曲线绘制心形">使用Three.js中的贝塞尔曲线绘制心形</span></h3><h4><span id="绘制圆形">绘制圆形</span></h4><p>我们首先可以通过贝塞尔曲线绘制出一个圆形，心形可以在圆形的基础上进行一定的控制点的调整就可以绘制而成。</p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/aEsuA.png" alt="aEsuA"><figcaption aria-hidden="true">aEsuA</figcaption></figure><p>从上图中可以看出，一个圆形可以被分成四个弧线，每条弧线可以通过一个三阶贝塞尔曲线绘制而成（两个控制点），控制点的位置在<a href="https://stackoverflow.com/questions/1734745/how-to-create-circle-with-bézier-curves">geometry- How to create circle with Bézier curves? - StackOverflow</a>已经有人计算好了，我们可以直接使用（这里的计算也并不是特别复杂，简单的数学知识就可以计算出来）。由此，我们可以通过贝塞尔曲线创建出一个圆的形状：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> radius = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">0.551915024494</span> * radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heartShape = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Shape</span>()</span><br><span class="line">    .<span class="title function_">moveTo</span>(x, y+radius)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x+c,y+radius, x+radius, y+c, x+radius, y)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x+radius,y-c, x+c, y-radius, x, y-radius)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x-c,y-radius, x-radius, y-c, x-radius, y)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x-radius,y+c, x-c, y+radius, x, y+radius)</span><br></pre></td></tr></table></figure><p><code>bezierCurveTo()</code>是Three.js中的贝塞尔曲线的API，它接受六个参数，前四个分别是两个控制点的x,y坐标，最后两个是终止点的x,y坐标。这里只需要设定好参数，使用四段贝塞尔曲线一一绘制出来就可以了。</p><h4><span id="绘制心形">绘制心形</span></h4><p>心形其实就是在圆形的基础上移动了三个控制点的位置，将y轴上上方的起始点稍向下移动，以及下方左右两个控制点向上移动，就可以绘制出一个心形，代码以及效果图如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> radius = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">const</span> c = <span class="number">0.551915024494</span> * radius;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> heartShape = <span class="keyword">new</span> <span class="variable constant_">THREE</span>.<span class="title class_">Shape</span>()</span><br><span class="line">    .<span class="title function_">moveTo</span>(x, y+radius/<span class="number">3</span>)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x+c,y+radius, x+radius, y+c, x+radius, y)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x+radius,y-c, x+c, y-radius/<span class="number">2</span>, x, y-radius)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x-c,y-radius/<span class="number">2</span>, x-radius, y-c, x-radius, y)</span><br><span class="line">    .<span class="title function_">bezierCurveTo</span>(x-radius,y+c, x-c, y+radius, x, y+radius/<span class="number">3</span>)</span><br></pre></td></tr></table></figure><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/heart.gif" alt="heart"><figcaption aria-hidden="true">heart</figcaption></figure><h3><span id="参考资料">参考资料</span></h3><p><a href="https://www.bilibili.com/video/BV1X7411F744?p=11">GAMES101-现代计算机图形学入门-闫令琪_哔哩哔哩_bilibili</a></p><p><a href="https://zh.wikipedia.org/wiki/德卡斯特里奥算法">德卡斯特里奥算法 -维基百科，自由的百科全书 (wikipedia.org)</a></p><p><a href="https://threejs.org/docs/#api/en/extras/core/Path.bezierCurveTo">Path#bezierCurveTo– three.js docs (threejs.org)</a></p><p><a href="https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B06%5DPath_Bezier.md">AndroidNote_Path_BezierGcsSloop/AndroidNote(github.com)</a></p><p><a href="https://stackoverflow.com/questions/1734745/how-to-create-circle-with-bézier-curves">geometry- How to create circle with Bézier curves? - Stack Overflow</a></p>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
            <tag> 前端 </tag>
            
            <tag> Three.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BugMysql:Access Denied for user &#39;root&#39;@&#39;localhost&#39;</title>
      <link href="/2021/11/21/bug/bugmysql-access-denied-for-user-root-localhost/"/>
      <url>/2021/11/21/bug/bugmysql-access-denied-for-user-root-localhost/</url>
      
        <content type="html"><![CDATA[<p>终于将困扰了很长时间的mysql的Bug解决了。朋友在macOS上的mysql每次进入的时候都会弹出<code>Access denied......</code>的错误提示，经过长时间的上网搜索未果，今天终于有机会将其解决。</p><p><span id="more"></span></p><p>我在Ubuntu上部署mysql的时候发现，如果没有sudo权限的话，直接输入<code>mysql -u root -p</code>进入mysql的话，即使密码正确也是会<code>access denied</code>，只要又sudo权限就能进入，所以mysql的root也是需要os的root权限的。由于我想远程从本地的可视化databasenavigator远程对数据库进行操作，如果想要连接到root，就会提示<code>access denied</code>，究其原因还是因为ssh连接到远程服务器上的时候不会给sudo权限。这个时候我们就只能够新创建一个user，给这个user近似root的权限，来达到全程操作的效果。</p><p>首先，打开mysql路径下的my.cnf，找到bind-address这一行，改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind-address=0.0.0.0</span><br></pre></td></tr></table></figure><p>接下来<code>sudo mysql -u root -p</code>进入mysql，然后输入以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER &#x27;myuser&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;mypass&#x27;;</span><br><span class="line">CREATE USER &#x27;myuser&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;mypass&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;myuser&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">GRANT ALL ON *.* TO &#x27;myuser&#x27;@&#x27;%&#x27;;</span><br><span class="line">flush privileges;</span><br><span class="line">// myuser就是你的username</span><br></pre></td></tr></table></figure><p>然后就可以用新创建的这个user进行远程访问数据库了</p><p>参考资料</p><p><a href="https://stackoverflow.com/questions/16287559/mysql-adding-user-for-remote-access">Mysqladding user for remote access</a></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：数组中的逆序对</title>
      <link href="/2021/11/06/algorithms/suan-fa-shu-zu-zhong-de-ni-xu-dui/"/>
      <url>/2021/11/06/algorithms/suan-fa-shu-zu-zhong-de-ni-xu-dui/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>题目来源：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/">剑指Offer 51. 数组中的逆序对 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p>数组中的逆序对是数据结构和算法中的一道经典题目。如果<code>A[i]&gt;A[j]</code>并且<code>i&lt;j</code>，那么这就算是一组逆序对。题目要求给定一个数组，求出数组中逆序对的个数</p><blockquote><p>输入：[7,5,6,4]</p><p>输出：5</p></blockquote><span id="more"></span><h2><span id="题解">题解</span></h2><p>本题可以使用排序的思想，因为在排序中我们发现的不符合排列顺序的数组对都是一组逆序对，我们只需要计算出在排序的过程中交换的次数即可。本题中可以采用时间复杂度为O(logn)的归并排序。代码如下：</p><p>基本思路和归并排序是一样的，如果对归并排序的代码不理解的可以先看一看<a href="https://lucas-hao.github.io/2021/07/26/suan-fa-pai-xu-suan-fa/">排序算法</a>。</p><p>唯一需要注意的地方就是归并的时候的逆序对计算，当我们发现right小于left的时候，right同时也小于left后面的所有元素，我们增加的个数就是mid-left+1（merge函数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] aux; <span class="comment">// copy of the origin array</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> subReversePairs(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">subReversePairs</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        count += subReversePairs(nums, lo, mid);</span><br><span class="line">        count += subReversePairs(nums, mid+<span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">// 优化：如果左侧最大小于右侧最小，那么就不需要进行归并了</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= nums[mid+<span class="number">1</span>]) <span class="keyword">return</span> count;</span><br><span class="line">        count += merge(nums, lo, mid, hi);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) aux[i] = nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> lo, right  = mid+<span class="number">1</span>, index = lo;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid &amp;&amp; right &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aux[left] &lt;= aux[right]) nums[index++] = aux[left++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (aux[left] &gt; aux[right]) &#123;</span><br><span class="line">                nums[index++] = aux[right++];</span><br><span class="line">                count += mid - left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= mid) nums[index++] = aux[left++];</span><br><span class="line">        <span class="keyword">while</span> (right &lt;= hi) nums[index++] = aux[right++];</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图形学入门笔记1: 图形学中的数学</title>
      <link href="/2021/10/30/gamegraphics/tu-xing-xue-ru-men-bi-ji-1-tu-xing-xue-zhong-de-shu-xue/"/>
      <url>/2021/10/30/gamegraphics/tu-xing-xue-ru-men-bi-ji-1-tu-xing-xue-zhong-de-shu-xue/</url>
      
        <content type="html"><![CDATA[<p>数学在图形学中是非常重要的基础，本篇简要记录一下图形学之中的一些数学基础和技巧</p><span id="more"></span><h2><span id="线性代数基础">线性代数基础</span></h2><p>线代在图形学中是非常重要的数学。在图形学中，一些基础的线性代数知识是必须要掌握的，比如向量与矩阵的相关运算</p><ul><li>Vector Addition, Scalar Multiplication, Scalar Product,Normalization, Cross Product</li><li>Vector Cross Product: <span class="math inline">\(V_1\timesV_2=u|V_1||V_2|\sin\theta=\left|\begin{matrix}u_x &amp; u_y &amp; u_z \\v_{1x} &amp; v_{1y} &amp; v_{1z} \\ v_{2x} &amp; v_{2y} &amp; v_{2z}\end{matrix}\right|\)</span></li><li>Vector Cross product properties: 1. <span class="math inline">\(V_1\times V_2 = -(V_2 \times V_1)\)</span> (不符合交换律) 2. <span class="math inline">\(V_1 \times (V_2 \times V_3) \neq (V_1 \times V_2)\times V_3\)</span> (不符合交换律) 3. <span class="math inline">\(V_1\times (V_2 + V_3)=V_1 \times V_2 + V_1 \times V_3\)</span>(符合结合律)</li><li>Matrix-matrix multiplication， Matrix-vector multiplication</li></ul><h2><span id="二维三维变换与齐次坐标系">二维三维变换与齐次坐标系</span></h2><p>利用线性代数中的向量和矩阵，我们可以表示出在二维平面和三维空间中点线面的位置与相应的关系。首先，我们需要引入齐次坐标的概念，为了简便，以下都以三维空间中的齐次坐标为例。普通的三维坐标表示为<span class="math inline">\((x,y,z)\)</span>，但是在齐次坐标系中，我们添加一个维度<span class="math inline">\(w\)</span>用来标明该坐标为向量还是坐标，如果是空间中的点就是1，如果是向量就是0，并且齐次坐标满足以下规则，<span class="math inline">\((x,y,z,w)=(x/w,y/w,z/w,1)\)</span>，即原坐标与每个维度乘以相同的数之后得到的坐标是等价的。通过齐次坐标系，我们就可以得到常见的基本变换的矩阵表示。</p><ol type="1"><li><p>平移 (Translation) <span class="math display">\[\text{Translation: }\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; T_x \\0 &amp; 1 &amp; 0 &amp; T_y \\0 &amp; 0 &amp; 1 &amp; T_z \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\text{, Inverse: }\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; -T_x \\0 &amp; 1 &amp; 0 &amp; -T_y \\0 &amp; 0 &amp; 1 &amp; -T_z \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\]</span></p></li><li><p>缩放 (Scaling) <span class="math display">\[\text{Scaling:}\left(\begin{matrix}S_x &amp; 0 &amp; 0 &amp; 0 \\0 &amp; S_y &amp; 0 &amp; 0 \\0 &amp; 0 &amp; S_z &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\]</span></p></li><li><p>旋转 (Rotation) 逆时针 <span class="math display">\[R_x(\alpha)=\left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; \cos{\alpha} &amp; -\sin{\alpha} &amp; 0 \\0 &amp; \sin{\alpha} &amp; \cos{\alpha} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right),R_y(\alpha)=\left(\begin{matrix}\cos{\alpha} &amp; 0 &amp; \sin{\alpha} &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\-\sin{\alpha} &amp; 0 &amp; \cos{\alpha} &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right),R_z(\alpha)=\left(\begin{matrix}\cos{\alpha} &amp; -\sin{\alpha} &amp; 0 &amp; 0 \\\sin{\alpha} &amp; \cos{\alpha} &amp; 0 &amp; 0 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right),\]</span> 绕着轴<span class="math inline">\(n\)</span>旋转角度<span class="math inline">\(\alpha\)</span> (Rodrigues' Rotation Formula)<span class="math display">\[R(n,\alpha)=\cos(\alpha)\mathbf{I}+(1-\cos(\alpha))\mathbf{nn^T}+\sin(\alpha)\underbrace{\left(\begin{matrix}0 &amp; -n_z &amp; n_y \\n_z &amp; 0 &amp; -n_x \\-n_y &amp; n_x &amp; 0\end{matrix}\right)}\]</span> 欧拉角：<span class="math inline">\(R_{xyz}(\alpha,\beta,\gamma)=R_x(\alpha)R_y(\beta)R_z(\gamma)\)</span>:</p><p>桶滚 (roll), 偏航 (yaw), 俯仰 (pitch)</p><p><img src="https://i.loli.net/2021/10/31/8Mug69ZUWynx2eC.png" height="200" alt="图片名称" align="center"></p><blockquote><p><strong>补充:</strong>旋转除了使用坐标进行计算之外，还可以使用四元数进行计算，四元数这里推荐两个YouTube视频</p><ul><li><a href="https://www.youtube.com/watch?v=3BR8tK-LuB0">FantasticQuaternions - Numberphile - YouTube</a></li><li><a href="https://www.youtube.com/watch?v=d4EgbgTm0Bg">Visualizingquaternions (4d numbers) with stereographic projection -YouTube</a></li></ul></blockquote></li></ol><h2><span id="二维与三维几何的基础知识">二维与三维几何的基础知识</span></h2><h3><span id="二维几何知识">二维几何知识</span></h3><ol type="1"><li><p>计算点到直线距离 [<span class="math inline">\(A(x_1,y_1),B(x_2,y_2),P(x,y)\)</span>]</p><ul><li>直线方向向量：<span class="math inline">\(\vec{v}=(x_2-x_1,y_2-y_1)=(d_x,d_y)\)</span></li><li>直线的法线向量 (垂直于直线)：<span class="math inline">\(\vec{n}=(-d_y,d_x)=(y_1-y_2,x_2-x_1)\)</span></li><li><span class="math inline">\(\vec{n},\vec{v}\)</span>转化为单位向量(Normalization)</li><li>向量点乘找到距离: <span class="math inline">\(h=|(P-A)\cdot\hat{n}|\)</span></li></ul></li><li><p>两条直线相交（非常简单），联立方程解出交点即可</p></li><li><p>给定一个点<span class="math inline">\(P\)</span>和一条直线<span class="math inline">\(AB\)</span>，判断点在直线的哪一侧</p><p>使用三角形的有向面积 (Signed area) <span class="math inline">\(\gamma=\frac{1}{2}Det\left|\begin{matrix}x_a &amp;x_b &amp; x \\ y_a &amp; y_b &amp; y \\ 1 &amp; 1 &amp;1\end{matrix}\right|,\begin{cases}\gamma&gt;0,left\\\gamma&lt;0,right\\\gamma=0,on\spaceline\end{cases}\)</span></p></li></ol><p><img src="https://i.loli.net/2021/10/31/iqGdoEm9ukIJfjM.png" height="200" alt="图片名称" align="center"></p><p>​ 多边形的有向面积：<span class="math inline">\(polygon\spacearea=\frac{1}{2}\sum{Det\left|\begin{matrix}x_i &amp; x_{i+1} \\ y_i&amp; y_{i+1}\end{matrix}\right|}\)</span> (Note:不能忘记最后一个点和第一个点)</p><ol type="1"><li><p>判断点是否在多边形内部1</p><ol type="1"><li><p>法一：使用(3)的方法判断点在多边形的每一条边的哪一侧，进而判断点是否在多边形的内部</p></li><li><p>法二：如果一个点在多边形内部，过这个点任意做一条直线，与多边形的边的交点个数为奇数，如果为偶数，说明这个点在多边形的外部（注意：还有一些特殊情况需要考虑）</p><p><img src="https://i.loli.net/2021/10/31/sfeOKyQblIcTU7L.png" height="200" alt="图片名称" align="center"></p></li></ol></li></ol><h3><span id="三维几何知识">三维几何知识</span></h3><ol type="1"><li><p>线性差值 (Linear Interpolation) [Lerp]: <span class="math inline">\(V=V_0+t(V_1-V_0)\)</span> (点<span class="math inline">\(V\)</span>在<span class="math inline">\(V_0\)</span>和<span class="math inline">\(V_1\)</span>的直线上移动 )</p></li><li><p>质心坐标 (Barycentric coordinate)</p><p><span class="math inline">\(P=\alpha P_0+\beta P_1 + \gamma P_2\text{ where } \alpha+\beta+\gamma=1,A_0=\alpha A, A_1=\betaA,A_2=\gamma A\)</span></p></li><li><p>球面线性差值 (Spherical Linear Interpolation) [Slerp]</p><p><span class="math inline">\(\vec{V(t)}=\vec{V_0}\frac{\sin((1-t)\theta)}{\sin\theta}+\vec{V_1}\frac{\sin(t\theta)}{\sin\theta}\)</span>(<span class="math inline">\(V\)</span>在<span class="math inline">\(V_0\)</span>和<span class="math inline">\(V_1\)</span>之间的弧线上移动 )</p></li><li><p>三角形的法线，假设三角形三个顶点<span class="math inline">\(V_0,V_1,V_2\)</span>，将两条边按照逆时针方向进行叉乘，得到的结果就是三角形的法线<span class="math display">\[\vec{n}=(V_1-V_0)\times(V_2-V_0) \text{ OR } (V_1-V_1) \cdots\]</span></p></li><li><p>顶点的法线: 取周围多个面的法线的平均值</p></li></ol><blockquote><p>本篇笔记基于上课的课件以及Games101进行整理</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> GameGraphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：数组中第k大的数</title>
      <link href="/2021/10/21/algorithms/suan-fa-shu-zu-zhong-di-k-da-de-shu/"/>
      <url>/2021/10/21/algorithms/suan-fa-shu-zu-zhong-di-k-da-de-shu/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>数组中第k大的数是一道十分经典的题目，题目表述可以如下</p><blockquote><p>You are given a set S of n integers in an array and also an integer k∈ [1, n]. Design an algorithm to find the k-th largest integer of S.</p><p>给定 一个数组，返回数组中第k大的元素</p></blockquote><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215.数组中的第K个最大元素 - 力扣（LeetCode） (leetcode-cn.com)</a></p><p><a href="https://leetcode-cn.com/problems/xx4gT2/">剑指 Offer II 076.数组中的第 k 大的数字 - 力扣（LeetCode） (leetcode-cn.com)</a></p><span id="more"></span><h2><span id="题解">题解</span></h2><h3><span id="分治算法快速排序">分治算法（快速排序）</span></h3><p>首先，一个非常简单的思路，我们直接先将整个数组进行排序，然后就可以直接找到第k大的数字了，这样的时间复杂度是O(nlogn)。但是实际上，我们并不需要将整个数组进行排序，我们在排序的过程中已经可以找到第k大的元素。下面这个算法就是基于快速排序算法找出了第k大的数字(参考《算法导论》以及课上的课件)。</p><p>算法思路：首先在数组中随机选取一个下标当做pivot，然后进行partition，将比pivot的值大的放在左侧，比pivot的值小的放在右侧，接下来分三种情况：</p><blockquote><ol type="1"><li>pivot==k-1, 我们就已经找到了第k大的元素</li><li>pivot&lt;k-1,我们需要在pivot之后的数字中找到第k-pivot-1大的元素</li><li>pivot&gt;k-1, 我们需要在pivot之前的数字中找到第k大的元素</li></ol><p>（注：这里是k-1是因为pivot是下标从0开始，k从1开始）</p></blockquote><p>我们还可以对这个算法进行一定的优化，如果说我们随机选取的pivot的位置非常靠左或者靠右，那么这个时候我们在递归之前可能只能排除掉非常少的部分元素，我们可以希望pivot落在数组范围的中间1/3部分，如果不在的话，我们重新选择一个pivot(实际上感觉这样子提升的效果也不是很好？)下面是代码部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KSelection</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Comparable <span class="title function_">kSelectionSort</span><span class="params">(Comparable[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; arr.length || k &lt;= <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> quickKSelection(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Comparable <span class="title function_">quickKSelection</span><span class="params">(Comparable[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo == hi) <span class="keyword">return</span> arr[hi];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> partition(arr, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; k) <span class="keyword">return</span> quickKSelection(arr, lo, pivot - <span class="number">1</span>, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pivot &lt; k) <span class="keyword">return</span> quickKSelection(arr, pivot + <span class="number">1</span>, hi, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> arr[pivot];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] arr, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> pivot= random.nextInt(hi-lo+<span class="number">1</span>)+lo;</span><br><span class="line">        swap(arr, pivot, lo);</span><br><span class="line">        pivot = lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (arr[++i].compareTo(arr[pivot]) &gt; <span class="number">0</span>) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">while</span> (arr[pivot].compareTo(arr[--j]) &gt; <span class="number">0</span> ) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            swap(arr, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, j);</span><br><span class="line">        pivot = j;</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt;= lo + (hi - lo) / <span class="number">3</span> &amp;&amp; pivot &lt;= hi - (hi - lo) / <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> pivot;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> partition(arr, lo, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Comparable[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">Comparable</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(f(n)\leO(n)+f(\lceil2n/3\rceil)\)</span>,根据Master's theorem,时间复杂度为O(n)。空间复杂度：函数递归占用栈空间O(logn)。</p><h3><span id="最大堆">最大堆</span></h3><p>另一个思路也非常容易，就是维护一个大根堆，然后依次将每个元素压入队列中，然后最后将最上面k-1个元素依次弹出，现在堆顶的元素就是数组中第k大的元素。时间复杂度O(nlogn)。代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) queue.add(num);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) queue.poll();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1109. 航班预订统计</title>
      <link href="/2021/09/24/leetcode/1109-hang-ban-yu-ding-tong-ji/"/>
      <url>/2021/09/24/leetcode/1109-hang-ban-yu-ding-tong-ji/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] =[firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组answer，里面的元素是每个航班预定的座位总数。</p><p><span id="more"></span></p><blockquote><p>示例 1：</p><p>输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5输出：[10,55,45,25,25] 解释： 航班编号 1 2 3 4 5 预订记录 1 ： 10 10预订记录 2 ： 20 20 预订记录 3 ： 25 25 25 25 总座位数： 10 55 45 25 25因此，answer = [10,55,45,25,25] 示例 2：</p><p>输入：bookings = [[1,2,10],[2,2,15]], n = 2 输出：[10,25] 解释：航班编号 1 2 预订记录 1 ： 10 10 预订记录 2 ： 15 总座位数： 10 25因此，answer = [10,25]</p></blockquote><h2><span id="题解">题解</span></h2><p>使用方法：差分，也就是逆向前缀和，时间复杂度O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] booking : bookings) &#123;</span><br><span class="line">            ans[booking[<span class="number">0</span>]-<span class="number">1</span>] += booking[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (booking[<span class="number">1</span>] != n) ans[booking[<span class="number">1</span>]] -= booking[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] += ans[i-<span class="number">1</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java异常java.util.ConcurrentModificationException详解（转载）</title>
      <link href="/2021/08/02/java/java-yi-chang-java-util-concurrentmodificationexception-xiang-jie/"/>
      <url>/2021/08/02/java/java-yi-chang-java-util-concurrentmodificationexception-xiang-jie/</url>
      
        <content type="html"><![CDATA[<p>最近在Android开发的过程中，使用WorkerManager的时候产生了报错java.util.ConcurrentModificationException，于是就到网上进行查询，感觉这篇文章讲述的比较详尽，记录学习一下。</p><p>原文原载于<a href="https://www.cnblogs.com/snowater/p/8024776.html">java.util.ConcurrentModificationException异常问题详解</a></p><p><span id="more"></span></p><p>在Java开发过程中，使用iterator遍历集合的同时对集合进行修改就会出现java.util.ConcurrentModificationException异常，本文就以ArrayList为例去理解和解决这种异常。</p><h2><span id="一-单线程情况下问题分析及解决方案">一、单线程情况下问题分析及解决方案</span></h2><h3><span id="11-问题复现">1.1 问题复现</span></h3><p>先上一段抛异常的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>  &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        arrayList.add(Integer.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复现方法一</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">            arrayList.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复现方法二</span></span><br><span class="line">    iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">for</span> (Integer value : arrayList) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">            arrayList.remove(integer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中展示了两种能抛异常的实现方式。</p><h3><span id="12-问题原因分析">1.2、问题原因分析</span></h3><p>先来看实现方法一，方法一中使用Iterator遍历ArrayList，抛出异常的是iterator.next()。看下Iterator next方法实现源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    checkForComodification();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    cursor = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在next方法中首先调用了checkForComodification方法，该方法会判断modCount是否等于expectedModCount，不等于就会抛出java.util.ConcurrentModificationExcepiton异常。</p><p>我们接下来跟踪看一下modCount和expectedModCount的赋值和修改。</p><p>modCount是ArrayList的一个属性，继承自抽象类AbstractList，用于表示ArrayList对象被修改次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">protected</span> <span class="keyword">transient</span> <span class="type">int</span> <span class="variable">modCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>整个ArrayList中修改modCount的方法比较多，有add、remove、clear、ensureCapacityInternal等，凡是设计到ArrayList对象修改的都会自增modCount属性。</p><p>在创建Iterator的时候会将modCount赋值给expectedModCount，在遍历ArrayList过程中，没有其他地方可以设置expectedModCount了，因此遍历过程中expectedModCount会一直保持初始值20（调用add方法添加了20个元素，修改了20次）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount; <span class="comment">// 创建对象时初始化</span></span><br></pre></td></tr></table></figure><p>遍历的时候是不会触发modCount自增的，但是遍历到integer.intValue() ==5的时候，执行了一次arrayList.remove(integer)，这行代码执行后modCount++变为了21，但此时的expectedModCount仍然为20。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">checkForComodification</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行next方法时，遇到modCount !=expectedModCount方法，导致抛出异常java.util.ConcurrentModificationException。</p><p>明白了抛出异常的过程，但是为什么要这么做呢？很明显这么做是为了阻止程序员在不允许修改的时候修改对象，起到保护作用，避免出现未知异常。引用网上的一段解释，<a href="http://lz12366.iteye.com/blog/675016">点击查看解释来源</a></p><blockquote><p>Iterator 是工作在一个独立的线程中，并且拥有一个 mutex 锁。 Iterator被创建之后会建立一个指向原来对象的单链索引表，当原来的对象数量发生变化时，这个索引表的内容不会同步改变。当索引指针往后移动的时候就找不到要迭代的对象，所以按照 fail-fast 原则Iterator 会马上抛出 java.util.ConcurrentModificationException 异常。所以 Iterator 在工作的时候是不允许被迭代的对象被改变的。但你可以使用Iterator 本身的方法 remove() 来删除对象， Iterator.remove()方法会在删除当前迭代对象的同时维护索引的一致性。</p></blockquote><p>再来分析下第二种for循环抛异常的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">final</span> E[] elementData = (E[]) <span class="built_in">this</span>.elementData;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="built_in">this</span>.size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;</span><br><span class="line">        action.accept(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在for循环中一开始也是对expectedModCount采用modCount进行赋值。在进行for循环时每次都会有判定条件modCount==expectedModCount，当执行完arrayList.remove(integer)之后，该判定条件返回false退出循环，然后执行if语句，结果同样抛出java.util.ConcurrentModificationException异常。</p><p>这两种复现方法实际上都是同一个原因导致的。</p><h3><span id="13-问题解决方案">1.3 问题解决方案</span></h3><p>上述的两种复现方法都是在单线程运行的，先来说明单线程中的解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        arrayList.add(Integer.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = arrayList.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">            iterator.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种解决方案最核心的就是调用iterator.remove()方法。我们看看该方法源码为什么这个方法能避免抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在iterator.remove()方法中，同样调用了ArrayList自身的remove方法，但是调用完之后并非就return了，而是expectedModCount= modCount重置了expectedModCount值，使二者的值继续保持相等。</p><p>针对forEach循环并没有修复方案，因此在遍历过程中同时需要修改ArrayList对象，则需要采用iterator遍历。</p><p>上面提出的解决方案调用的是iterator.remove()方法，如果不仅仅是想调用remove方法移除元素，还想增加元素，或者替换元素，是否可以呢？浏览Iterator源码可以发现这是不行的，Iterator只提供了remove方法。</p><p>但是ArrayList实现了ListIterator接口，ListIterator类继承了Iter，这些操作都是可以实现的，使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>();</span><br><span class="line">    checkForComodification();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList.<span class="built_in">this</span>.remove(lastRet);</span><br><span class="line">        cursor = lastRet;</span><br><span class="line">        lastRet = -<span class="number">1</span>;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="二-多线程情况下的问题分析及解决方案">二、多线程情况下的问题分析及解决方案</span></h2><p>单线程问题解决了，再来看看多线程情况。</p><h3><span id="21-问题复现">2.1 问题复现</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">arrayList.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在个测试代码中，开启两个线程，一个线程遍历，另外一个线程遍历加修改。程序输出结果如下</p><blockquote><p>thread1 0 thread2 0 thread2 1 thread2 2 thread2 3 thread2 4 thread2 5thread2 6 thread2 7 thread2 8 thread2 9 thread2 10 thread2 11 thread2 12thread2 13 thread2 14 thread2 15 thread2 16 thread2 17 thread2 18thread2 19 Exception in thread "Thread-0"java.util.ConcurrentModificationException at java.util.ArrayList<span class="math inline">\(Itr.checkForComodification(ArrayList.java:901)  at java.util.ArrayList\)</span>Itr.next(ArrayList.java:851) atcom.snow.ExceptionTest$1.run(ExceptionTest.java:74) atjava.lang.Thread.run(Thread.java:745)</p><p>Process finished with exit code 0</p></blockquote><h3><span id="22-问题分析">2.2 问题分析</span></h3><p>从上面代码执行结果可以看出thread2 遍历结束后，thread1sleep完1000ms准备遍历第二个元素，next的时候抛出异常了。我们从时间点分析一下抛异常的原因</p><table><colgroup><col style="width: 25%"><col style="width: 16%"><col style="width: 29%"><col style="width: 29%"></colgroup><thead><tr><th>时间点</th><th>arrayList.modCount</th><th>thread1 iterator.expectedModCount</th><th>thread2 iterator.expectedModCount</th></tr></thead><tbody><tr><td>thread start，初始化iterator</td><td>20</td><td>20</td><td>20</td></tr><tr><td>thread2.remove()调用之后</td><td>21</td><td>20</td><td>21</td></tr></tbody></table><p>两个thread都是使用的同一个arrayList，thread2修改完后modCount =21，此时thread2的expectedModCount = 21可以一直遍历到结束；thread1的expectedModCount仍然为20，因为thread1的expectedModCount只是在初始化的时候赋值，其后并未被修改过。因此当arrayList的modCount被thread2修改为21之后，thread1想继续遍历必定会抛出异常了。</p><p>在这个示例代码里面，两个thread，每个thread都有自己的iterator，当thread2通过iterator方法修改expectedModCount必定不会被thread1感知到。这个跟ArrayList非线程安全是无关的，即使这里面的ArrayList换成Vector也是一样的结果，不信上测试代码：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">    Vector&lt;Integer&gt; vector = <span class="keyword">new</span> <span class="title class_">Vector</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">        vector.add(Integer.valueOf(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = vector.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            ListIterator&lt;Integer&gt; iterator = vector.listIterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;thread2 &quot;</span> + integer.intValue());</span><br><span class="line">                <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后输出结果为：</p><blockquote><p>thread1 0 thread2 0 thread2 1 thread2 2 thread2 3 thread2 4 thread2 5thread2 6 thread2 7 thread2 8 thread2 9 thread2 10 thread2 11 thread2 12thread2 13 thread2 14 thread2 15 thread2 16 thread2 17 thread2 18thread2 19 Exception in thread "Thread-0"java.util.ConcurrentModificationException at java.util.Vector<span class="math inline">\(Itr.checkForComodification(Vector.java:1184)  at java.util.Vector\)</span>Itr.next(Vector.java:1137) atcom.snow.ExceptionTest$3.run(ExceptionTest.java:112) atjava.lang.Thread.run(Thread.java:745)</p><p>Process finished with exit code 0</p></blockquote><p>test5()方法执行结果和test4()是相同的，那如何解决这个问题呢？</p><h3><span id="23-多线程下的解决方案">2.3 多线程下的解决方案</span></h3><h4><span id="231方案一iterator遍历过程加同步锁锁住整个arraylist">2.3.1方案一：iterator遍历过程加同步锁，锁住整个arrayList</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">arrayList.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">             <span class="keyword">synchronized</span> (arrayList) &#123;</span><br><span class="line">                ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">              <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (arrayList) &#123;</span><br><span class="line">                ListIterator&lt;Integer&gt; iterator = arrayList.listIterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 &quot;</span> + integer.intValue());</span><br><span class="line">                    <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   thread1.start();</span><br><span class="line">    thread2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>这种方案本质上是将多线程通过加锁来转变为单线程操作，确保同一时间内只有一个线程去使用iterator遍历arrayList，其它线程等待，效率显然是只有单线程的效率。</p><h4><span id="232方案二使用copyonwritearraylist有坑要明白原理再用否则你就呆坑里吧">2.3.2方案二：使用CopyOnWriteArrayList，有坑！要明白原理再用，否则你就呆坑里吧。</span></h4><p>我们先来看代码，很有意思咯</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">CopyOnWriteArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            list.add(Integer.valueOf(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                ListIterator&lt;Integer&gt; iterator = list.listIterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread1 &quot;</span> + iterator.next().intValue());</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 &quot;</span> + integer.intValue());</span><br><span class="line">                    <span class="keyword">if</span> (integer.intValue() == <span class="number">5</span>) &#123;</span><br><span class="line">                        list.remove(integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (Integer integer : list) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;thread2 again &quot;</span> + integer.intValue());</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                ListIterator&lt;Integer&gt; iterator = list.listIterator();</span></span><br><span class="line"><span class="comment">//                while (iterator.hasNext()) &#123;</span></span><br><span class="line"><span class="comment">//                    Integer integer = iterator.next();</span></span><br><span class="line"><span class="comment">//                    System.out.println(&quot;thread2 &quot; + integer.intValue());</span></span><br><span class="line"><span class="comment">//                    if (integer.intValue() == 5) &#123;</span></span><br><span class="line"><span class="comment">//                        iterator.remove();</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>先不分析，看执行结果，这个执行结果重点关注字体加粗部分。</p><blockquote><p>thread1 0 thread2 0 thread2 1 thread2 2 thread2 3 <strong>thread24</strong> <strong>thread2 5</strong> <strong>thread2 6</strong> thread27 thread2 8 thread2 9 thread2 10 thread2 11 thread2 12 thread2 13thread2 14 thread2 15 thread2 16 thread2 17 thread2 18 thread2 19thread2 again 0 thread2 again 1 thread2 again 2 thread2 again 3<strong>thread2 again 4</strong> <strong>thread2 again 6</strong>thread2 again 7 thread2 again 8 thread2 again 9 thread2 again 10 thread2again 11 thread2 again 12 thread2 again 13 thread2 again 14 thread2again 15 thread2 again 16 thread2 again 17 thread2 again 18 thread2again 19 thread1 1 thread1 2 thread1 3 thread1 4 thread1 5 thread1 6thread1 7 thread1 8 thread1 9 thread1 10 thread1 11 thread1 12 thread113 thread1 14 thread1 15 thread1 16 thread1 17 thread1 18 thread1 19</p><p>Process finished with exit code 0</p></blockquote><p>我们先分析thread2的输出结果，第一次遍历将4 56都输出，情理之中；第一次遍历后删除掉了一个元素，第二次遍历输出46，符合我们的预期。</p><p>再来看下thread1的输出结果，有意思的事情来了，thread1 仍然输出了4 56，什么鬼？thread1和thread2都是遍历list，list在thread1遍历第二个元素的时候就已经删除了一个元素了，为啥还能输出5？</p><p>为了了解这个问题，需要了解CopyOnWriteArrayList是如何做到一边遍历的同时还能一边修改并且还不抛异常的。</p><p>在这里不想再深入分析CopyOnWriteArrayList代码，后续会专门出一篇博客来解释这个类的源码的。</p><p>这里说一下CopyOnWriteArrayList的解决思路，其实很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList本质上是对array数组的一个封装，一旦CopyOnWriteArrayList对象发生任何的修改都会new一个新的Object[]数组newElement，在newElement数组上执行修改操作，修改完成后将newElement赋值给array数组（array=newElement）。</p><p>因为array是volatile的，因此它的修改对所有线程都可见。</p><p>了解了CopyOnWriteArrayList的实现思路之后，我们再来分析上面代码test6为什么会出现那样的输出结果。先来看下thread1和thread2中用到的两种遍历方式的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">forEach</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> E&gt; action)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (action == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line"><span class="comment">// 在遍历开始前获取当前数组</span></span><br><span class="line">Object[] elements = getArray();</span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> elements.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) elements[i];</span><br><span class="line">action.accept(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title function_">listIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">COWIterator</span>&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">COWIterator</span>&lt;E&gt; <span class="keyword">implements</span> <span class="title class_">ListIterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="comment">/** Snapshot of the array */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;</span><br><span class="line">        <span class="comment">/** Index of element to be returned by subsequent call to next.  */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> cursor;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">COWIterator</span><span class="params">(Object[] elements, <span class="type">int</span> initialCursor)</span> &#123;</span><br><span class="line">            cursor = initialCursor;</span><br><span class="line">            <span class="comment">// 初始化为当前数组</span></span><br><span class="line">            snapshot = elements;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 已经不支持Iterator remove操作了！！</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (! hasNext())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处省略其他无关代码</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这两种遍历方式有个共同的特点：都在初始化的时候将当前数组保存下来了，之后的遍历都将会遍历这个数组，而不管array如何变化。</p><table><colgroup><col style="width: 14%"><col style="width: 15%"><col style="width: 20%"><col style="width: 24%"><col style="width: 24%"></colgroup><thead><tr><th>时间点</th><th>CopyOnWriteArrayList的array</th><th>thread1 iterator 初始化的Object数组</th><th>thread2 第一次遍历forEach初始化的Object数组</th><th>thread2 第二次遍历forEach初始化的Object数组</th></tr></thead><tbody><tr><td>thread start</td><td>假设为A</td><td>A</td><td>A</td><td>/</td></tr><tr><td>thread2 调用remove方法之后</td><td>假设为B</td><td>A</td><td>A</td><td>B</td></tr></tbody></table><p>有了这个时间节点表就很清楚了，thread1和thread2start的时候都会将A数组初始化给自己的临时变量，之后遍历的也都是这个A数组，而不管CopyOnWriteArrayList中的array发生了什么变化。因此也就解释了thread1在thread2remove掉一个元素之后为什么还会输出5了。在thread2中，第二次遍历初始化数组变成了当前的array，也就是修改后的B，因此不会有Integer.valueOf(5)这个元素了。</p><p>从test6执行结果来看，CopyOnWriteArrayList确实能解决一边遍历一边修改并且还不会抛异常，但是这也是有<strong>代价</strong>的：</p><ol type="1"><li><p>thread2对array数组的修改thread1并不能被动感知到，只能通过hashCode()方法去主动感知，否则就会一直使用修改前的数据</p></li><li><p>每次修改都需要重新new一个数组，并且将array数组数据拷贝到new出来的数组中，效率会大幅下降</p></li></ol><p>此外CopyOnWriteArrayList中的ListIterator实现是不支持remove、add和set操作的，一旦调用就会抛出UnsupportedOperationException异常，因此test6注释代码34-41行中如果运行是会抛异常的。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡特兰数</title>
      <link href="/2021/07/27/algorithms/qia-te-lan-shu/"/>
      <url>/2021/07/27/algorithms/qia-te-lan-shu/</url>
      
        <content type="html"><![CDATA[<p>考虑以下问题：</p><blockquote><p>现在我们有<span class="math inline">\(n+1\)</span>个数，<span class="math inline">\(x_0,x_1,x_2,\cdots,x_n\)</span>，考虑它们的乘积<span class="math inline">\(x_1\cdot x_2\cdotsx_n\)</span>，现在我们可以在其中插入括号来改变计算顺序。那么一共有多少种排列的顺序呢？比如说，现在有三个数<span class="math inline">\(x_0, x_1, x_2\)</span>，它们的计算顺序有<span class="math inline">\((x_0x_1)x_2\)</span>以及<span class="math inline">\(x_0(x_1x_2)\)</span>两种排列方式</p></blockquote><span id="more"></span><h3><span id="问题分析">问题分析</span></h3><p>我们可以使用递归的思想来考虑这个问题。我们把这<span class="math inline">\(n+1\)</span>个数分为两组，在第<span class="math inline">\(k\)</span>个数处分开，就形成了下面<span class="math inline">\(A, B\)</span>两组数。</p><p><span class="math display">\[\underbrace{(x_0\space x_1\space x_2 \cdots x_k)}_{A},\underbrace{(\space x_{k+1}\cdots x_{n-1}\space x_{n})}_{B}\]</span></p><p>我们记<span class="math inline">\(n+1\)</span>个数的插入括号后的计算顺序个数为<span class="math inline">\(C_n\)</span>，那么<span class="math inline">\(A\)</span>的计算顺序个数就是<span class="math inline">\(C_k\)</span>，<span class="math inline">\(B\)</span>的就是<span class="math inline">\(C_{n-k-1}\)</span>。所以说，如果说我们把最后一个括号放在第<span class="math inline">\(k\)</span>个数的地方，那么我们总的个数就是<span class="math inline">\(C_kC_{n-k-1}\)</span>。这里<span class="math inline">\(k\)</span>可以从0到<span class="math inline">\(n-1\)</span>，根据加法原则，</p><p><span class="math display">\[C_n=\sum^{n-1}_{k=0}C_kC_{n-k-1}, \space\space\space\space n\geqslant 1\]</span></p><p>剩下的事情就是用数学方法计算出这个数列的通项公式。</p><h3><span id="数学解法">数学解法</span></h3><p>通过生成函数法(generatingfunction)可以解出符合方法一中递推公式的数列的通项公式。</p><p>首先我们定义函数</p><p><span class="math display">\[f(x)=\sum_{k\geqslant0}C_kx^k\]</span></p><p>然后我们可以将上面的递推公式推广到<span class="math inline">\(n\geqslant0\)</span>，也就是</p><p><span class="math display">\[C_n=\sum_{k\geqslant0}C_kC_{n-k-1}+\mathbb{I}_{\{n=0\}},\space\space\space\space \forall n\geqslant0\]</span></p><p>其中<span class="math inline">\(\mathbb{I}_{\{n=0\}}\)</span>是示意函数(indicatorfunction)，当<span class="math inline">\(n=0\)</span>时此函数值为1，否则值为0。并且我们定义当<span class="math inline">\(k&lt;0\)</span>时，<span class="math inline">\(C_k=0\)</span>。等式两边同乘我们可以得到</p><p><span class="math display">\[\begin{aligned}f(x)&amp; =\sum_{n\geqslant0}C_nx^n  =\sum_{n\geqslant0}C_kC_{n-k-1}x^n+\mathbb{I}_{\{n=0\}}x^n\\&amp; = \sum_{n\geqslant0}\sum_{k\geqslant0}C_kC_{n-k-1}x^kx^{n-k}+1 \\&amp; =\sum_{k\geqslant0}\Big[C_kx^k\sum_{n\geqslant0}C_{n-k-1}x^{n-k-1}\cdotx\Big]+1 \\\end{aligned}\]</span></p><p>我们对<span class="math inline">\(n-k+1\)</span>进行一个换元之后，式子中的<span class="math inline">\(\sum_{n\geqslant0}C_{n-k-1}x^{n-k-1}\)</span>可以写成<span class="math inline">\(\sum_{j\geqslant0}Cjx^j\)</span>，也就是<span class="math inline">\(f(x)\)</span>，所以我们得到</p><p><span class="math display">\[\begin{aligned}f(x)&amp; =\sum_{k\geqslant0}C_kx^kf(x)x+1 \\&amp; =x\big(f(x)\big)^2+1 \\\Longrightarrow f(x)&amp; =\frac{1\pm\sqrt{1-4x}}{2x}\end{aligned}\]</span></p><p>通过观察，由于<span class="math inline">\(f(x)=C_0+C_1x+C_2x^2+\cdots\)</span>并且<span class="math inline">\(f(0)=C_0=1\)</span>，可以推断出这里我们需要取减号。接下来计算<span class="math inline">\((1-4x)^{\frac{1}{2}}\)</span></p><p><span class="math display">\[\begin{aligned}(1-4x)^{\frac{1}{2}} &amp;=\sum_{k\geqslant0}\tbinom{\frac{1}{2}}{k}(-4x)^k\space\space\space\space |x|&lt;\frac{1}{4}\\ &amp; =1+\sum_{k\geqslant1}(-1)^k\tbinom{\frac{1}{2}}{k}4^kx^k\end{aligned}\]</span></p><p>通过广义二项式定理，我们可以进一步化简</p><p><span class="math display">\[\begin{aligned}\tbinom{\frac{1}{2}}{k}&amp;=\frac{\frac{1}{2}(\frac{1}{2}-1)\cdots(\frac{1}{2}-k+1)}{k!} \\&amp; =\frac{1}{2k}\cdot\frac{(-\frac{1}{2})(-\frac{3}{2})\cdots(-\frac{1}{2}-(k-1)+1)}{(k-1)!}\\&amp; =\frac{1}{2k}\cdot(-\frac{1}{2})^{k-1}\cdot\frac{1\cdot3\cdots(2k-3)}{(k-1)!}\\&amp; =\frac{1}{2k}\cdot(-\frac{1}{2})^{k-1}\cdot\frac{1\cdot2\cdot3\cdot4\cdots(2k-3)\cdot(2k-2)}{2^{k-1}(k-1)!(k-1)!}\\&amp; =\frac{1}{2k}\cdot(-\frac{1}{4})^{k-1}\cdot\tbinom{2k-2}{k-1}\end{aligned}\]</span></p><p>代入上述式子可得</p><p><span class="math display">\[\begin{aligned}(1-4x)^{\frac{1}{2}}&amp;=1-\sum_{k\geqslant1}\frac{1}{2k}\tbinom{2k-2}{k-1}\cdot4\cdot x^k \\&amp; =1-2x\sum_{k\geqslant0}\frac{1}{k+1}\tbinom{2k}{k}x^k\end{aligned}\]</span></p><p>最后把这个式子代回到<span class="math inline">\(f(x)\)</span>的表达式中去，我们可以得到</p><p><span class="math display">\[f(x)=\sum_{k\geqslant0}\frac{1}{k+1}\tbinom{2k}{k}x^k\]</span></p><p>与<span class="math inline">\(f(x)=\sum_{k\geqslant0}C_kx^k\)</span>进行对比我们可以得出结论</p><p><span class="math display">\[C_n=\frac{1}{n+1}\tbinom{2n}{n}\]</span></p><p>这就是卡特兰数(Catalan Number)</p><h3><span id="卡特兰数的其他等价问题">卡特兰数的其他等价问题</span></h3><ol type="1"><li><p>Dyck word的个数. Dyck word表示一个有由<span class="math inline">\(n\)</span>个X和<span class="math inline">\(n\)</span>个Y组成的字符串，并且需要满足：在任意一个位置，之前的X个数都必须大于等于Y的个数。</p><p>这里可以给出一个卡特兰数简单的计算方法</p><p>首先不考虑限制条件，那么总共的排列方式有<span class="math inline">\(\tbinom{2n}{n}\)</span>种，然后考虑不满足题目限制的个数。假设在第<span class="math inline">\(2m+1\)</span>处有<span class="math inline">\(m+1\)</span>个Y和<span class="math inline">\(m\)</span>个X(不满足题目要求)，那么后面就有<span class="math inline">\(n-m\)</span>个X和<span class="math inline">\(n-m-1\)</span>个Y，将这里的X全部替换为Y，Y全部替换为X，那么这样的字符串就变成了由<span class="math inline">\(n-1\)</span>个X和<span class="math inline">\(n+1\)</span>个Y组成的字符串。这样的字符串总数是<span class="math inline">\(\tbinom{2n}{n+1}\)</span>，所以总数是</p><p><span class="math display">\[\tbinom{2n}{n}-\tbinom{2n}{n+1}=\frac{1}{n+1}\tbinom{2n}{n}\]</span></p></li><li><p>包含n组括号的合法运算式的个数。</p></li><li><p>不相交的弦问题：在一个圆周上分布着<span class="math inline">\(2n\)</span>个点，要求在每两个点之间连接一条弦，并且弦与弦不能相交，求这样的连接方式个数。</p></li><li><p>格路问题：所有在<span class="math inline">\(n\timesn\)</span>格点中不越过对角线的单调路径的个数。可以等价于计算Dyckword的个数(X代表“向右”，Y表示向右)</p></li></ol><h3><span id="参考资料">参考资料</span></h3><p>维基百科,https://zh.wikipedia.org/wiki/%E5%8D%A1%E5%A1%94%E5%85%B0%E6%95%B0</p><p>卡特兰数（Catalannumber）（一）,https://zhuanlan.zhihu.com/p/31317307</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java将List数据拆分进行分批处理</title>
      <link href="/2021/07/26/java/java-jiang-list-shu-ju-chai-fen-jin-xing-fen-pi-chu-li/"/>
      <url>/2021/07/26/java/java-jiang-list-shu-ju-chai-fen-jin-xing-fen-pi-chu-li/</url>
      
        <content type="html"><![CDATA[<p>最近碰到一个问题，如果将一个数据量比较大的List数据发送到服务器上，这样的批量操作可能会由一个小错误导致整个请求无法实现，这个时候我们就可以考虑将List进行拆分，分批处理，降低失误率。</p><span id="more"></span><p>考虑到List中并没有实现<code>sublist</code>的方法，所以我们可以自己实现一个<code>sublist</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 将list拆分成指定数量的小list</span></span><br><span class="line"><span class="comment">* 注: 使用的subList方式,返回的是list的内部类,不可做元素的删除,修改,添加操作</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> length 数量</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> list 大list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;T&gt;&gt; <span class="title function_">getSubList</span><span class="params">(<span class="type">int</span> length, List&lt;T&gt; list)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> size / length + <span class="number">1</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> size % length == <span class="number">0</span>;</span><br><span class="line">    List&lt;List&lt;T&gt;&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == temp - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (result) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            subList.add(list.subList(length * i, size)) ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            subList.add(list.subList(length * i, length * (i + <span class="number">1</span>))) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> subList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考资料：<a href="https://blog.csdn.net/weixin_43687353/article/details/104756939">Java中将大list拆分成多个小list，分批操作</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：排序算法</title>
      <link href="/2021/07/26/algorithms/suan-fa-pai-xu-suan-fa/"/>
      <url>/2021/07/26/algorithms/suan-fa-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2><span id="选择排序-selection-sort">选择排序 (Selection sort)</span></h2><p><code>Selection Sort</code>是一种最基本的排序方法。这种排序方法的基本想法就是：第一次找到最小的数与第一位进行交换，第二次找到第二小的数与第二位进行交换，第三次找到第三小的数与第三位进行交换……以此类推。由于找第i小的数时，前面i-1个数已经是前i-1个最小的数了，所以只要在后N-i+1个数中找到最小的数和第i个数进行交换就好了。也就是说，这个方法需要嵌套两个<code>for</code>循环，时间复杂度很明显也就是<span class="math inline">\(O(N^2)\)</span>了。Java 代码：</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectionSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">double</span>[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; lengh; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i</span><br><span class="line">            <span class="title function_">for</span><span class="params">(<span class="type">int</span> j = i; j &lt; length; j++)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (a[j] &lt; a[min])&#123;</span><br><span class="line">                min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[min] = a[i] + a[min];</span><br><span class="line">            a[i] = a[min] - a[i];</span><br><span class="line">            a[min] = a[min] - a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="插入排序-insertion-sort">插入排序 (Insertion sort)</span></h2><p><code>Insertion Sort</code>是另一种基本的排序方法，它会比<code>Selection Sort</code>更有效率一些，因为这种排序方法的效率和原本数组的混乱度有关，如果说这个数组本身就已经排序十分整齐的话，这个时候这种算法的效率就会很高了。这种算法的基本想法就和我们打扑克的时候理牌的方法是一样的。我们打牌的时候，会对我们想要进行移动的那张牌进行大小判断，将那张牌插入到我们已经整理好的一堆牌里的对应的位置。这种算法就是这样，我们假设我们想要移动第i个数，并且前i-1张牌都已经进行好了排序，那么我们只需要对这个数与前一个数进行大小的比较，如果这个数更小，那么就进行交换，直到我们找到了前一个位置的数比这个第i个数还要小的时候，再去移动下一个数。所以，这个方法仍然需要嵌套两个<code>for</code>循环，时间复杂度也是<span class="math inline">\(O(N^2)\)</span>。Java代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertionSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">double</span>[] a)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt;= <span class="number">0</span> &amp;&amp; a[j]&lt; a[j-<span class="number">1</span>]; j--)&#123;</span><br><span class="line">                a[j] = a[j] + a[j-<span class="number">1</span>];</span><br><span class="line">                a[j-<span class="number">1</span>] = a[j] - a[j-<span class="number">1</span>];</span><br><span class="line">                a[j] = a[j] - a[j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="归并排序-merge-sort">归并排序 (Merge sort)</span></h2><p>在之前寻找一个数组中的最大值的时候，我们可以使用二分法的方法寻找最大值，可以大大提高效率。那么在排序的时候，也可以使用类似的想法，利用分治(divideand conquer)可以将时间复杂度降低至<span class="math inline">\(O(lgN)\)</span>。首先，我们可以考虑一下情况，有两组数，都是已经排好序的，如果将这两组数按照顺序合并在一起，那么我们可以新创建一个数组，存储新的有顺序的数。首先，比较两组数的第一位数，将较小的数放进新的数组中，较小数所在数组的下一位与较大数所在数组原来的数继续进行比较，直到有一组数达到了尽头，然后把另一组剩下的数放进去得到的新的数组就是排好序的合并后的数组。Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="comment">// 数组aux[]为原数组的复制</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">inr</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= hi; i++)&#123;</span><br><span class="line">        aux[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo; k &lt;= hi; k++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(less(a[i], a[j])) a[k] = aux[i++];</span><br><span class="line">        <span class="keyword">else</span> a[k] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以使用分治算法递归进行计算。Java代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Comparable[] aux;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span>&#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">Comaparable</span>[a.length]; </span><br><span class="line">        sort(a, <span class="number">0</span>, hi / <span class="number">2</span>, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">        sort(a, lo, mid);</span><br><span class="line">        sort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">        merge(a, lo, mid, hi);</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> mid, <span class="type">int</span> hi)</span>&#123;</span><br><span class="line">        <span class="comment">// 数组aux[]为原数组的复制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            aux[k] = a[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> lo; k &lt;= hi; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; mid) a[k] = aux[j++]</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(less(a[i], a[j])) a[k] = aux[i++];</span><br><span class="line">            <span class="keyword">else</span> a[k] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="快速排序-quick-sort">快速排序 (Quick sort)</span></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Comparable[] a)</span> &#123;</span><br><span class="line">        quickSort(a, <span class="number">0</span>, a.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">partitionIndex</span> <span class="operator">=</span> partition(a, lo, hi);</span><br><span class="line">            quickSort(a, lo, partitionIndex-<span class="number">1</span>);</span><br><span class="line">            quickSort(a, hi, partitionIndex+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Comparable[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同版本的partition：主要思想都是一致的，将比pivot小的放在左边，比他大的放在pivot的右边</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 算法第四版 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> lo;</span><br><span class="line">    <span class="comment">// Scan right, scan left, check for scan complete, and exchange</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[++i] &lt; a[pivot]) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (a[pivot] &lt; a[--j]) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    swap(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 菜鸟教程 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Comaparable[] a, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> lo;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">            swap(arr, i, index);</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>539. 移动零</title>
      <link href="/2021/07/26/leetcode/539-yi-dong-ling/"/>
      <url>/2021/07/26/leetcode/539-yi-dong-ling/</url>
      
        <content type="html"><![CDATA[<p>给一个数组 <em>nums</em> 写一个函数将 <code>0</code>移动到数组的最后面，非零元素保持原数组的顺序</p><h3><span id="样例">样例</span></h3><p>例1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0, 1, 0, 3, 12],</span><br><span class="line">输出: [1, 3, 12, 0, 0].</span><br></pre></td></tr></table></figure><span id="more"></span><p>例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [0, 0, 0, 3, 1],</span><br><span class="line">输出: [3, 1, 0, 0, 0].</span><br></pre></td></tr></table></figure><h3><span id="注意事项">注意事项</span></h3><p>1.必须在原数组上操作 2.最小化操作数</p><h3><span id="解法">解法</span></h3><p>算法：双指针，简单粗暴。用两个指针 <code>right</code>和<code>left</code>，<code>right</code>用来右移数组，碰到不为0的元素就赋值到 <code>left</code>指针处。时间复杂度：<span class="math inline">\(O(N)\)</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java solution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[right] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                left += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt; length; i++) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法：回溯法学习记录</title>
      <link href="/2021/07/26/algorithms/suan-fa-hui-su-fa-xue-xi-ji-lu/"/>
      <url>/2021/07/26/algorithms/suan-fa-hui-su-fa-xue-xi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>回溯法是一种非常常见的算法，八皇后问题和迷宫问题都可以使用回溯法进行求解。以下是百度百科中对于回溯法的解释</p><blockquote><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯<a href="https://baike.baidu.com/item/条件/1783021">条件</a>的某个<a href="https://baike.baidu.com/item/状态/33204">状态</a>的点称为“回溯点”。——百度百科</p></blockquote><p>回溯法采用一种试探回溯的思想。我们从一个一个分支逐步深入，一旦发现当前分支不是我们所需要的，就排除当前分支，然后回到上一步试探其他分支。迷宫问题就是一种常见的使用回溯法的算法问题。事实上，在现实生活中走迷宫我们也经常使用这种试探的走法。</p><p>除了迷宫问题，全排列问题，八皇后问题也都是回溯法的典型问题</p><p><span id="more"></span></p><h3><span id="八皇后问题">八皇后问题</span></h3><blockquote><p>问题表述为：在8×8格的<a href="https://baike.baidu.com/item/国际象棋/80888">国际象棋</a>上摆放8个<a href="https://baike.baidu.com/item/皇后/15860305">皇后</a>，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p></blockquote><p>对于八皇后问题，我们采用逐行试探的方法。先在当前行找到一个符合条件的位置放置皇后，如果找不到，就回溯一行排除当前位置继续寻找，直到在最后一行找到一个合适的位置，就可以得到一个解。</p><p>一下是四皇后问题的一个解的寻找过程。首先在(0,0)处放置皇后，转移到行1，查找到第一个合法的位置为(1,3)。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png"></p><p>接着搜寻行2，发现没有符合条件的位置，于是回溯到行1，继续寻找下一个合法的位置(1,4)。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png"></p><p>继续试探到行2，找到了一个合法的位置(2,1)。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png"></p><p>发现在这种情况下行3没有合法的位置，回溯到行2，发现行2剩余的位置也没有合法的，回溯到行1，行1已经没有剩余位置，直接回溯到第0行。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png"></p><p>接着试探，起始位置为(0,1)。第1行试探，皇后放在(1,3)</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png"></p><p>第2行，皇后放在(2,0)。第3行，皇后放在(3,2)。四皇后问题的第一个解找到。</p><p><img src="https://i.loli.net/2021/07/26/W3ZKphw9uAESN8V.png"></p><p>代码实现中特别需要关注的问题是循环何时终止，以及对于边界的处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> QUEENS 4</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> EMPTY 0</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> FULL 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> checkboard[QUEENS][QUEENS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> boardrow[QUEENS] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要判断当前行与之前几行是否冲突</span></span><br><span class="line"><span class="comment">// assert： 0&lt;=x&lt;QUEENS &amp;&amp; 0&lt;=y&lt;QUEENS</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">collide</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = x - <span class="number">1</span>, j = y - <span class="number">1</span>, k = y + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; (j &gt;= <span class="number">0</span> || k &lt; QUEENS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkboard[i][y] == FULL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= <span class="number">0</span> &amp;&amp; checkboard[i][j--] == FULL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; QUEENS &amp;&amp; checkboard[i][k++] == FULL)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">drawBoard</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;---------------\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; QUEENS; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; QUEENS; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d | &quot;</span>, checkboard[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n---------------\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意边界状态</span></span><br><span class="line"><span class="comment">// 注意循环结束判断</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Queen</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// 棋盘坐标</span></span><br><span class="line">    <span class="type">int</span> numOfSol = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">0</span> || y &lt; QUEENS) &#123;</span><br><span class="line">        <span class="comment">/* 何时回溯</span></span><br><span class="line"><span class="comment">         * 1. 当前行数达到最大（得到一个解）</span></span><br><span class="line"><span class="comment">         * 2. 列数达到最大（当前情况解已经列举完毕）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= QUEENS) &#123;</span><br><span class="line">            numOfSol++;</span><br><span class="line">            x--;</span><br><span class="line">            drawBoard();</span><br><span class="line">            y = boardrow[x];</span><br><span class="line">            checkboard[x][y++] = EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= QUEENS) &#123;</span><br><span class="line">            x--;</span><br><span class="line">            <span class="keyword">if</span> (x &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            y = boardrow[x];</span><br><span class="line">            checkboard[x][y++] = EMPTY;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (collide(x, y)) &#123;</span><br><span class="line">            <span class="comment">// 如果冲突，移动至当前行下一列</span></span><br><span class="line">            y++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不冲突，并且在范围内</span></span><br><span class="line">            <span class="comment">// 那么移动至下一行首列</span></span><br><span class="line">            checkboard[x][y] = FULL;</span><br><span class="line">            boardrow[x++] = y;</span><br><span class="line">            y = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfSol;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> c = Queen();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of Solution: %d&quot;</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里循环结束的终点条件是当回溯到第0行第4列时，就会继续回溯到第-1行，也就是x&lt;0时结束整个循环。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android studio中log的内容不完整（log被截断）</title>
      <link href="/2021/07/26/android/android-studio-zhong-log-de-nei-rong-bu-wan-zheng/"/>
      <url>/2021/07/26/android/android-studio-zhong-log-de-nei-rong-bu-wan-zheng/</url>
      
        <content type="html"><![CDATA[<p>今天在调试Android程序的时候，想要log一段json数据，数据挺大的，折腾了半天，原来以为是JSON的长度会不会是有上限的，经过搜索发现并没有，参考StackOverflow的两个问题<a href="https://stackoverflow.com/questions/57340897/what-is-limit-of-json-array-and-how-to-overcome-it">android- What is limit of json array and how to overcome it - StackOverflow</a>和<a href="https://stackoverflow.com/questions/1262376/is-there-a-limit-on-how-much-json-can-hold">Isthere a limit on how much JSON can hold? - StackOverflow</a>。此外，还试图研究Java中String的长度上限，参考这篇文章<a href="https://blog.csdn.net/cyw1900/article/details/48179911">java中String类型的最大长度_cyw1900的专栏-CSDN博客_string类型的最大长度</a>，发现String的上限远比我的数据要大的多，总结就是<mark>String类型的长度为320339960，其最大容量不超过1个G</mark>。</p><p>后来发现是Androidstudio的log的字符串长度是有上限的，logcat在实现上对于message的内存分配大概是4k左右，实际上根据我的个人的log来看，截取的部分大约是4056个字符串，超过的部分都会被截断。经过搜索，发现网上一个博主自己定义一个debug工具类切分超过4k的message，来解决这个问题。</p><span id="more"></span><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DebugUtils</span> &#123;</span><br><span class="line"><span class="comment">// 使用Log来显示调试信息,因为log在实现上每个message有4k字符长度限制</span></span><br><span class="line"><span class="comment">// 所以这里使用自己分节的方式来输出足够长度的message</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">4000</span>;</span><br><span class="line">        String sub;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; str.length()) &#123;</span><br><span class="line">            <span class="comment">// java的字符不允许指定超过总的长度end</span></span><br><span class="line">            <span class="keyword">if</span> (str.length() &lt;= index + maxLength) &#123;</span><br><span class="line">                sub = str.substring(index);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sub = str.substring(index, maxLength);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            index += maxLength;</span><br><span class="line">            Log.i(<span class="string">&quot;qidizi_debug&quot;</span>, sub.trim());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>本文参考文章：<a href="https://blog.csdn.net/qidizi/article/details/47291803">android的logcat的message有字符长度的限制,超过将直接截断</a>，仅作为个人笔记记录。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Bug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 使用过的命令记录(ubuntu)</title>
      <link href="/2021/07/24/backend/linux-ming-ling-ji-lu/"/>
      <url>/2021/07/24/backend/linux-ming-ling-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>本文记录一下使用过搜索过的Linux的一些命令，作为一个Linux新手，很多命令用了就忘，还是稍微记录一下比较好，单纯的做个笔记。</p><p><span id="more"></span></p><h2><span id="网络">网络</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示所有网络接口和相关IP地址的列表</span></span><br><span class="line">ip addr</span><br><span class="line"><span class="comment"># 显示内部IP地址</span></span><br><span class="line">hostname -I</span><br><span class="line">ifconfig</span><br><span class="line"><span class="comment"># 检测监听端口22</span></span><br><span class="line"><span class="built_in">sudo</span> lsof -i:22</span><br><span class="line"><span class="comment"># 查看进程</span></span><br><span class="line">ps -A | grep 进程名称</span><br><span class="line">ps -A <span class="comment"># 查看所有</span></span><br><span class="line">ps -ef <span class="comment"># 更详尽的信息</span></span><br><span class="line"><span class="comment"># 结束进程</span></span><br><span class="line"><span class="built_in">kill</span> [信号代码] 进程PID <span class="comment"># kill -9 PID</span></span><br></pre></td></tr></table></figure><h2><span id="文件管理">文件管理</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示文件</span></span><br><span class="line"><span class="built_in">ls</span> -t(时间顺序) -a(所有文件) </span><br><span class="line"><span class="comment"># 返回历史上一级目录</span></span><br><span class="line"><span class="built_in">cd</span> -</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$OLDPWD</span></span><br><span class="line"><span class="comment"># 移动文件</span></span><br><span class="line"><span class="built_in">mv</span> [options] 源文件或目录 目标文件或目录</span><br><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line"><span class="built_in">mv</span> abc 1234 重命名文件名为1234</span><br><span class="line"><span class="comment"># 新建文件</span></span><br><span class="line"><span class="built_in">touch</span> filename OR vim newFileName</span><br></pre></td></tr></table></figure><h3><span id="文件压缩">文件压缩</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件 file1 和目录 dir2 到 test.tar.gz</span></span><br><span class="line">tar -zcvf test.tar.gz file1 dir2</span><br><span class="line"><span class="comment"># 解压 test.tar.gz（将 c 换成 x 即可）</span></span><br><span class="line">tar -zxvf test.tar.gz</span><br><span class="line"><span class="comment"># 列出压缩文件的内容</span></span><br><span class="line">tar -ztvf test.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>z : 使用 gzip 来压缩和解压文件 -v : --verbose 详细的列出处理的文件 -f: --file=ARCHIVE 使用档案文件或设备，这个选项通常是必选的 -c : --create创建一个新的归档（压缩包） -x : 从压缩包中解出文件</p></blockquote><h2><span id="卸载软件">卸载软件</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看已经安装的软件</span></span><br><span class="line">dpkg --list</span><br><span class="line"><span class="built_in">sudo</span> apt-get remove –-purge 要卸载的软件的名字 <span class="comment">#卸载软件同时删除配置文件</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get remove 要卸载的软件的名字  <span class="comment">#卸载该软件</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get clean <span class="comment"># apt缓存删除</span></span><br></pre></td></tr></table></figure><h2><span id="时区">时区</span></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timedatectl status # 查看当前时间状态</span><br><span class="line">timedatectl set-timezone &quot;Asia/Shanghai&quot; # 修改时区为上海时间</span><br></pre></td></tr></table></figure><h2><span id="tmux">Tmux</span></h2><p>Tmux是一个非常方便的session管理以及session工具, 教程参见<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">Tmux使用教程（阮一峰）</a></p><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/tmux-help.png" alt="Tmux快捷键指南"><figcaption aria-hidden="true">Tmux快捷键指南</figcaption></figure>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正向代理和反向代理的区分</title>
      <link href="/2021/07/24/backend/zheng-xiang-dai-li-he-fan-xiang-dai-li-de-qu-fen/"/>
      <url>/2021/07/24/backend/zheng-xiang-dai-li-he-fan-xiang-dai-li-de-qu-fen/</url>
      
        <content type="html"><![CDATA[<p>最近在学习的过程中，对正向代理和反向代理的区别纠结了好久，总是感觉有点相似，又有些微妙的差别，但是又说不上到底如何理解，终于找到了一篇讲得比较清晰好理解的博文，适合我这种新手小白，记录一下，原文原载于<a href="https://cloud.tencent.com/developer/article/1418457">终于有人把正向代理和反向代理解释的明明白白了！- 云+社区 - 腾讯云(tencent.com)</a>，原文图文并茂，生动形象，本文由于版权原因，没有了图片，权当个人笔记，如有兴趣，可以直接去看一看原文。</p><span id="more"></span><p><strong>正向代理</strong></p><p>正向代理（forwardproxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p><p>这种代理其实在生活中是比较常见的，比如访问外国网站技术，其用到的就是代理技术。</p><p>有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</p><p>这个过程其实和租房子很像。</p><p>租房子的时候，一般情况下，我们很难联系到房东，因为有些房东为了图方便，只把自己的房屋信息和钥匙交给中介了。而房客想要租房子，只能通过中介才能联系到房东。而对于房东来说，他可能根本不知道真正要租他的房子的人是谁，他只知道是中介在联系他。</p><p>这里面一共有三个角色，租客（用户）、中介（代理服务器）和房东（国外网站，目标服务器）。引入中介（代理服务器）的原因是用户无法联系上房东（用户无法访问国外网站）。</p><p><strong>所以，正向代理，其实是"代理服务器"代理了"客户端"，去和"目标服务器"进行交互。</strong></p><p>通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理（有时候中介也直接冒充租客）。</p><h3><span id="正向代理的用途"><strong>正向代理的用途</strong></span></h3><p><strong>突破访问限制</strong></p><p>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</p><p>即，租客可以通过中介，来解决无法联系上房东的问题。</p><p><strong>提高访问速度</strong></p><p>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时，则直接由缓冲区中取出信息，传给用户，以提高访问速度。</p><p>即，中介手里留存了很多房源信息和钥匙，可以直接带租客去看房。</p><p><strong>隐藏客户端真实IP</strong></p><p>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p><p>即，房东并不知道租客的真实身份。PS：但是中介知道了，可能骚扰更多….</p><h3><span id="反向代理"><strong>反向代理</strong></span></h3><p>反向代理（reverseproxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>我们在租房子的过程中，除了有些房源需要通过中介以外，还有一些是可以直接通过房东来租的。用户直接找到房东租房的这种情况就是我们不使用代理直接访问国内的网站的情况。</p><p>还有一种情况，就是我们以为我们接触的是房东，其实有时候也有可能并非房主本人，有可能是他的亲戚、朋友，甚至是二房东。但是我们并不知道和我们沟通的并不是真正的房东。这种帮助真正的房主租房的二房东其实就是反向代理服务器。这个过程就是反向代理。</p><p>对于常用的场景，就是我们在Web开发中用到的<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>服务器（二房东），客户端（租客）发送请求到负载均衡服务器（二房东）上，负载均衡服务器（二房东）再把请求转发给一台真正的服务器（房东）来执行，再把执行结果返回给客户端（租客）。</p><p><strong>所以，反向代理，其实是"代理服务器"代理了"目标服务器"，去和"客户端"进行交互。</strong></p><p>通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。</p><h3><span id="反向代理的用途"><strong>反向代理的用途</strong></span></h3><p><strong>隐藏服务器真实IP</strong></p><p>使用反向代理，可以对客户端隐藏服务器的IP地址。</p><p>即，租客并不房东知道的真实身份。</p><p><strong>负载均衡</strong></p><p>反向代理服务器可以做负载均衡，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</p><p>即，二房东发现房主本人很忙，于是找到房主的妻子帮忙处理租房事宜。</p><p><strong>提高访问速度</strong></p><p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</p><p>即，二房东同样有房屋信息和钥匙。</p><p><strong>提供安全保障</strong></p><p>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</p><p>即，二房东可以有效的保护房东的安全。</p><h3><span id="正向代理和反向代理的区别"><strong>正向代理和反向代理的区别</strong></span></h3><p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p><p>1、<strong>正向代理其实是客户端的代理</strong>，帮助客户端访问其无法访问的服务器资源。<strong>反向代理则是服务器的代理</strong>，帮助服务器做负载均衡，安全防护等。</p><p>2、<strong>正向代理一般是客户端架设的</strong>，比如在自己的机器上安装一个代理软件。而<strong>反向代理一般是服务器架设的</strong>，比如在自己的机器集群中部署一个反向代理服务器。</p><p>3、<strong>正向代理中，服务器不知道真正的客户端到底是谁</strong>，以为访问自己的就是真实的客户端。而在<strong>反向代理中，客户端不知道真正的服务器是谁</strong>，以为自己访问的就是真实的服务器。</p><p>4、正向代理和反向代理的作用和目的不同。<strong>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL的个人使用笔记</title>
      <link href="/2021/07/23/backend/postgresql-de-ge-ren-shi-yong-bi-ji/"/>
      <url>/2021/07/23/backend/postgresql-de-ge-ren-shi-yong-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>作为一个数据库小白，PostgreSQL居然是我第一个使用的数据库而不是MySQL。有的时候有些操作难免忘记，就又要到网上去查询，这里就记录一下我忘记的那些一些用到过的SQL语句吧（虽然有些可能感觉挺蠢的orz。</p><span id="more"></span><h2><span id="添加和删除unique约束">添加和删除UNIQUE约束</span></h2><p>我们现在使用一下语句创建了一张表，用来记录app在某一天的使用情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> app_usage_info (</span><br><span class="line"><span class="keyword">day</span> <span class="type">date</span>,</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">usage_time <span class="type">interval</span>,</span><br><span class="line">usage_count <span class="type">integer</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然而，创建好之后我发现，我需要插入的数据在特定的一天中，一个app只能插入一组数据，所以我们需要添加UNIQUE约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> app_usage_info <span class="keyword">add</span> <span class="keyword">constraint</span> unique_app_one_day <span class="keyword">unique</span>(<span class="keyword">day</span>,app_name); </span><br></pre></td></tr></table></figure><p>想要删除这一个约束，我们可以使用一下语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> app_usage_info <span class="keyword">drop</span> <span class="keyword">constraint</span> unique_app_one_day;</span><br></pre></td></tr></table></figure><p>如果我们在建表的时候就添加约束，那么应该这样写</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> app_usage_info (</span><br><span class="line"><span class="keyword">day</span> <span class="type">date</span>,</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">usage_time <span class="type">interval</span>,</span><br><span class="line">usage_count <span class="type">integer</span>,</span><br><span class="line">    constaint unique_app_one_day <span class="keyword">unique</span>(<span class="keyword">day</span>,app_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2><span id="更新操作upsert">更新操作UPSERT</span></h2><p>UPSERT就是说当我们在INSERT的时候，发现与约束冲突，这个时候我们就可以对原有的数据进行更新而不是插入。例如我们对上面的表进行UPSERT，下面的SQL语句中excluded中的内容就是发生冲突的数据，我们使用这个数据对其进行更新即可。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> app_usage_info <span class="keyword">values</span> (<span class="string">&#x27;2021-07-16&#x27;</span>,<span class="string">&#x27;QQ&#x27;</span>,<span class="string">&#x27;com.tencent.mobileqq&#x27;</span>,<span class="string">&#x27;03:22:44&#x27;</span>,<span class="string">&#x27;20&#x27;</span>)</span><br><span class="line"><span class="keyword">on</span> conflict(<span class="keyword">day</span>,app_name) do <span class="keyword">update</span> </span><br><span class="line"><span class="keyword">set</span> &quot;usage_time&quot;<span class="operator">=</span>excluded.usage_time,&quot;usage_count&quot;<span class="operator">=</span>excluded.usage_count;</span><br></pre></td></tr></table></figure><h2><span id="删除某个字段">删除某个字段</span></h2><p>同样的，我们创建一个表，用来记录app的活动情况，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> DB_usage_events (</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">start_time timestamptz,</span><br><span class="line">end_time, timestamptz</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后，我们创建好之后发现我们可以不需要app_name这个字段，于是我们就可以用一下命令删去：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> DB_usage_events <span class="keyword">drop</span> <span class="keyword">column</span> if <span class="keyword">exists</span> app_name;</span><br></pre></td></tr></table></figure><h2><span id="设置postgresql时区">设置PostgreSQL时区</span></h2><p>在PostgreSQL中的日期/时间类型有时区之差，在使用中发现默认使用的是零时区，所以我们需要切换一下时区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="type">time</span> zone; <span class="comment">-- 显示当前时区</span></span><br><span class="line"><span class="keyword">select</span> form now(); <span class="comment">-- 显示当前时间</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> pg_timezone_names; <span class="comment">-- 查看支持的时区列表</span></span><br><span class="line"><span class="keyword">set</span> <span class="type">time</span> zone <span class="string">&#x27;PRC&#x27;</span>; <span class="comment">-- 设置成东八区 北京时间 UTC+8</span></span><br></pre></td></tr></table></figure><p>上述方法是session级设置，退出psql只有就不会再生效，我们可以使用用户级配置或者数据库级配置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用户级配置</span></span><br><span class="line"><span class="keyword">alter</span> role rolename <span class="keyword">set</span> timezone<span class="operator">=</span><span class="string">&#x27;PRC&#x27;</span>;</span><br><span class="line"><span class="keyword">alter</span> role <span class="keyword">all</span> <span class="keyword">set</span> timezone<span class="operator">=</span><span class="string">&#x27;PRC&#x27;</span>;</span><br><span class="line"><span class="comment">-- 数据库级配置</span></span><br><span class="line"><span class="keyword">alter</span> database dbname <span class="keyword">set</span> timezone<span class="operator">=</span><span class="string">&#x27;PRC&#x27;</span>;</span><br></pre></td></tr></table></figure><p>更加详细的PostgreSQL日期/时间/时区相关可以参考这篇博文<a href="https://blog.csdn.net/wangkai_123456/article/details/106333521">PostgreSQL时区、时间不一致、差8小时</a></p><h2><span id="schema-刷新-schemareloading">Schema 刷新 (SchemaReloading)</span></h2><p>在使用RESTfulAPI的时候，如果在数据库中创建了一个函数，那么要想在RESTfulAPI中使用这个函数，那么首先我们需要reloadSchema，使用以下命令可以在不中断PostgreSQLService服务的同时刷新Schema</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -SIGUSR1 postgrest</span><br></pre></td></tr></table></figure><p>参考<a href="https://postgrest.org/en/stable/admin.html#schema-reloading">HardeningPostgREST — PostgREST 7.0.1 documentation</a></p>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java日期与格式化：Date,Calendar,DateFormat和SimpleDateFormat类</title>
      <link href="/2021/07/22/java/java-ri-qi-ge-shi-hua-dateformat-lei-he-simpledateformat-lei/"/>
      <url>/2021/07/22/java/java-ri-qi-ge-shi-hua-dateformat-lei-he-simpledateformat-lei/</url>
      
        <content type="html"><![CDATA[<p>最近的一个项目中有着大量关于时间和日期的应用，从网上找到一篇教程记录一下，就当放进收藏夹里好了。</p><p><code>Date</code>和<code>Calendar</code>原载于<a href="http://c.biancheng.net/view/876.html">Java时间日期的处理：JavaDate类、Calendar类详解 (biancheng.net)</a></p><p><code>DateFormat</code>和<code>SimpleDateFormat</code>原载于<a href="http://c.biancheng.net/view/878.html">Java日期格式化（DateFormat类和SimpleDateFormat类）(biancheng.net)</a></p><span id="more"></span><p>在 <a href="http://c.biancheng.net/java/">Java</a>中获取当前时间，可以使用 java.util.Date 类和 java.util.Calendar类完成。其中，Date 类主要封装了系统的日期和时间的信息，Calendar类则会根据系统的日历来解释 Date对象。下面详细介绍这两个类的具体使用。</p><h2><span id="date-类">Date 类</span></h2><p>Date 类表示系统特定的时间戳，可以精确到毫秒。Date对象表示时间的默认顺序是星期、月、日、小时、分、秒、年。</p><h3><span id="构造方法">构造方法</span></h3><p>Date 类有如下两个构造方法。</p><ul><li>Date()：此种形式表示分配 Date对象并初始化此对象，以表示分配它的时间（精确到毫秒），使用该构造方法创建的对象可以获取本地的当前时间。</li><li>Date(long date)：此种形式表示从 GMT 时间（格林尼治时间）1970 年 1 月1 日 0 时 0 分 0 秒开始经过参数 date 指定的毫秒数。</li></ul><p>这两个构造方法的使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();    <span class="comment">// 调用无参数构造函数</span></span><br><span class="line">System.out.println(date1.toString());    <span class="comment">// 输出：Wed May 18 21:24:40 CST 2016</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">60000</span>);    <span class="comment">// 调用含有一个long类型参数的构造函数</span></span><br><span class="line">System.out.println(date2);    <span class="comment">// 输出：Thu Jan 0108:01:00 CST 1970</span></span><br></pre></td></tr></table></figure><p>Date类的无参数构造方法获取的是系统当前的时间，显示的顺序为星期、月、日、小时、分、秒、年。</p><p>Date 类带 long 类型参数的构造方法获取的是距离 GMT指定毫秒数的时间，60000 毫秒是一分钟，而 GMT（格林尼治标准时间）与CST（中央标准时间）相差 8 小时，也就是说 1970 年 1 月 1 日 00:00:00 GMT与 1970 年 1 月 1 日 08:00:00 CST 表示的是同一时间。 因此距离 1970 年 1月 1 日 00:00:00 CST 一分钟的时间为 1970 年 1 月 1 日 00:01:00CST，即使用 Date 对象表示为 Thu Jan 01 08:01:00 CST 1970。</p><h3><span id="常用方法">常用方法</span></h3><p>Date 类提供了许多与日期和事件相关的方法，其中常见的方法如表 1所示。</p><table><colgroup><col style="width: 35%"><col style="width: 64%"></colgroup><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean after(Date when)</code></td><td>判断此日期是否在指定日期之后</td></tr><tr><td><code>boolean before(Date when)</code></td><td>判断此日期是否在指定日期之前</td></tr><tr><td><code>int compareTo(Date anotherDate)</code></td><td>比较两个日期的顺序</td></tr><tr><td><code>boolean equals(Object obj)</code></td><td>比较两个日期的相等性</td></tr><tr><td><strong><code>long getTime()</code></strong></td><td>返回自 1970 年 1 月 1 日 00:00:00 GMT 以来，此 Date对象表示的毫秒数</td></tr><tr><td><code>String toString()</code></td><td>把此 Date 对象转换为以下形式的 String: dow mon dd hh:mm:ss zzzyyyy。 其中 dow 是一周中的某一天(Sun、Mon、Tue、Wed、Thu、Fri 及Sat)</td></tr></tbody></table><h3><span id="例-1">例 1</span></h3><p>下面使用一个实例来具体演示 Date类的使用。假设，某一天特定时间要去做一件事，而且那个时间已经过去一分钟之后才想起来这件事还没有办，这时系统将会提示已经过去了多长时间。具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test11</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要做的事情：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">title</span> <span class="operator">=</span> input.next();</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 获取当前日期</span></span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span> + title + <span class="string">&quot;] 这件事发生时间为：&quot;</span> + date1);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">60000</span>);<span class="comment">// 暂停 1 分钟</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;现在时间为：&quot;</span> + date2);</span><br><span class="line">        <span class="keyword">if</span> (date2.before(date1)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;你还有 &quot;</span> + (date2.getTime() - date1.getTime()) / <span class="number">1000</span> + <span class="string">&quot; 秒需要去完成【&quot;</span> + title + <span class="string">&quot;】这件事！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;【&quot;</span> + title + <span class="string">&quot;】事情已经过去了 &quot;</span> + (date2.getTime() - date1.getTime()) / <span class="number">1000</span> + <span class="string">&quot; 秒&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该程序中，分别使用 Date 类的无参数构造方法创建了两个 Date对象。在创建完第一个 Date 对象后，使用 Thread.sleep() 方法让程序休眠 60秒，然后再创建第二个 Date 对象，这样第二个 Date对象所表示的时间将会在第一个 Date对象所表示时间之后，因此“date2.before(date1)”条件表达式不成立，从而执行else 块中的代码，表示事情已经发生过。</p><p>运行该程序，执行结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入要做的事情：</span><br><span class="line">收快递</span><br><span class="line">【收快递】这件事发生时间为：Fri Oct 12 11:11:07 CST 2018</span><br><span class="line">现在时间为：Fri Oct 12 11:12:07 CST 2018</span><br><span class="line">【收快递】事情已经过去了 60 秒</span><br></pre></td></tr></table></figure><h2><span id="calendar-类">Calendar 类</span></h2><p>Calendar 类是一个抽象类，它为特定瞬间与YEAR、MONTH、DAY_OF—MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（如获得下星期的日期）提供了一些方法。</p><p>创建 Calendar 对象不能使用 new 关键字，因为 Calendar类是一个抽象类，但是它提供了一个<code>getInstance()</code>方法来获得Calendar类的对象。<code>getInstance()</code> 方法返回一个 Calendar对象，其日历字段已由当前日期和时间初始化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar c = Calendar.getInstance();</span><br></pre></td></tr></table></figure><p>当创建了一个 Calendar 对象后，就可以通过 Calendar对象中的一些方法来处理日期、时间。Calendar 类的常用方法如表 2 所示。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void add(int field, int amount)</code></td><td>根据日历的规则，为给定的日历字段 field 添加或减去指定的时间量amount</td></tr><tr><td><code>boolean after(Object when)</code></td><td>判断此 Calendar 表示的时间是否在指定时间 when之后，并返回判断结果</td></tr><tr><td><code>boolean before(Object when)</code></td><td>判断此 Calendar 表示的时间是否在指定时间 when之前，并返回判断结果</td></tr><tr><td><code>void clear()</code></td><td>清空 Calendar 中的日期时间值</td></tr><tr><td><code>int compareTo(Calendar anotherCalendar)</code></td><td>比较两个 Calendar 对象表示的时间值（从格林威治时间 1970 年 01 月 01日 00 时 00 分 00 秒至现在的毫秒偏移量），大则返回 1，小则返回-1，相等返回 0</td></tr><tr><td><code>int get(int field)</code></td><td>返回指定日历字段的值</td></tr><tr><td><code>int getActualMaximum(int field)</code></td><td>返回指定日历字段可能拥有的最大值</td></tr><tr><td><code>int getActualMinimum(int field)</code></td><td>返回指定日历字段可能拥有的最小值</td></tr><tr><td><code>int getFirstDayOfWeek()</code></td><td>获取一星期的第一天。根据不同的国家地区，返回不同的值</td></tr><tr><td><code>static Calendar getInstance()</code></td><td>使用默认时区和语言坏境获得一个日历</td></tr><tr><td><code>static Calendar getInstance(TimeZone zone)</code></td><td>使用指定时区和默认语言环境获得一个日历</td></tr><tr><td><strong><code>static Calendar getInstance(TimeZone zone, Locale aLocale)</code></strong></td><td>使用指定时区和语言环境获得一个日历</td></tr><tr><td><strong><code>Date getTime()</code></strong></td><td>返回一个表示此 Calendar 时间值（从格林威治时间 1970 年 01 月 01 日00 时 00 分 00 秒至现在的毫秒偏移量）的 Date 对象</td></tr><tr><td><strong><code>long getTimeInMillis()</code></strong></td><td>返回此 Calendar 的时间值，以毫秒为单位</td></tr><tr><td><code>void set(int field, int value)</code></td><td>为指定的日历字段设置给定值</td></tr><tr><td><code>void set(int year, int month, int date)</code></td><td>设置日历字段 YEAR、MONTH 和 DAY_OF_MONTH 的值</td></tr><tr><td><code>void set(int year, int month, int date, int hourOfDay, int minute, int second)</code></td><td>设置字段 YEAR、MONTH、DAY_OF_MONTH、HOUR、 MINUTE 和 SECOND的值</td></tr><tr><td><code>void setFirstDayOfWeek(int value)</code></td><td>设置一星期的第一天是哪一天</td></tr><tr><td><strong><code>void setTimeInMillis(long millis)</code></strong></td><td>用给定的 long 值设置此 Calendar 的当前时间值</td></tr></tbody></table><p>Calendar 对象可以调用 set() 方法将日历翻到任何一个时间，当参数 year取负数时表示公元前。Calendar 对象调用 get()方法可以获取有关年、月、日等时间信息，参数 field 的有效值由 Calendar静态常量指定。</p><p>Calendar 类中定义了许多常量，分别表示不同的意义。</p><ul><li><code>Calendar.YEAR</code>：年份。</li><li><code>Calendar.MONTH</code>：月份。</li><li><code>Calendar.DATE</code>：日期。</li><li><code>Calendar.DAY_OF_MONTH</code>：日期，和上面的字段意义完全相同。</li><li><code>Calendar.HOUR</code>：12小时制的小时。</li><li><code>Calendar.HOUR_OF_DAY</code>：24 小时制的小时。</li><li><code>Calendar.MINUTE</code>：分钟。</li><li><code>Calendar.SECOND</code>：秒。</li><li><code>Calendar.DAY_OF_WEEK</code>：星期几。</li></ul><p>例如，要获取当前月份可用如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int month = Calendar.getInstance().get(Calendar.MONTH);</span><br></pre></td></tr></table></figure><p>如果整型变量 month 的值是 0，表示当前日历是在 1 月份；如果值是11，则表示当前日历在 12 月份。</p><p>使用 Calendar 类处理日期时间的实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance(); <span class="comment">// 如果不设置时间，则默认为当前时间</span></span><br><span class="line">calendar.setTime(<span class="keyword">new</span> <span class="title class_">Date</span>()); <span class="comment">// 将系统当前时间赋值给 Calendar 对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;现在时刻：&quot;</span> + calendar.getTime()); <span class="comment">// 获取当前时间</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> calendar.get(Calendar.YEAR); <span class="comment">// 获取当前年份</span></span><br><span class="line">System.out.println(<span class="string">&quot;现在是&quot;</span> + year + <span class="string">&quot;年&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> calendar.get(Calendar.MONTH) + <span class="number">1</span>; <span class="comment">// 获取当前月份（月份从 0 开始，所以加 1）</span></span><br><span class="line">System.out.print(month + <span class="string">&quot;月&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> calendar.get(Calendar.DATE); <span class="comment">// 获取日</span></span><br><span class="line">System.out.print(day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">week</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>; <span class="comment">// 获取今天星期几（以星期日为第一天）</span></span><br><span class="line">System.out.print(<span class="string">&quot;星期&quot;</span> + week);</span><br><span class="line"><span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> calendar.get(Calendar.HOUR_OF_DAY); <span class="comment">// 获取当前小时数（24 小时制）</span></span><br><span class="line">System.out.print(hour + <span class="string">&quot;时&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> calendar.get(Calendar.MINUTE); <span class="comment">// 获取当前分钟</span></span><br><span class="line">System.out.print(minute + <span class="string">&quot;分&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> calendar.get(Calendar.SECOND); <span class="comment">// 获取当前秒数</span></span><br><span class="line">System.out.print(second + <span class="string">&quot;秒&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">millisecond</span> <span class="operator">=</span> calendar.get(Calendar.MILLISECOND); <span class="comment">// 获取毫秒数</span></span><br><span class="line">System.out.print(millisecond + <span class="string">&quot;毫秒&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfMonth</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH); <span class="comment">// 获取今天是本月第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是本月的第 &quot;</span> + dayOfMonth + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">dayOfWeekInMonth</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH); <span class="comment">// 获取今天是本月第几周</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是本月第 &quot;</span> + dayOfWeekInMonth + <span class="string">&quot; 周&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">many</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_YEAR); <span class="comment">// 获取今天是今年第几天</span></span><br><span class="line">System.out.println(<span class="string">&quot;今天是今年第 &quot;</span> + many + <span class="string">&quot; 天&quot;</span>);</span><br><span class="line"><span class="type">Calendar</span> <span class="variable">c</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">c.set(<span class="number">2012</span>, <span class="number">8</span>, <span class="number">8</span>); <span class="comment">// 设置年月日，时分秒将默认采用当前值</span></span><br><span class="line">System.out.println(<span class="string">&quot;设置日期为 2012-8-8 后的时间：&quot;</span> + c.getTime()); <span class="comment">// 输出时间</span></span><br></pre></td></tr></table></figure><p>上面的示例代码演示了 Calendar类中的方法与常量的结合使用，从而完成处理日期的操作。 ### 例 2</p><p>下面使用 Calendar 类来实现日历的打印功能，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalendarDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">        calendar.set(<span class="number">2016</span>, <span class="number">5</span>, <span class="number">1</span>); <span class="comment">// 实际的calendar对象所表示的日期为2016年6月1日</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断2016年6月1日为一周中的第几天</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_WEEK) - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span>[] title = &#123; <span class="string">&#x27;日&#x27;</span>, <span class="string">&#x27;一&#x27;</span>, <span class="string">&#x27;二&#x27;</span>, <span class="string">&#x27;三&#x27;</span>, <span class="string">&#x27;四&#x27;</span>, <span class="string">&#x27;五&#x27;</span>, <span class="string">&#x27;六&#x27;</span> &#125;; <span class="comment">// 存放日历的头部</span></span><br><span class="line">        <span class="type">int</span> daysArray[][] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>][<span class="number">7</span>];<span class="comment">// 存放日历的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">daysInMonth</span> <span class="operator">=</span> <span class="number">31</span>; <span class="comment">// 该月的天数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 自动增长</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充第一周的日期数据，即日历中的第一行</span></span><br><span class="line">            daysArray[<span class="number">0</span>][i] = day++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充其他周的日历数据，控制行</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果当前day表示的是本月最后一天，则停止向数组中继续赋值</span></span><br><span class="line">                <span class="keyword">if</span> (day &gt; daysInMonth) &#123;</span><br><span class="line">                    i = <span class="number">6</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                daysArray[i][j] = day++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------------2016 年 6 月--------------------\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; title.length; i++) &#123;</span><br><span class="line">            System.out.print(title[i] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 输出二元数组daysArray中的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (daysArray[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果到月末，则完成显示日历的任务，停止该方法的执行</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.print(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.print(daysArray[i][j] + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序看似复杂其实很简单。因为 Calendar 类所表示的时间月份是 set()方法中表示月份的参数值 +1，因此 Calendar 类的实际时间为 2016 年 6 月 1日。在下面的代码中分别获取 6 月 1日为本周中的第几天，以便在相应的星期下开始输出 6 月份的日历。程序中的<code>daysArray</code>是一个二元数组，该二元数组控制了日历的格式输出，第一个子数组控制日历的行，第二个子数组控制曰历的列，即可输出二元数组中的每一个元素。</p><p>运行程序，执行结果如下所示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">------------------2016 年 6 月--------------------</span><br><span class="line"></span><br><span class="line">日 一 二 三 四 五 六</span><br><span class="line">   1 2 3 4</span><br><span class="line">5 6 7 8 9 10 11</span><br><span class="line">12 13 14 15 16 17 18</span><br><span class="line">19 20 21 22 23 24 25</span><br><span class="line">26 27 28 29 30 31 </span><br></pre></td></tr></table></figure><p>日期格式化：格式化日期表示将日期/时间格式转换为预先定义的日期/时间格式。例如将日期“FriMay 18 15:46:24 CST2016” 格式转换为 “2016-5-18 15:46:24星期五”的格式。</p><p>在 <a href="http://c.biancheng.net/java/">Java</a> 中，可以使用<code>DateFormat</code> 类和<code>SimpleDateFormat</code>类来格式化日期，下面详细介绍这两个格式化日期类的使用。</p><h2><span id="dateformat-类">DateFormat 类</span></h2><p><code>DateFormat</code>是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如<code>SimpleDateFormat</code>）允许进行格式化（也就是日期→文本）、解析（文本→日期）和标准化日期。</p><p>在创建<code>DateFormat</code> 对象时不能使用 new 关键字，而应该使用<code>DateFormat</code> 类中的静态方法<code>getDateInstance()</code>，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateFormat</span> <span class="variable">df</span> <span class="operator">=</span> DateFormat.getDatelnstance();</span><br></pre></td></tr></table></figure><p>在创建了一个 <code>DateFormat</code>对象后，可以调用该对象中的方法来对日期/时间进行格式化。<code>DateFormat</code>类中常用方法如表 1 所示。</p><table><colgroup><col style="width: 50%"><col style="width: 50%"></colgroup><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>String format(Date date)</code></td><td>将 Date 格式化日期/时间字符串</td></tr><tr><td><code>Calendar getCalendar()</code></td><td>获取与此日期/时间格式相关联的日历</td></tr><tr><td><code>static DateFormat getDateInstance()</code></td><td>获取具有默认格式化风格和默认语言环境的<strong>日期</strong>格式</td></tr><tr><td><code>static DateFormat getDateInstance(int style)</code></td><td>获取具有指定格式化风格和默认语言环境的<strong>日期</strong>格式</td></tr><tr><td><strong><code>static DateFormat getDateInstance(int style, Locale locale)</code></strong></td><td>获取具有指定格式化风格和指定语言环境的<strong>日期</strong>格式</td></tr><tr><td><code>static DateFormat getDateTimeInstance()</code></td><td>获取具有默认格式化风格和默认语言环境的<strong>日期/时间</strong>格式</td></tr><tr><td><code>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle)</code></td><td>获取具有指定日期/时间格式化风格和默认语言环境的<strong>日期/时间</strong>格式</td></tr><tr><td><strong><code>static DateFormat getDateTimeInstance(int dateStyle,int timeStyle,Locale locale)</code></strong></td><td>获取具有指定日期/时间格式化风格和指定语言环境的<strong>日期/时间</strong>格式</td></tr><tr><td><code>static DateFormat getTimeInstance()</code></td><td>获取具有默认格式化风格和默认语言环境的<strong>时间</strong>格式</td></tr><tr><td><code>static DateFormat getTimeInstance(int style)</code></td><td>获取具有指定格式化风格和默认语言环境的<strong>时间</strong>格式</td></tr><tr><td><strong><code>static DateFormat getTimeInstance(int style, Locale locale)</code></strong></td><td>获取具有指定格式化风格和指定语言环境的<strong>时间</strong>格式</td></tr><tr><td><code>void setCalendar(Calendar newCalendar)</code></td><td>为此格式设置日历</td></tr><tr><td><code>Date parse(String source)</code></td><td>将给定的字符串解析成日期/时间</td></tr></tbody></table><p>格式化样式(<code>dateStyle</code>)主要通过 <code>DateFormat</code>常量设置。将不同的常量传入到表 1所示的方法中，以控制结果的长度。<code>DateFormat</code>类的常量如下。</p><ul><li>SHORT：完全为数字，如 12.5.10 或 5:30pm。</li><li><strong>MEDIUM：较长，如 May 10，2016。</strong><mark>个人感觉用的比较多</mark></li><li>LONG：更长，如 May 12，2016 或 11:15:32am。</li><li>FULL：是完全指定，如 Tuesday、May 10、2012 AD 或 11:15:42amCST。</li></ul><p>使用 <code>DateFormat</code> 类格式化曰期/时间的示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的日期</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df1</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df2</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df3</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df4</span> <span class="operator">=</span> DateFormat.getDateInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取不同格式化风格和中国环境的时间</span></span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df5</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.SHORT, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df6</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.FULL, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df7</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.MEDIUM, Locale.CHINA);</span><br><span class="line"><span class="type">DateFormat</span> <span class="variable">df8</span> <span class="operator">=</span> DateFormat.getTimeInstance(DateFormat.LONG, Locale.CHINA);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将不同格式化风格的日期格式化为日期字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">date1</span> <span class="operator">=</span> df1.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">date2</span> <span class="operator">=</span> df2.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">date3</span> <span class="operator">=</span> df3.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">date4</span> <span class="operator">=</span> df4.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将不同格式化风格的时间格式化为时间字符串</span></span><br><span class="line"><span class="type">String</span> <span class="variable">time1</span> <span class="operator">=</span> df5.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">time2</span> <span class="operator">=</span> df6.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">time3</span> <span class="operator">=</span> df7.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"><span class="type">String</span> <span class="variable">time4</span> <span class="operator">=</span> df8.format(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出日期</span></span><br><span class="line">System.out.println(<span class="string">&quot;SHORT：&quot;</span> + date1 + <span class="string">&quot; &quot;</span> + time1);</span><br><span class="line">System.out.println(<span class="string">&quot;FULL：&quot;</span> + date2 + <span class="string">&quot; &quot;</span> + time2);</span><br><span class="line">System.out.println(<span class="string">&quot;MEDIUM：&quot;</span> + date3 + <span class="string">&quot; &quot;</span> + time3);</span><br><span class="line">System.out.println(<span class="string">&quot;LONG：&quot;</span> + date4 + <span class="string">&quot; &quot;</span> + time4);</span><br></pre></td></tr></table></figure><p>运行该段代码，输出的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHORT：18-10-15 上午9:30</span><br><span class="line">FULL：2018年10月15日 星期一 上午09时30分43秒 CST</span><br><span class="line">MEDIUM：2018-10-15 9:30:43</span><br><span class="line">LONG：2018年10月15日 上午09时30分43秒</span><br></pre></td></tr></table></figure><p>该示例主要介绍了 <code>DateFormat</code>类中方法与常量的结合使用，通过使用<code>DateFomat</code>类可以对日期进行不同风格的格式化。</p><h2><span id="simpledateformat-类">SimpleDateFormat 类</span></h2><p>如果使用 <code>DateFormat</code>类格式化日期/时间并不能满足要求，那么就需要使用 <code>DateFormat</code>类的子类——<code>SimpleDateFormat</code>。</p><p><code>SimpleDateFormat</code>是一个以与语言环境有关的方式来格式化和解析日期的具体类，它允许进行格式化（日期→文本）、解析（文本→日期）和规范化。<code>SimpleDateFormat</code>使得可以选择任何用户定义的日期/时间格式的模式。</p><p><code>SimpleDateFormat</code> 类主要有如下 3 种构造方法。</p><ul><li><code>SimpleDateFormat()</code>：用默认的格式和默认的语言环境构造<code>SimpleDateFormat</code>。</li><li><code>SimpleDateFormat(String pattern)</code>：用指定的格式和默认的语言环境构造<code>SimpleDateFormat</code>。</li><li><code>SimpleDateFormat(String pattern,Locale locale)</code>：用指定的格式和指定的语言环境构造<code>SimpleDateFormat</code>。</li></ul><p><code>SimpleDateFormat</code> 自定义格式中常用的字母及含义如表 2所示。</p><table><colgroup><col style="width: 3%"><col style="width: 48%"><col style="width: 48%"></colgroup><thead><tr><th>字母</th><th>含义</th><th>示例</th></tr></thead><tbody><tr><td>y</td><td>年份。一般用 yy 表示两位年份，yyyy 表示 4 位年份</td><td>使用 yy 表示的年扮，如 11； 使用 yyyy 表示的年份，如 2011</td></tr><tr><td>M</td><td>月份。一般用 MM 表示月份，如果使用 MMM，则会根据语言环境显示不同语言的月份</td><td>使用 MM 表示的月份，如 05； 使用 MMM 表示月份，在 Locale.CHINA语言环境下，如“十月”；在 Locale.US 语言环境下，如 Oct</td></tr><tr><td>d</td><td>月份中的天数。一般用 dd 表示天数</td><td>使用 dd 表示的天数，如 10</td></tr><tr><td>D</td><td>年份中的天数。表示当天是当年的第几天， 用 D 表示</td><td>使用 D 表示的年份中的天数，如 295</td></tr><tr><td>E</td><td>星期几。用 E 表示，会根据语言环境的不同， 显示不 同语言的星期几</td><td>使用 E 表示星期几，在 Locale.CHINA 语 言环境下，如“星期四”；在Locale.US 语 言环境下，如 Thu</td></tr><tr><td>H</td><td>一天中的小时数（0~23)。一般用 HH 表示小时数</td><td>使用 HH 表示的小时数，如 18</td></tr><tr><td>h</td><td>一天中的小时数（1~12)。一般使用 hh 表示小时数</td><td>使用 hh 表示的小时数，如 10 (注意 10 有 可能是 10 点，也可能是 22点）</td></tr><tr><td>m</td><td>分钟数。一般使用 mm 表示分钟数</td><td>使用 mm 表示的分钟数，如 29</td></tr><tr><td>s</td><td>秒数。一般使用 ss 表示秒数</td><td>使用 ss 表示的秒数，如 38</td></tr><tr><td>S</td><td>毫秒数。一般使用 SSS 表示毫秒数</td><td>使用 SSS 表示的毫秒数，如 156</td></tr></tbody></table><h3><span id="例-1">例 1</span></h3><p>编写 Java 程序，使用 <code>SimpleDateFormat</code>类格式化当前日期并打印，日期格式为“xxxx 年 xx 月 xx 日星期 xxx 点 xx 分xx 秒”，具体的实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test13</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 创建一个Date对象，获取当前时间</span></span><br><span class="line">        <span class="comment">// 指定格式化格式</span></span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今天是 &quot;</span> + <span class="string">&quot;yyyy 年 MM 月 dd 日 E HH 点 mm 分 ss 秒&quot;</span>);</span><br><span class="line">        System.out.println(f.format(now)); <span class="comment">// 将当前时间袼式化为指定的格式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天是 2018 年 10 月 15 日 星期一 09 点 26 分 23 秒</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android PackageManager 使用简单记录</title>
      <link href="/2021/07/22/android/android-packagemanager-shi-yong-jian-dan-ji-lu/"/>
      <url>/2021/07/22/android/android-packagemanager-shi-yong-jian-dan-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>Android为我们提供了一个能够获取Package的信息的类<code>PackageManager</code>，从中我们可以通过包名获取到例如App名称，桌面图标等应用信息。简单记录一下如何使用PackageManager获取对应的信息吧。</p><span id="more"></span><h4><span id="获取app-name">获取App Name</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getApplicationNameByPackageName</span><span class="params">(Context context, String packageName)</span> &#123;</span><br><span class="line">    <span class="type">PackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> context.getPackageManager();</span><br><span class="line">    String Name;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Name = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA)).toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        Name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="获取桌面图标">获取桌面图标</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Drawable <span class="title function_">getAppIconByPacakgeName</span><span class="params">(Context context, String packageName)</span> &#123;</span><br><span class="line">    <span class="type">PackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> context.getPackageManager();</span><br><span class="line">    Drawable icon;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        icon = pm.getApplicationIcon(packageName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        icon = ContextCompat.getDrawable(context, R.mipmap.ic_launcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> icon;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java获取当天开始结束时间</title>
      <link href="/2021/07/22/java/java-huo-qu-dang-tian-kai-shi-jie-shu-shi-jian/"/>
      <url>/2021/07/22/java/java-huo-qu-dang-tian-kai-shi-jie-shu-shi-jian/</url>
      
        <content type="html"><![CDATA[<p>记录一下给定一个时间戳，Java获取这一天开始和结束时间的方法，主要还是没有系统的学习过Java时间相关的类和使用方法</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取指定某一天的开始时间戳</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeStamp 毫秒级时间戳</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeZone  如 GMT+8:00</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getDailyStartTime</span><span class="params">(Long timeStamp, String timeZone)</span> &#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    calendar.setTimeZone(TimeZone.getTimeZone(timeZone));</span><br><span class="line">    calendar.setTimeInMillis(timeStamp);</span><br><span class="line">    calendar.set(Calendar.HOUR_OF_DAY, <span class="number">0</span>);</span><br><span class="line">    calendar.set(Calendar.SECOND, <span class="number">0</span>);</span><br><span class="line">    calendar.set(Calendar.MINUTE, <span class="number">0</span>);</span><br><span class="line">    calendar.set(Calendar.MILLISECOND, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> calendar.getTimeInMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 获取指定某一天的结束时间戳</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeStamp 毫秒级时间戳</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> timeZone  如 GMT+8:00</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">getDailyEndTime</span><span class="params">(Long timeStamp, String timeZone)</span> &#123;</span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    calendar.setTimeZone(TimeZone.getTimeZone(timeZone));</span><br><span class="line">    calendar.setTimeInMillis(timeStamp);</span><br><span class="line">    calendar.set(Calendar.HOUR_OF_DAY, <span class="number">23</span>);</span><br><span class="line">    calendar.set(Calendar.MINUTE, <span class="number">59</span>);</span><br><span class="line">    calendar.set(Calendar.SECOND, <span class="number">59</span>);</span><br><span class="line">    calendar.set(Calendar.MILLISECOND, <span class="number">999</span>);</span><br><span class="line">    <span class="keyword">return</span> calendar.getTimeInMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于<code>TimeZone</code>的用法可以参考<a href="https://www.jb51.net/article/85930.htm#:~:text=TimeZone可以用来获取或者规定时区%2C也可以用来计算时差%2C这里我们就来详解Java中的时区类TimeZone的用法%2C特别要注意下面所提到的TimeZone相关的时间校准问题.%20TimeZone%20表示时区偏移量，也可以计算夏令时。%20在操作%20Date%2C%20Calendar等表示日期%2F时间的对象时，经常会用到TimeZone；因为不同的时区，时间不同。%20下面说说TimeZone对象的,2种常用创建方式。%20关于%20getTimeZone%20(String%20id)%20这种方式支持的全部id参数的取值，可以通过以下方式查找：%20例如，创建上面第2个打印值%22Etc%2FGMT%2B11%22对应的TimeZone。%20方法如下：">详解Java中的时区类TimeZone的用法_java_脚本之家(jb51.net)</a>，获取默认<code>TimeZone</code>可以使用<code>TimeZone.getDefault().getID()</code>。</p><p>原文来自于<a href="https://www.cnblogs.com/lingyejun/p/11298186.html">Java获取当天、当前月、当前年(今年)的开始和结束时间戳- 翎野 - 博客园</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>138. 复制带随机指针的链表</title>
      <link href="/2021/07/22/leetcode/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/"/>
      <url>/2021/07/22/leetcode/138-fu-zhi-dai-sui-ji-zhi-zhen-de-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random，该指针可以指向链表中的任何节点或空节点。</p><p>构造这个链表的 深拷贝。 深拷贝应该正好由 n 个 全新节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 next指针和 random指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。复制链表中的指针都不应指向原链表中的节点。</p><p>例如，如果原链表中有 X 和 Y 两个节点，其中 <code>X.random→Y</code>。那么在复制链表中对应的两个节点 x 和 y ，同样有 <code>x.random→y</code>。</p><p>返回复制链表的头节点。</p><span id="more"></span><p>用一个由 n 个节点组成的链表来表示输入/输出中的链表。每个节点用一个[val, random_index] 表示：</p><p><code>val</code>：一个表示 <code>Node.val</code>的整数。random_index：随机指针指向的节点索引（范围从 0 到n-1）；如果不指向任何节点，则为 null 。 你的代码 只 接受原链表的头节点head 作为传入参数。</p><p>示例 1：</p><figure><img src="https://i.loli.net/2021/07/22/PuImxiYAStbcj3O.png" alt="138_example1"><figcaption aria-hidden="true">138_example1</figcaption></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br><span class="line">&gt;输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">// Definition for a Node.</span></span><br><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">   <span class="type">int</span> val;</span><br><span class="line">   Node next;</span><br><span class="line">   Node random;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.val = val;</span><br><span class="line">          <span class="built_in">this</span>.next = <span class="literal">null</span>;</span><br><span class="line">          <span class="built_in">this</span>.random = <span class="literal">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure></blockquote><h2><span id="题解">题解</span></h2><p>看到这道题第一个反应就是这个链表不是一个普通的链表，本质上它可以转化为有向图，所以这道题本质可以说是图的深拷贝。下面这张图就是我们将这个链表转化为一张图之后的样子。</p><figure><img src="https://i.loli.net/2021/07/22/PBhuRnt3eiOqKAN.png" alt="138_diagram"><figcaption aria-hidden="true">138_diagram</figcaption></figure><p>所以，由此我们可以采取类似BFS的思路对这个链表进行深拷贝。当遍历到一个节点的时候，我们可以对当前节点的下一个节点和随机节点分别进行拷贝。为了保证一个不会重复拷贝已经拷贝过的节点，我们可以使用哈希表对节点的拷贝情况进行记录。以下是代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node,Node&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(head)) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(head.val);</span><br><span class="line">            map.put(head, newHead);</span><br><span class="line">            newHead.next = copyRandomList(head.next);</span><br><span class="line">            newHead.random = copyRandomList(head.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种思路是在评论区里看到的，感觉也非常的容易理解，也记录一下。思路非常清晰，首先遍历一遍链表，拷贝每个节点的值到新节点中，并且放入哈希表中记录，但是并拷贝节点的两个指针。然后第二次遍历，这个时候，我们新创建的每个指针的节点都储存在哈希表中了，我们就直接可以用<code>next</code>和<code>random</code>指针直接指向了。总体的思路就是，先创建单个节点，再将他们连接起来。下面是代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Map&lt;Node,Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node,Node&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next) &#123;</span><br><span class="line">            map.put(node, <span class="keyword">new</span> <span class="title class_">Node</span>(node.val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head; node != <span class="literal">null</span>; node = node.next) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> map.get(node);</span><br><span class="line">            newNode.next = map.get(node.next);</span><br><span class="line">            newNode.random = map.get(node.random);</span><br><span class="line">            map.put(node, newNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="附">附</span></h2><p>注意到第一种解法的代码中，我们首先将<code>newNode</code>加入到哈希表中，之后再改变它的两个指针，由此可以判断出我们加入哈希表中的Object实际上应该是一个引用，所以我们改变原本的值就会直接影响到哈希表中存储的值，写了以下代码进行验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">            Node next;</span><br><span class="line">            <span class="type">int</span> val;</span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.val = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="number">2</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line">        node2.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node1.val);</span><br><span class="line">        map.put(node1, newNode);</span><br><span class="line">        newNode.val = <span class="number">4</span>;</span><br><span class="line">        newNode.next = node2;</span><br><span class="line">        System.out.println(map.get(node1).val);</span><br><span class="line">        System.out.println(map.get(node1).next.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 输出：</span></span><br><span class="line"><span class="comment">* 4</span></span><br><span class="line"><span class="comment">* 2</span></span><br><span class="line"><span class="comment">/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指 Offer 52. 两个链表的第一个公共节点</title>
      <link href="/2021/07/21/leetcode/jian-zhi-offer-52-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian/"/>
      <url>/2021/07/21/leetcode/jian-zhi-offer-52-liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>比较经典的简单题目，稍微记录一下思路</p><blockquote><p>输入两个链表，找出它们的第一个公共节点。</p><p>如下面的两个链表：</p><figure><img src="https://i.loli.net/2021/07/21/uiplfmB3PqCkht6.png" alt="160_statement"><figcaption aria-hidden="true">160_statement</figcaption></figure><p>在节点 c1 开始相交。</p><span id="more"></span><p>示例 1：</p><figure><img src="https://i.loli.net/2021/07/21/PdIR6xC4V7Uhp3o.png" alt="160_example_1"><figcaption aria-hidden="true">160_example_1</figcaption></figure><p>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5],skipA = 2, skipB = 3 输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为[5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3个节点。</p><p>示例 2：</p><figure><img src="https://i.loli.net/2021/07/21/3ZU2Afnc5eNs9rk.png" alt="160_example_2"><figcaption aria-hidden="true">160_example_2</figcaption></figure><p>输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA =3, skipB = 1 输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。</p><p>示例 3：</p><figure><img src="https://i.loli.net/2021/07/21/GTQD9AjXB2nJzyh.png" alt="160_example_3"><figcaption aria-hidden="true">160_example_3</figcaption></figure><p>输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3,skipB = 2 输出：null 输入解释：从各自的表头开始算起，链表 A 为[2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为0，而 skipA 和 skipB 可以是任意值。 解释：这两个链表不相交，因此返回null。</p></blockquote><h2><span id="题解">题解</span></h2><p>这道题采用双指针的思想就可以轻松解决。我们注意到，无论指针从哪个端点出发，遍历两个链表一共走的步数是一样的，并且他们去除他们的公共部分，也就是说如果两个指针分别从A和B的头出发的话，最后他们一定会同时到达第一个相交的公共节点。并且，如果说这两个链表没有公共节点，那么他们最后一定会同时到达两个链表的末尾，也就是<code>null</code>。思路出来了，代码也就很容易了，时间复杂度<strong>O(N)</strong>，空间复杂度<strong>O(1)</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeA</span> <span class="operator">=</span> headA, nodeB = headB;</span><br><span class="line">        <span class="keyword">if</span> (nodeA == <span class="literal">null</span> || nodeB == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (nodeA != nodeB) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nodeA == <span class="literal">null</span>) nodeA = headB;</span><br><span class="line">            <span class="keyword">else</span> nodeA = nodeA.next;</span><br><span class="line">            <span class="keyword">if</span> (nodeB == <span class="literal">null</span>) nodeB = headA;</span><br><span class="line">            <span class="keyword">else</span> nodeB = nodeB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Java </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NexT主题配置记录</title>
      <link href="/2021/07/18/other/next-zhu-ti-pei-zhi-ji-lu/"/>
      <url>/2021/07/18/other/next-zhu-ti-pei-zhi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>原来折腾了很久的Yilia主题，然而搞了半天终于还是来到了NexT的怀抱，NexT提供的功能相比于Yilia确实多了不少，这篇就作为一个记录，稍微记载下NexT中的一些配置吧。</p><hr><p>2022.9.10 更新 以后打算就在这里记录一下对博客的更新情况<span id="more"></span></p><ul><li><label><input type="checkbox">英文版网页，英文行距字体等等</label></li><li>2024.9.18 更新作品集页面(AI真好用)</li><li>2024.2.15 修改默认字体</li><li>2023.12.24添加twentytwenty图片对比插件，但是仍有很多问题有待解决</li><li>2022.12.5添加hexo-auto-category，自动根据文件夹目录设置categories</li><li>2022.9.11 中英文切换功能，中英文板块分离;</li><li>2022.9.10 增加Portfolio页面; 添加DarkMode以及切换功能;</li><li>2021.7.18 切换主题为Next主题并进行配置;</li></ul><h2><span id="修改默认字体">修改默认字体</span></h2><p>Next的配置项中可以直接对字体进行更改，相关配置如下 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Find fonts on Google Fonts (https://fonts.google.com)</span></span><br><span class="line"><span class="comment"># All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#   light | light italic | normal | normal italic | bold | bold italic</span></span><br><span class="line"><span class="comment"># Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Web Safe fonts are recommended for `global` (and `title`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="string">enable</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Inter</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Fira</span> <span class="string">Code</span></span><br></pre></td></tr></table></figure></p><p>现在直接统一调成了中文字体，但实际上还是有点想要中英文字体进行一下区分，参考<a href="https://bambrow.com/20200718-hexo-next-font-settings/">Hexo NexT主题的字体更换</a>，但是最后没有成功不知道为什么。</p><h2><span id="hexo图片对比插件">Hexo图片对比插件</span></h2><p>作为一个图形学选手，渲染的结果经常需要进行对比。jQuery的twentytwenty插件能够方便的提供双图以至四图的对比，所以我就试图寻找一个插件实现这个功能。<a href="https://github.com/tea3/hexo-tag-twentytwenty">hexo-tag-twentytwenty</a>刚好可以。但是这个插件还有一些问题，按照github上的描述从cdn中加载twentytwenty.js是可行的，但是似乎这个版本并不是很好，在cdn上也并没有找到一个更好的其他的版本。这个版本的问题在于，一无法居中对齐，二无法设置<code>alt</code>参数。我在本地有一个我期望的twentytwenty版本，但是尝试各种方法之后，发现都很难通过本地路径嵌入到静态网页当中去，感觉肯定是有办法的，但是确实不是很熟悉。以后如果有空再尝试尝试吧。此外，这个插件太老了，而且现在的next没有了jquery，所以在他的基础上进行一些更改。代码如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;theme_inject&#x27;</span>, <span class="keyword">function</span> (<span class="params">injects</span>) &#123;</span><br><span class="line">  injects.<span class="property">postBodyEnd</span>.<span class="title function_">raw</span>(<span class="string">&#x27;jquery&#x27;</span>, <span class="string">&#x27;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js&quot;&gt;&lt;/script&gt;&#x27;</span>, &#123;&#125;, &#123; <span class="attr">cache</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  injects.<span class="property">postBodyEnd</span>.<span class="title function_">raw</span>(<span class="string">&#x27;jquerymove&#x27;</span>, <span class="string">&#x27;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mhayes-twentytwenty/1.0.0/js/jquery.event.move.min.js&quot;&gt;&lt;/script&gt;&#x27;</span>, &#123;&#125;, &#123; <span class="attr">cache</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  injects.<span class="property">postBodyEnd</span>.<span class="title function_">raw</span>(<span class="string">&#x27;twtwscript&#x27;</span>, <span class="string">&#x27;&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/mhayes-twentytwenty/1.0.0/js/jquery.twentytwenty.min.js&quot;&gt;&lt;/script&gt;&#x27;</span>, &#123;&#125;, &#123; <span class="attr">cache</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  injects.<span class="property">postBodyEnd</span>.<span class="title function_">raw</span>(<span class="string">&#x27;twtwcss&#x27;</span>, <span class="string">&#x27;&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdnjs.cloudflare.com/ajax/libs/mhayes-twentytwenty/1.0.0/css/twentytwenty.min.css&quot;/&gt;&#x27;</span>, &#123;&#125;, &#123; <span class="attr">cache</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  injects.<span class="property">postBodyEnd</span>.<span class="title function_">file</span>(<span class="string">&#x27;twtwscripts&#x27;</span>, <span class="string">&#x27;js/twtw.swig&#x27;</span>, &#123;&#125;, &#123; <span class="attr">cache</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">tag</span>.<span class="title function_">register</span>(<span class="string">&#x27;twtw&#x27;</span>, <span class="keyword">function</span>(<span class="params">args, content</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> beforeImg       = args[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">var</span> afterImg        = args[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">var</span> imgWidth        = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> maxWidth        = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">var</span> imgHeight       = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(args.<span class="property">length</span> &gt; <span class="number">2</span>)&#123;</span><br><span class="line">    imgWidth = <span class="string">&#x27; data-width=&quot;&#x27;</span> + args[<span class="number">2</span>] + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">    maxWidth = <span class="string">&#x27; style=&quot;max-width:&#x27;</span> + args[<span class="number">2</span>] + <span class="string">&#x27;px&quot;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(args.<span class="property">length</span> &gt; <span class="number">3</span>)&#123;</span><br><span class="line">    imgHeight = <span class="string">&#x27; data-height=&quot;&#x27;</span> + args[<span class="number">3</span>] + <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> returnHTML  = <span class="string">&#x27;&lt;div class=&quot;twentytwenty-container&quot;&#x27;</span> + maxWidth + <span class="string">&#x27;&gt;\n&#x27;</span></span><br><span class="line">            + <span class="string">&#x27;&lt;img src=&quot;&#x27;</span>+ beforeImg +<span class="string">&#x27;&quot;&#x27;</span> + imgWidth + imgHeight + <span class="string">&#x27;&gt;\n&#x27;</span></span><br><span class="line">            + <span class="string">&#x27;&lt;img src=&quot;&#x27;</span>+ afterImg +<span class="string">&#x27;&quot;&#x27;</span> + imgWidth + imgHeight + <span class="string">&#x27;&gt;\n&#x27;</span></span><br><span class="line">            + <span class="string">&#x27;&lt;/div&gt;&#x27;</span>;</span><br><span class="line">  <span class="keyword">return</span> returnHTML;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">async</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">ends</span>: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>并且在<code>styles.styl</code>中需要添加以下格式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-class">.twentytwenty-container</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.post-body</span> <span class="selector-class">.twentytwenty-container</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在根目录下添加<code>js/twtw.swig</code>，这个文件可以自行更改路径和名称没有什么规定。<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">  $(<span class="variable language_">document</span>).<span class="title function_">ready</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">initialize_twentytwenty</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  );</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">function</span> <span class="title function_">initialize_twentytwenty</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span>($(<span class="string">&quot;.twentytwenty-container&quot;</span>).<span class="property">twentytwenty</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">      $(<span class="string">&quot;.twentytwenty-container&quot;</span>).<span class="title function_">twentytwenty</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="built_in">setTimeout</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">initialize_twentytwenty</span>();</span></span><br><span class="line"><span class="language-javascript">      &#125;,<span class="number">250</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;)();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>其中第一行css就是尝试让图片居中，同时还需要为图片设置合适大小的width，才能正常居中，否则因为<code>twentytwenty-container</code>默认是fullwidth，会占据整个页面，而图片在右侧，只能暂时通过这种方式解决，更加合理的解决办法还有待研究。另外目前还有一个问题，似乎两边的图片有点色差，不知道是什么导致的问题……不过也只能先凑活着用着</p><h2><span id="hexo博客中英文板块以及切换">Hexo博客中英文板块以及切换</span></h2><p>由于一些原因准备给博客添加英文板块，主要想要实现的功能是中英文板块单独分离，用户在点击中英文切换的按钮后跳转到对应的页面。Next原本就支持双语切换，但是只有Menu等少部分元素的切换，并不是想要的效果。在网上找了很多相关的资料，最终决定还是使用最简单的办法：在github中创两个仓库，hexo_zh和hexo_en，分别作为中文博客和英文博客，并且在Menu上添加外链，点击可以进行跳转。</p><p>需要修改的地方主要有：</p><ol type="1"><li><p>en博客删除_post中不需要的中文博客</p></li><li><p>修改<code>_config.yml</code>的URL</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as &#x27;http://example.com/child&#x27; and root as &#x27;/child/&#x27;</span></span><br><span class="line"><span class="comment"># 这里是中英文对应的url，由于是subdirectory，所以需要按照以下写法</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://lucas-hao.github.io/hexo_en/</span></span><br><span class="line"><span class="attr">root:</span> <span class="string">/hexo_en/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"><span class="attr">pretty_urls:</span></span><br><span class="line">  <span class="attr">trailing_index:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;index.html&#x27; from permalinks</span></span><br><span class="line">  <span class="attr">trailing_html:</span> <span class="literal">true</span> <span class="comment"># Set to false to remove trailing &#x27;.html&#x27; from permalinks</span></span><br></pre></td></tr></table></figure></li><li><p>修改<code>_config.next.yml</code>（即主题配置文件，参见<a href="https://theme-next.js.org/docs/getting-started/configuration">Configuration| NexT(theme-next.js.org)</a>）的Menu，添加切换的外链。这里还有一些Bug没有解决，目前仍然存在的问题是点击切换按钮后只有内容板块切换到了中英文对应的post页面，但是其他包括左侧的边栏以及评论板块都没有刷新，也就是说因为en和zh在同一个root下，所以hexo默认为站内的切换而并非外链，有待寻找解决办法。<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">     <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">     <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">     <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">     <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">     <span class="attr">portfolio:</span> <span class="string">/portfolio/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">     <span class="string">中文:</span> <span class="string">https://lucas-hao.github.io/hexo_zh/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-language</span></span><br><span class="line">     <span class="comment">#archives: /archives/ || fa fa-archive</span></span><br><span class="line">     <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">     <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">     <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure></p></li><li><p>修改Deploy的git地址</p></li></ol><blockquote><p><strong>参考资料</strong> - <a href="https://youngforest.github.io/2021/09/07/Setup-English-blog/">Hexo创建中英文博客 | YoungForest's blog</a> - <a href="https://tstrs.me/1448.html?utm_source=blog_decay_fun">Hexo添加多语言支持「国际化i18n」- SaltyLeo's Blog (tstrs.me)</a> - <a href="https://siriusq.top/Hexo-Next-8-%E5%8F%8C%E8%AF%AD%E5%88%87%E6%8D%A2.html">HexoNext 8 双语切换</a></p></blockquote><h2><span id="hexo站点内页面跳转的问题">Hexo站点内页面跳转的问题</span></h2><p>在Hexo站点内部文章页面跳转在hexo中可以使用<code>My portfolio: &#123;% poge_link "Post Name"&#125;</code>这种方式简便的实现，但是由于我想要实现的是两个Page之间的跳转，而不是一个post跳转到另一个post，这种方式就无法实现了。最傻的办法就是直接使用markdown传统的网址链接的方式，但是感觉有点不是太方便，具体的页面跳转的方式有待查证(TODO)</p><blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://hexo.io/zh-cn/docs/tag-plugins.html#引用文章">标签插件（TagPlugins） | Hexo</a></li></ul></blockquote><h2><span id="添加可以切换模式的darkmode支持">添加可以切换模式的DarkMode支持</span></h2><p>目前Next主题已经支持DarkMode了，可以直接在<code>_config.yml</code>中进行配置，但是没有切换的功能，所以采用了<a href="https://github.com/rqh656418510/hexo-next-darkmode">hexo-dark-mode</a>插件来实现深色模式。可以使用自定义styl的方式分别设置浅色深色模式的背景，让背景图片和主题更搭一些。自定义styl需要在<code>source/</code>文件夹下创建<code>_data/</code>文件夹，然后再创建一个<code>styles.styl</code>文件，并在<code>_config.next.yml</code>中设置<code>custom_file_path</code>。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(/images/body-light.jpg); <span class="comment">// 可以是路径也可以是链接</span></span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat; <span class="comment">// 不重复</span></span><br><span class="line">    <span class="attribute">background-attachment</span>:fixed; <span class="comment">// 固定住背景图片</span></span><br><span class="line">    <span class="attribute">background-position</span>:<span class="number">50%</span> <span class="number">50%</span>; <span class="comment">// 图片位置：居中</span></span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span> <span class="number">100%</span>; <span class="comment">// 图片长宽扩充为100%</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.darkmode--activated</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">&#x27;/images/body-dark.jpg&#x27;</span>)</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-attachment</span>: fixed;</span><br><span class="line">    <span class="attribute">background-position</span>: <span class="number">50%</span>, <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background-size</span>: <span class="number">100%</span>, <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/Darkmode.gif"></p><blockquote><p><strong>参考资料</strong></p><ul><li><a href="https://www.techgrow.cn/posts/abf4aee1.html">Hexo Next 8.x主题添加可切换的暗黑模式 | Clay 的技术博客 (techgrow.cn)</a></li></ul></blockquote><h2><span id="使用mathjax对latex公式进行渲染">使用mathjax对<span class="math inline">\(\LaTeX\)</span>公式进行渲染</span></h2><p>我们在markdown中或多或少都会用到Latex来书写数学符号，NexT就为<span class="math inline">\(\LaTeX\)</span>提供了非常方便的渲染方式。我们只需要找到<code>/next/__config.yml</code>，然后找到如下配置并修改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: none | ams | all</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">none</span></span><br></pre></td></tr></table></figure><p>然而，由于hexo自带的<code>hexo-renderer-marked</code>会造成一些bug，所以我们使用pandoc会更加好一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-pandoc --save</span><br></pre></td></tr></table></figure><p>然后，进行部署就会发现渲染成功啦</p><p>更新2022.9.12</p><p>今天写的时候发现一个问题，<code>$$</code>符号没有隐藏，然后发现是因为似乎pandoc自动渲染了<code>\begin&#123;align&#125;</code>中的公式，所以外层的<code>$$</code>就被忽略了，所以去掉就好了，但是这样子就会有一个问题，就是在typora中是无法预览的，不是很方便，也许有机会研究一下如何解决吧(TODO)</p><blockquote><p>参考资料</p><ul><li><a href="https://nokiasonic.github.io/2020/12/17/%5BHexo%5DNext主题更好地支持LaTeX数学公式/">【Hexo】Next主题更好地支持LaTeX数学公式</a></li></ul></blockquote><h2><span id="next主题的目录层级问题">NexT主题的目录层级问题</span></h2><p>发现如果跨级使用目录的话，就会造成bug导致目录下的层级错乱，这就是由于我比较喜欢二级标题跟着四级标题，如果标题逐级递减就不会有这个问题了，把四级标题都改成三级标题就好了</p><p><img title src="https://i.loli.net/2021/07/23/rHYxJv5Rk96UNpd.png" alt="image-20210723224432413" width="387"></p><p>更新 (2022.10.6)最近又出现了目录乱七八糟的问题，这次是二级标题+三级标题但是还是有问题，尝试了一下严格的使用一级标题二级标题，发现就好了，以后还是一级标题起手吧orz。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL生成RESTful神器PostgREST</title>
      <link href="/2021/07/17/backend/postgresql-sheng-cheng-restful-shen-qi-postgrest/"/>
      <url>/2021/07/17/backend/postgresql-sheng-cheng-restful-shen-qi-postgrest/</url>
      
        <content type="html"><![CDATA[<p>当我们想要对PostgreSQL进行客户端上的操作时，我们需要从远端对数据库进行访问。这个时候PostgreSQL的神器PostgREST就可以出马了。PostgREST是一个能够帮助我们生成一系列用于操作PostgreSQL数据库的RESTfulAPI的服务器。之前我还尝试过直接使用Nginx中的ngx_postgres模块进行数据的操作，但是实际使用下来发现非常的麻烦，并且RESTfulstyle要求每个网址代表一种资源，在网址中不能有动词，只能有名词，而且所用的名词一般和数据库名称相同。然而，我在Nginx的使用中还并没有找到一种可以适配这种样式的方法，关于ngx_postgres这个模块，可以看一看我的这篇博客<a href="https://lucas-hao.github.io/2021/07/06/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/#more">Nginx以及ngx_postgres安装以及配置| Lucas的博客</a> 和这一篇<a href="https://lucas-hao.github.io/2021/07/08/shi-yong-java-tong-guo-nginx-fan-xiang-dai-li-fu-wu-qi-cao-zuo-postgresql-shu-ju-ku/">使用Java通过Nginx反向代理服务器操作PostgreSQL数据库| Lucas的博客 )</a> 。</p><span id="more"></span><h2><span id="postgrest的配置">PostgREST的配置</span></h2><p>PostgREST的下载安装也非常的方便，首先我们创建一个文件夹用来放置PostgREST的安装目录。这里我选择在<code>/opt</code>目录下创建文件夹<code>postgrest</code>，然后下载压缩包到<code>~/pacakges</code>，压缩包最新版本可以在<a href="https://github.com/PostgREST/postgrest/releases/tag/v7.0.1">Releasev7.0.1 · PostgREST/postgrest(github.com)</a>里面找到，这里我下载的是7.0.1版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> wget https://github.com/PostgREST/postgrest/releases/download/v7.0.1/postgrest-v7.0.1-linux-x64-static.tar.xz</span><br></pre></td></tr></table></figure><p>将压缩包解压到postgrest中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/packages</span><br><span class="line"><span class="built_in">sudo</span> tar -xvf postgrest-v7.0.1-linux-x64-static.tar.xz -C /opt/postgrest</span><br></pre></td></tr></table></figure><p>然后进入postgrest目录中，解压后只有一个可执行文件<code>postgrest</code>，执行解压后的可执行文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/postgrest</span><br><span class="line">./postgrest</span><br></pre></td></tr></table></figure><p>执行之后看到提示说明配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db-uri = <span class="string">&quot;postgres://user:pass@localhost:5432/dbname&quot;</span></span><br><span class="line">db-schema = <span class="string">&quot;public&quot;</span></span><br><span class="line">db-anon-role = <span class="string">&quot;postgres&quot;</span></span><br><span class="line">db-pool = 10</span><br></pre></td></tr></table></figure><p>接下来配置配置文件，新建文件<code>default.conf</code>，配置文件内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># postgrest.conf</span></span><br><span class="line"><span class="comment"># The standard connection URI format, documented at</span></span><br><span class="line"><span class="comment"># &lt;https://www.postgresql.org/docs/current/static/libpq-connect.html#AEN45347&gt;</span></span><br><span class="line">db-uri       = <span class="string">&quot;postgres://postgres:password@127.0.0.1:5432/dbname&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of which database schema to expose to REST clients</span></span><br><span class="line">db-schema    = <span class="string">&quot;public&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The database role to use when no client authentication is provided.</span></span><br><span class="line"><span class="comment"># Can (and probably should) differ from user in db-uri</span></span><br><span class="line">db-anon-role = <span class="string">&quot;postgres&quot;</span></span><br></pre></td></tr></table></figure><p>用设置好的配置文件启动postgrest</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/postgrest</span><br><span class="line"><span class="built_in">sudo</span> ./postgrest default.conf</span><br></pre></td></tr></table></figure><p>启动之后，就会看到日志直接输出，可以通过Ctrl-C停止程序。我们可以通过调整将日志输出到日志文件，并且后台运行程序，日志文件应该保存在当前用户空间中，否则会出现权限问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">nohup</span> postgrest default.conf&gt;~/postgrest.log &amp;</span><br></pre></td></tr></table></figure><p>启动之后，我们就可以通过PostgREST进行Query或者Insertion了。</p><p>如果想要停止PostgREST，需要先找到它的进程，然后kill就好了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -A | grep postgrest  # 查看进程</span><br><span class="line">sudo lsof -i:3000# 查看端口，也会显示进程PID</span><br><span class="line">kill PID# 杀死进程</span><br></pre></td></tr></table></figure><h2><span id="postgrest和nignx联合使用">PostgREST和Nignx联合使用</span></h2><p>虽然PostgREST能够为我们提供强大的RESTfulAPI帮助，但是它并未提供一些安全上的保障和措施。所以，在实际应用中，我们可以搭配强大的Nginx，用Nginx反向代理PostgREST。我们在Nginx的配置文件中加入如下配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream postgrest &#123;</span><br><span class="line">server localhost:3000;</span><br><span class="line">    keepalive 64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">location /api/ &#123;</span><br><span class="line">        default_type  application/json;</span><br><span class="line">        proxy_hide_header Content-Location;</span><br><span class="line">        add_header Content-Location  /api/<span class="variable">$upstream_http_content_location</span>;</span><br><span class="line">        proxy_set_header  Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_pass http://postgrest/;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以直接通过<code>http://hostname/api/</code>来对数据库进行操作</p><p>参考资料：<a href="https://www.cnblogs.com/cunchen/p/9464115.html">【PostgREST基本教程（一）】 PostgREST快速搭建 )</a></p><p>使用教程：<a href="https://postgrest.org/en/stable/">官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo下yilia主题博客个性化自定义</title>
      <link href="/2021/07/16/other/hexo-zhu-ti-yilia-pei-zhi-ji-lu/"/>
      <url>/2021/07/16/other/hexo-zhu-ti-yilia-pei-zhi-ji-lu/</url>
      
        <content type="html"><![CDATA[<p>我的博客采用的hexo下的yilia主题，这篇文章记录一下自己折腾配置博客的方法和经过。首先是创建博客的基本的几个命令 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo g # 生成博客网页文件</span><br><span class="line">hexo s # 本地预览博客，打开本地网址http://localhost:4000/进行预览</span><br><span class="line">hexo d # 上传网页文件到github</span><br><span class="line">hexo new post &quot;Article Title&quot; # 新建一篇博客</span><br><span class="line">hexo cl &amp;&amp; hexo g &amp;&amp;　hexo s # 一步实现清除重构本地预览</span><br></pre></td></tr></table></figure> <span id="more"></span></p><h2><span id="yilia主题下的截断功能及优化">yilia主题下的截断功能及优化</span></h2><p>一篇文章太长，不需要将其全部显示出来，在yilia主题下，我们只需要在我们的markdown文件中需要截断的地方插入<code>&lt;!-- more --&gt;</code>就可以实现阶段了。</p><p>但是这个时候发现，在截断的地方会有一个<code>more&gt;&gt;</code>的标志出现，与展开全文重复了</p><figure><img src="https://i.loli.net/2021/04/06/XcU5V76DT3HniFN.png" alt="image-20210406213135567"><figcaption aria-hidden="true">image-20210406213135567</figcaption></figure><p>为了去除这个<code>more&gt;&gt;</code>，在<code>themes/_config.yml</code>，修改excerpt_link参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">excerpt_link：之后的more单词换成空格</span><br><span class="line">注：‘excerpt_link： ’。其中：后有一个空格键</span><br></pre></td></tr></table></figure><h2><span id="优先级配置">优先级配置</span></h2><p>修改根目录配置文件<code>/_config.yml</code>,top值-1标示根据top值倒序（正序设置为1即可），同样<code>date</code>也是根据创建日期倒序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">index_generator</span>:</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page</span>: <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by</span>:</span><br><span class="line">    <span class="attr">top</span>: -<span class="number">1</span></span><br><span class="line">    <span class="attr">date</span>: -<span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="在左边栏显示总文章数">在左边栏显示总文章数</span></h2><p>将<code>themes\yilia\layout_partial\left-col.ejs</code>文件的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav <span class="keyword">class</span>=<span class="string">&quot;header-menu&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &lt;% for (var i in theme.menu)&#123; %&gt;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%- url_for(theme.menu[i]) %&gt;&quot;</span>&gt;</span>&lt;%= i %&gt;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &lt;%&#125;%&gt;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><p>后面加上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    总文章数 &lt;%=site.<span class="property">posts</span>.<span class="property">length</span>%&gt;</span><br><span class="line">&lt;/nav&gt;</span><br></pre></td></tr></table></figure><h2><span id="添加网站流量计数功能">添加网站流量计数功能</span></h2><ul><li><p>在<code>_config.yml</code>中添加 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">busuanzi:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p></li><li><p>将themes/yilia/layout/_partial/footer.ejs替换为一下代码<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;footer id=<span class="string">&quot;footer&quot;</span>&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outer&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer-left&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">       <span class="symbol">&amp;copy;</span> &lt;%= date(new Date(), &#x27;YYYY&#x27;) %&gt; &lt;%= config.author || config.title %&gt;</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer-right&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://hexo.io/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span>  Theme <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://github.com/litten/hexo-theme-yilia&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>Yilia<span class="tag">&lt;/<span class="name">a</span>&gt;</span> by Litten</span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">calss</span>=<span class="string">&quot;count-span&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">     <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">         总访问量: <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_site_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"> <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">&quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p></li><li><p>打开<code>\themes\yilia\layout\_partial\article.ejs</code>，在<code>&lt;header class="article-header"&gt;</code>里加入以下代码:<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 添加代码 访问统计 --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span> ( !index )&#123; %&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;archive-article-date&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        阅读量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></p></li></ul><figure><img src="https://i.loli.net/2021/04/06/tPHydr4apl3oUDx.png" alt="image-20210406210243081"><figcaption aria-hidden="true">image-20210406210243081</figcaption></figure><p>参考资源: <a href="https://blog.csdn.net/weixin_43864927/article/details/106970576">Hexo个人博客之yilia主题阅读量和文章字数统计</a></p><h2><span id="添加字数统计和阅读时长功能">添加字数统计和阅读时长功能</span></h2><ul><li><p><strong>安装hexo-wordcount</strong></p><p>在终端中博客目录下输入命令(安装wordcount插件) <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i –save hexo-wordcount</span><br></pre></td></tr></table></figure></p></li><li><p><strong>配置修改</strong></p><p>在theme_partial.ejs文件：</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=<span class="string">&quot;margin-top:10px;&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-keyboard-o&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>  字数统计: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>&lt;%= wordcount(post.content) %&gt;字<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-time&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="symbol">&amp;nbsp;</span> | <span class="symbol">&amp;nbsp;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-hourglass-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span>  阅读时长: <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-count&quot;</span>&gt;</span>&lt;%= min2read(post.content) %&gt;分<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>在<code>\themes\yilia\layout\_partial\article.ejs</code>中添加</p><p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 需要添加的位置 --&gt;</span><br><span class="line">&lt;!-- 开始添加字数统计--&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span>(theme.<span class="property">word_count</span> &amp;&amp; !post.<span class="property">no_word_count</span>)&#123;%&gt;</span><br><span class="line">    &lt;%- <span class="title function_">partial</span>(<span class="string">&#x27;post/word&#x27;</span>) %&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">            &lt;!-- 添加完成 --&gt;</span><br></pre></td></tr></table></figure></p><figure><img src="https://i.loli.net/2021/04/06/BIudtvj9NOxirUS.png" alt="image-20210406210706379"><figcaption aria-hidden="true">image-20210406210706379</figcaption></figure></li></ul><p>参考资源: <a href="https://blog.csdn.net/weixin_43864927/article/details/106970576">Hexo个人博客之yilia主题阅读量和文章字数统计</a></p><h2><span id="live-2d看板娘">Live 2D看板娘</span></h2><p>在博客的根目录运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>安装想要的live2d动画人物模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-haru</span><br></pre></td></tr></table></figure><p>live2d-widget-model-haru这个是一个动画的样式model，你可以在网上搜到很多。</p><p>安装成功后，你可以在你的<code>博客根文件夹/node_modules/</code>底下找到<code>live2d-widget-model-haru</code>这个文件夹。模型可以在<a href="https://github.com/xiazeyu/live2d-widget-models">live2d-widget-models</a>中找到。</p><p>修改根目录下的配置文件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># <span class="number">7.</span>live2d配置宠物</span><br><span class="line">live2d<span class="punctuation">:</span></span><br><span class="line">  # 当enable 为<span class="literal"><span class="keyword">true</span></span>的时候，会启用yaliya主题自带宠物shizuku<span class="punctuation">,</span>橘头发小姐姐，而且不可以配置位置，所以需要讲enable注释掉</span><br><span class="line">  # enable<span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  scriptFrom<span class="punctuation">:</span> local</span><br><span class="line">  pluginRootPath<span class="punctuation">:</span> live2dw/</span><br><span class="line">  pluginJsPath<span class="punctuation">:</span> lib/</span><br><span class="line">  pluginModelPath<span class="punctuation">:</span> assets/</span><br><span class="line">  model<span class="punctuation">:</span></span><br><span class="line">  # 我用的是初音的模型(老二次元了)</span><br><span class="line">  use<span class="punctuation">:</span> live2d-widget-model-miku</span><br><span class="line">    # live2d-widget-model-wanko 是一只趴在碗里的狗狗</span><br><span class="line">    # use<span class="punctuation">:</span> live2d-widget-model-wanko # 通过修改use来确定使用哪种model</span><br><span class="line">    # hibiki 是一个御姐</span><br><span class="line">    # use<span class="punctuation">:</span> live2d-widget-model-hibiki</span><br><span class="line">    # haruto 海军服女孩，有点难看</span><br><span class="line">    # use<span class="punctuation">:</span> live2d-widget-model-haruto</span><br><span class="line">  display<span class="punctuation">:</span></span><br><span class="line">    position<span class="punctuation">:</span> left</span><br><span class="line">    width<span class="punctuation">:</span> <span class="number">150</span></span><br><span class="line">    height<span class="punctuation">:</span> <span class="number">300</span></span><br><span class="line">    # 一个比较可爱的位置</span><br><span class="line">    # hOffset<span class="punctuation">:</span> <span class="number">200</span> </span><br><span class="line">    # vOffset<span class="punctuation">:</span> <span class="number">-100</span></span><br><span class="line">    # 第二个位置配置，这个在左侧边栏位置很居中</span><br><span class="line">    hOffset<span class="punctuation">:</span> <span class="number">80</span>  # 调节水平位置</span><br><span class="line">    vOffset<span class="punctuation">:</span> <span class="number">-50</span>  # 调节垂直位置</span><br><span class="line">  mobile<span class="punctuation">:</span></span><br><span class="line">    show<span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br></pre></td></tr></table></figure><p>参考资料:</p><p><a href="https://www.jianshu.com/p/5b5c61323772">hexo-添加Live2d看板动画（添加宠物）- yaliya 主题 一个小坑</a></p><p><a href="https://wu_aquarius.gitee.io/live2d/">Hexo博客添加看板娘</a></p><h2><span id="yilia替换背景">yilia替换背景</span></h2><p>首先，左侧栏替换背景</p><p>找到<code>themes/yilia/layout/_partial/left-col.ejs</code>，将</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;overlay&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background: &lt;%= theme.style &amp;&amp; theme.style.header ? theme.style.header : defaultBg %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> --&gt;</span><br></pre></td></tr></table></figure><p>注释掉，然后在<code>themes\yilia\source\main.0cf68a.css</code>中修改样式，注释掉原有的背景颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left-col</span> &#123;</span><br><span class="line">    <span class="comment">/* background:#fff; */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>)), <span class="built_in">url</span>(<span class="string">&#x27;image-url&#x27;</span>) no-repeat <span class="number">0%</span> <span class="number">20%</span>/ cover;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">position</span>: fixed;</span><br><span class="line">    <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">2s</span> ease-in;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">999</span>;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">15px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，右侧主题区域替换背景。这里调整的是右侧显示文章的区域。在这里如果将代码作一下变化，那么右侧文章区域就会呈现半透明的状态。我为了简洁，还是选择这块区域呈现出不透明的状态。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.article</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ddd</span>;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#fff</span>;</span><br><span class="line">    <span class="comment">/* background: #fff; */</span></span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,.<span class="number">5</span>);</span><br><span class="line">    <span class="attribute">transition</span>: all .<span class="number">2s</span> ease-in</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来有两个地方需要注意，一个是<code>.mid-col</code>中的背景和<code>body</code>中的背景</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.mid-col</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="comment">/* background: #eaeaea; */</span></span><br><span class="line">    <span class="attribute">left</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">width</span>: auto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"></span><br><span class="line">  *<span class="attribute">overflow-y</span>*: hidden;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* background: #eaeaea */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两处都需要把背景注释掉，否则会遮挡背景图片导致图片无法显示。</p><p>然后在<code>body</code>中设置背景图片（和上面的body不是一个body，可以使用vscode中的搜索功能搜索）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">    <span class="attribute">font-family</span>: Helvetica Neue, Helvetica, STHeiTi, Arial, sans-serif;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">1.5</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="comment">/* background-color: #fff; */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(<span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>), <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">0.5</span>)), </span><br><span class="line">    <span class="built_in">url</span>(<span class="string">&#x27;image-url&#x27;</span>) no-repeat <span class="number">0%</span> <span class="number">0%</span>/ cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前左侧栏的背景成功更改了，但是右侧区域的背景还是没有成功更改。</p><p>参考资料:</p><p><a href="https://blog.csdn.net/weixin_41287260/article/details/103050813?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">hexo+yilia添加背景图片</a></p><p><a href="https://blog.csdn.net/weixin_44330881/article/details/103293892?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">hexo之yilia主题添加背景图片</a></p><h2><span id="修改翻页不能正确显示的bug">修改翻页不能正确显示的bug</span></h2><p>默认的Yilia主题下的翻页会有bug，在主页下的上下翻页会有如下的bug，HTML的特殊符号无法正确显示。</p><figure><img src="https://i.loli.net/2021/07/16/RNO63KuTbWn8tPH.png" alt="image-20210716214619724"><figcaption aria-hidden="true">image-20210716214619724</figcaption></figure><p>强迫症看着非常难受，索性直接改成中文上一页和下一页，找到<code>yilia/layout/_partial/archive.ejs</code>分别修改<strong>第8,9行</strong>和<strong>第37,38行</strong>，如下图：</p><figure><img src="https://i.loli.net/2021/07/16/BH5FIjKzf7eQCDp.png" alt="image-20210716215012720"><figcaption aria-hidden="true">image-20210716215012720</figcaption></figure><p>修改完之后，再找到文件<code>yilia/layout/_partial/script.ejs</code>，搜索<code>&amp;laquo; Prev</code>和<code>Next &amp;raquo;</code>并且删除，然后本来的Prev和Next就变成了“上一页”和”下一页“。参考<a href="https://blog.csdn.net/CYK5201995/article/details/107769487">软件 |hexo博客主题yilia上一页下一页显示的问题_RyanCYK的计算机世界-CSDN博客</a></p><h2><span id="gitalk-评论">Gitalk 评论</span></h2><p>在<a href="https://github.com/settings/applications/new">New OAuthApplication (github.com)</a>中进行注册，如下图：</p><figure><img src="https://i.loli.net/2021/07/17/9qHwNdr5CxtZ3Sz.png" alt="image-20210717000639493"><figcaption aria-hidden="true">image-20210717000639493</figcaption></figure><p>注册好之后，就可以得到Client ID和ClientSecret，然后我们需要创建一件仓库用来承接gitalk的评论。</p><p>在主题下的<code>_config.yml</code>中找到gitalk配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">gitalk:</span></span><br><span class="line">    <span class="attr">githubID:</span> <span class="comment"># 填你的 github 用户名</span></span><br><span class="line">    <span class="attr">repo:</span> <span class="string">xxx.github.io</span> <span class="comment"># 承载评论的仓库，一般使用 Github Page 仓库</span></span><br><span class="line">    <span class="attr">ClientID:</span> <span class="comment"># 第1步获得 Client ID</span></span><br><span class="line">    <span class="attr">ClientSecret:</span> <span class="comment"># 第1步获得 Client Secret</span></span><br><span class="line">    <span class="attr">adminUser:</span> <span class="comment"># Github 用户名</span></span><br><span class="line">    <span class="attr">distractionFreeMode:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">language:</span> <span class="string">zh-CN</span></span><br><span class="line">    <span class="attr">perPage:</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>然后重新部署博客页面就可以看到评论区出现了</p><p>参考资料：<a href="https://yelog.org/2020/05/23/3-hexo-comment/">3-hexo评论设置 |叶落阁 (yelog.org)</a> 这个博主的yilia还蛮全面的</p><p>在使用的时候发现了以下异常，Gitalk出现Error:ValidationFailed问题，经过查询发现这是由于Gitalk的id有长度限制，而在yilia中默认是将通过url设置为id，所以很容易长度超过50，解决办法：我们可以把id设置为文章标题，这样子就不容易超过50了。修改<code>yilia/layout/_partial/post/gitment.ejs</code>，第6行修改为<code>id: "&lt;%=post.title%&gt;"</code>，问题解决。</p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Java通过Nginx反向代理服务器操作PostgreSQL数据库</title>
      <link href="/2021/07/08/java/shi-yong-java-tong-guo-nginx-fan-xiang-dai-li-fu-wu-qi-cao-zuo-postgresql-shu-ju-ku/"/>
      <url>/2021/07/08/java/shi-yong-java-tong-guo-nginx-fan-xiang-dai-li-fu-wu-qi-cao-zuo-postgresql-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个项目，需要讲AndroidApp和服务器上的PostgreSQL进行连接，但是AndroidStudio不能够直接通过JDBC进行连接，所以选择通过Nginx作为中间服务器对PostgreSQL进行操作，这篇文章紧接<a href="https://lucas-hao.github.io/2021/07/06/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/#more">Nginx以及ngx_postgres安装以及配置</a>。</p><p><strong>更新：后来发现使用nginx的效果并不好，更好的方法可能是使用PostgREST+Nginx反向代理对数据库进行操作，因为PostgREST直接提供了处理PostgreSQL数据库的RESTful接口，更加方便。详细教程可以去网上搜一搜。</strong></p><span id="more"></span><p>我们的数据库中的数据主要存储的是Androidapp中的使用信息，定义app_usage_info表拥有以下字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">day</span> <span class="type">date</span>,</span><br><span class="line">app_name text,</span><br><span class="line">package_name text,</span><br><span class="line">app_usage_time <span class="type">interval</span>,</span><br><span class="line">app_usage_count <span class="type">integer</span></span><br></pre></td></tr></table></figure><p>首先，我们需要对nginx的配置文件进行配置，nginx的配置文件一般是在nginx的安装目录下的/conf/nginx.conf，比如在我的系统中就是/opt/nginx/conf/nginx.conf，打开配置文件我们就可以进行配置。Nginx的配置文件结构可以在<a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx配置详解 | 菜鸟教程 (runoob.com)</a>中简单学习一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 1;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">        include         mime.types;</span><br><span class="line">        default_type    application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">        keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    upstream database &#123;</span><br><span class="line">        postgres_server 172.29.118.77 dbname=postgres user=postgres password=511668;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line"></span><br><span class="line">        charset utf-8;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name localhost;</span><br><span class="line"></span><br><span class="line">        location /insert &#123;</span><br><span class="line">            postgres_pass database;</span><br><span class="line">            rds_json on;</span><br><span class="line">            postgres_query &quot;insert into app_usage_info VALUES (&#x27;$arg_day&#x27;, &#x27;$arg_app_name&#x27;, &#x27;$arg_package_name&#x27;, &#x27;$arg_time&#x27;, &#x27;$arg_count&#x27;);</span><br><span class="line">            postgres_rewrite no_changes 410;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /query-all &#123;</span><br><span class="line">            postgres_pass database;</span><br><span class="line">            rds_json on;</span><br><span class="line">            postgres_query &quot;select * from app_usage_info&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location /query-day &#123;</span><br><span class="line">            postgres_pass database;</span><br><span class="line">            rds_json on;</span><br><span class="line"></span><br><span class="line">            postgres_query      HEAD GET &quot;SELECT * FROM app_usage_info WHERE day=&#x27;$arg_day&#x27;&quot;;</span><br><span class="line">            postgres_rewrite    HEAD GET no_rows 410;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">               root   html;</span><br><span class="line">               index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">       # 错误页面 </span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">                root    html;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这是我的一个简单的配置，为了对数据库做不同的处理，我定义了insert页面，query-day（查询指定天数）页面，query-all（查询整个表）页面。这里面还涉及到关于Nginx中变量的使用，可以看这一篇<a href="https://www.jianshu.com/p/44680c081ea0">Nginx变量使用方法详解 -简书(jianshu.com)</a>，讲得还是非常的清楚的。这里我使用了<code>$arg_XXX</code>变量，就可以直接通过http网址进行参数的设定了，也就很方便的可以通过JAVA的Http请求执行对应的数据库操作。</p><p>下面是用来实现Http请求的Java类，参考这篇文章实现<a href="https://www.jb51.net/article/206762.htm#:~:text=JAVA发送HTTP请求的四种方式总结%201%20HttpURLConnection%202,URLConnection%203%20HttpClient%204%20Socket">JAVA发送HTTP请求的四种方式总结_java_脚本之家(jb51.net)</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String uri;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HttpUtils</span><span class="params">(String hostname)</span> &#123;</span><br><span class="line">        uri = hostname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendRequest</span><span class="params">(String url, Callback callback)</span> &#123;</span><br><span class="line">        <span class="type">OkHttpClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OkHttpClient</span>();</span><br><span class="line">        <span class="type">Request</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Request</span>.Builder().url(url).build();</span><br><span class="line">        client.newCall(request).enqueue(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sendRequestWithHttpURL</span><span class="params">(String urlParam,String requestType)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(urlParam);</span><br><span class="line">            <span class="comment">//得到连接对象</span></span><br><span class="line">            con = (HttpURLConnection) url.openConnection();</span><br><span class="line">            <span class="comment">//设置请求类型</span></span><br><span class="line">            con.setRequestMethod(requestType);</span><br><span class="line">            <span class="comment">//设置请求需要返回的数据类型和字符集类型</span></span><br><span class="line">            con.setRequestProperty(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">            <span class="comment">//允许写出</span></span><br><span class="line">            con.setDoOutput(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//允许读入</span></span><br><span class="line">            con.setDoInput(<span class="literal">true</span>);</span><br><span class="line">            <span class="comment">//不使用缓存</span></span><br><span class="line">            con.setUseCaches(<span class="literal">false</span>);</span><br><span class="line">            <span class="comment">//得到响应码</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">responseCode</span> <span class="operator">=</span> con.getResponseCode();</span><br><span class="line">            System.out.println(urlParam + <span class="string">&quot;: &quot;</span> + responseCode);</span><br><span class="line">            <span class="keyword">if</span>(responseCode == HttpURLConnection.HTTP_OK)&#123;</span><br><span class="line">                <span class="comment">//得到响应流</span></span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> con.getInputStream();</span><br><span class="line">                <span class="comment">//将响应流转换成字符串</span></span><br><span class="line">                resultBuffer = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">                String line;</span><br><span class="line">                buffer = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(inputStream, <span class="string">&quot;utf-8&quot;</span>));</span><br><span class="line">                <span class="keyword">while</span> ((line = buffer.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                    resultBuffer.append(line);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> resultBuffer.toString();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ProtocolException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Failed!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String day, String app_name, String package_name, String interval, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> sendRequestWithHttpURL(uri+<span class="string">&quot;/insert?&quot;</span>+<span class="string">&quot;day=&quot;</span>+day+<span class="string">&quot;&amp;app_name=&quot;</span>+app_name+<span class="string">&quot;&amp;package_name=&quot;</span>+package_name+<span class="string">&quot;&amp;time=&quot;</span>+interval+<span class="string">&quot;&amp;count=&quot;</span>+count, <span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        System.out.println(responseData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> sendRequestWithHttpURL(uri+<span class="string">&quot;/query-all&quot;</span>, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        System.out.println(responseData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">queryDay</span><span class="params">(String day)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">responseData</span> <span class="operator">=</span> sendRequestWithHttpURL(uri+<span class="string">&quot;/query-day?day=&quot;</span>+day, <span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        System.out.println(responseData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数所在类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span><span class="string">&quot;your host address&quot;</span>;</span><br><span class="line">        <span class="type">HttpUtils</span> <span class="variable">http</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpUtils</span>(url);</span><br><span class="line">        http.queryAll();</span><br><span class="line">        http.queryDay(<span class="string">&quot;2021-07-07&quot;</span>);</span><br><span class="line">        http.insert(<span class="string">&quot;2021-07-08&quot;</span>, <span class="string">&quot;华为桌面&quot;</span>, <span class="string">&quot;com.huawei.android.launcher&quot;</span>,</span><br><span class="line">                <span class="string">&quot;00:18:41&quot;</span>, <span class="number">63</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果</p><figure><img src="https://i.loli.net/2021/07/16/DJsO18TfyU29MSz.png" alt="image-20210708152524585"><figcaption aria-hidden="true">image-20210708152524585</figcaption></figure><h4><span id="参考资料">参考资料</span></h4><p>[1] <a href="https://www.runoob.com/w3cnote/nginx-setup-intro.html">Nginx配置详解 | 菜鸟教程 (runoob.com)</a></p><p>[2] <a href="https://www.jianshu.com/p/44680c081ea0">Nginx变量使用方法详解 -简书 (jianshu.com)</a></p><p>[3] <a href="https://www.jb51.net/article/206762.htm#:~:text=JAVA发送HTTP请求的四种方式总结%201%20HttpURLConnection%202,URLConnection%203%20HttpClient%204%20Socket">JAVA发送HTTP请求的四种方式总结_java_脚本之家(jb51.net)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> PostgreSQL </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx以及ngx_postgres安装以及配置</title>
      <link href="/2021/07/06/backend/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/"/>
      <url>/2021/07/06/backend/nginx-yi-ji-ngx-postgres-an-zhuang-yi-ji-pei-zhi/</url>
      
        <content type="html"><![CDATA[<p>最近在做一个项目，需要讲AndroidApp和服务器上的PostgreSQL进行连接，但是AndroidStudio不能够直接通过JDBC进行连接，所以选择通过Nginx作为中间服务器对PostgreSQL进行操作。以下简单记录一下安装nginx和配置ngx_postgres的过程<span id="more"></span></p><p>首先，由于我们在手动安装的过程中需要对nginx的源码进行编译，所以首先系统中必须具有C/C++的编译器，如果没有，手动安装一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install gcc <span class="comment"># 安装C语言编译器gcc</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install g++ <span class="comment"># 安装C++编译器g++</span></span><br></pre></td></tr></table></figure><p>接下来依次安装我们需要的包，这里我全部安装到<code>~/packages</code>路径下。对于压缩包使用<code>wget address</code>命令下载，使用<code>tar -zxvf filename.tar.gz</code>进行解压；对于github上的仓库，使用<code>git clone github_address</code>克隆到本地。</p><ul><li><p>nginx http://nginx.org/download/nginx-1.20.1.tar.gz</p><p>在官网http://nginx.org/download/找到对应的压缩包，然后下载解压</p></li><li><p>ngx_postgres https://github.com/FRiCKLE/ngx_postgres.git</p></li><li><p>ngx_postgres还需要下载安装libpq，否则就会在编译的时候出现错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure: error: ngx_postgres addon was unable to find the libpq library.</span><br></pre></td></tr></table></figure><p>使用<code>sudo apt-get install libpq-dev</code>进行安装</p></li><li><p>ngx_devel_kithttps://github.com/vision5/ngx_devel_kit.git</p></li><li><p>rds-json-nginx-modulehttps://github.com/openresty/rds-json-nginx-module.git</p></li><li><p>form-input-nginx-modulehttps://github.com/nginx-modules/form-input-nginx-module.git</p></li></ul><p>还有几个nginx本身需要依赖的包，即使不使用ngx_postgres也是需要下载安装的</p><ul><li><p>pcre:https://jaist.dl.sourceforge.net/project/pcre/pcre/8.45/pcre-8.45.tar.gz</p><p>在这个网站可以找到对应的压缩包http://sourceforge.net/projects/pcre/files/pcre/</p></li><li><p>zlib:https://jaist.dl.sourceforge.net/project/libpng/zlib/1.2.11/zlib-1.2.11.tar.gz</p><p>官网 https://www.zlib.net/</p><figure><img src="https://i.loli.net/2021/07/16/zT3L16CWE8FmY9v.png" alt="zlib"><figcaption aria-hidden="true">zlib</figcaption></figure></li><li><p>openssl Github 地址:https://github.com/openssl/openssl.git</p></li></ul><p>全部下载完成之后应该有以下文件夹</p><figure><img src="https://i.loli.net/2021/07/16/H9VpaqmzQldSgnR.png" alt="packages"><figcaption aria-hidden="true">packages</figcaption></figure><p>然后进入nginx-1.20.1目录下，这个目录下有一个configure可执行文件，在命令行中输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./configure --prefix=/opt/nginx \\</span><br><span class="line">--with-pcre=/home/ubuntu/packages/pcre-8.45 \\ </span><br><span class="line">--with-zlib=/home/ubuntu/packages/zlib-1.2.11 \\ </span><br><span class="line">--with-openssl=/home/ubuntu/packages/openssl \\ </span><br><span class="line">--add-module=/home/ubuntu/packages/ngx_postgres \\</span><br><span class="line">--add-module=/home/ubuntu/packages/rds-json-nginx-module \\ </span><br><span class="line">--add-module=/home/ubuntu/packages/ngx_devel_kit \\</span><br><span class="line">--add-module=/home/ubuntu/packages/form-input-nginx-module</span><br></pre></td></tr></table></figure><p><code>--prefix=/opt/nginx</code>代表我把nginx安装在这个目录下，下面几行是所添加的module和包，填上自己的文件路径就可以了。然后运行命令<code>make</code>，如果没有下载make的话使用<code>apt-get</code>安装以下就好了。执行了<code>make</code>之后，出现了以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/home/ubuntu/packages/ngx_postgres/src/ngx_postgres_module.c:1323:21: error: ‘ngx_http_upstream_srv_conf_t’ &#123;aka ‘struct ngx_http_upstream_srv_conf_s’&#125; has no member named ‘default_port’</span><br><span class="line"> 1323 |         <span class="keyword">if</span> (uscfp[i]-&gt;default_port &amp;&amp; url-&gt;default_port</span><br><span class="line">      |                     ^~</span><br><span class="line">/home/ubuntu/packages/ngx_postgres/src/ngx_postgres_module.c:1324:25: error: ‘ngx_http_upstream_srv_conf_t’ &#123;aka ‘struct ngx_http_upstream_srv_conf_s’&#125; has no member named ‘default_port’</span><br><span class="line"> 1324 |             &amp;&amp; (uscfp[i]-&gt;default_port != url-&gt;default_port))</span><br></pre></td></tr></table></figure><p>到nginx的<code>src/http/ngx_http_upstream.h</code>文件找到<code>ngx_http_upstream_srv_conf_s</code>结构添加<code>in_port_t default_port;</code></p><p><img src="https://i.loli.net/2021/07/16/OjwVoBn2Xzg7ypc.png"></p><p>然后执行命令<code>make</code>，没有问题之后执行<code>make install</code>就可以成功安装了。</p><p>安装成功，我们就可以在我们的安装路径下<code>/opt/nginx</code>找到对应的安装目录，nginx可执行文件就是/opt/nginx/sbin/nginx这个路径。</p><p>使用以下命令启动nginx服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /opt/nginx/sbin/nginx -c /opt/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure><p>最后我们可以创建软链接，这样就可以不用自己手动配置了，只需要输入sudonginx就可以启动了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /opt/nginx/sbin/nginx /usr/bin/nginx</span><br></pre></td></tr></table></figure><p>使用<code>sudo nginx</code>开始nginx，<code>nginx -s stop</code>停止nginx。打开nginx之后，就可以在我们的服务器域名下看到如下的页面</p><p><img src="https://i.loli.net/2021/07/16/ibrBwHGD3h9aIAO.png"></p><h4><span id="参考资料">参考资料</span></h4><p>[1]知乎，<em>nginx安装及其配置详细教程</em>，https://zhuanlan.zhihu.com/p/83890573</p><p>[2] CSDN，<em>ubuntu手动安装nginx</em>，https://blog.csdn.net/xiaoyou625/article/details/112006193</p><p>[3] HostAdvice, <em>How to Install PostgreSQL on an Ubuntu VPSRunning Nginx</em>,https://hostadvice.com/how-to/how-to-install-postgresql-on-nginx-web-servers/</p>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java实现一个简单的计算器</title>
      <link href="/2021/07/01/java/java-jian-dan-de-ji-suan-qi/"/>
      <url>/2021/07/01/java/java-jian-dan-de-ji-suan-qi/</url>
      
        <content type="html"><![CDATA[<h1><span id="java实现一个简单的计算器">Java实现一个简单的计算器</span></h1><p>在LeetCode上有几道题目实现简单的计算器，最近刚刚在Algorithms (4thedition)上学习了利用栈实现简单的计算器，使用的是E.W.Dijkstra在1960s提出的栈算法实现的。利用栈后进先出的特性，可以实现对括号以及优先级的处理。第一次尝试这种算法，写出来的代码效率也不是很高。</p><span id="more"></span><h3><span id="基本想法">基本想法</span></h3><p>首先，初始化两个栈，一个用来存储运算符（包括括号和各种运算符)。<code>Stack&lt;String&gt; ops = new Stack&lt;String&gt;();</code><code>Stack&lt;Integer&gt; vals = new Stack&lt;Integer&gt;();</code>第一个程序实现的是只包括加减的，因此没有运算优先顺序，只需要考虑括号，空格等字符。基本想法是：向standardinput内输入一个字符串表达式，然后对数字和符号进行各自对应的处理。遇到一个数字，push进<code>vals</code>栈，遇到一个运算符，先判断在<code>ops</code>中的上一个字符是否可以进行运算（之所以这样子做是因为这样子也可以方便判断优先级），若可以进行运算，那么就将<code>ops</code>中的一个符号和<code>vals</code>的数pop出来进行对应的运算，然后将当前的运算符push进<code>ops</code>，否则，直接将当前符号push进<code>ops</code>。如果遇到右括号，直接对栈中的元素进行运算直到遇到左括号。</p><h3><span id="对于字符串转整型的处理">对于字符串转整型的处理</span></h3><p>首先，我们可以设置一个<code>int flag = 0</code>，若读取的当前字符为数字，那么就将<code>flag</code>的值设为1，并且将这个数字转化为<code>int</code>入栈。若当前的字符不为数字，记得一定要将<code>flag</code>的值重新设为0。代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">currentString</span> <span class="operator">=</span> s.subString(i,i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(currentChar.charAt(<span class="number">0</span>) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; currentChar.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)</span><br><span class="line">            vals.push(Integer.parseInt(currentChar));</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">       vals.push(Integer.parseInt(Integer.toString(vals.pop())+currentChar()));</span><br><span class="line">        flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="完整代码">完整代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Stack&lt;String&gt; ops = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;String&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; vals = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">currentChar</span> <span class="operator">=</span> s.substring(i, i + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//将当前位置的字符转化为字符串</span></span><br><span class="line">            <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot; &quot;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (currentChar.charAt(<span class="number">0</span>) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; currentChar.charAt(<span class="number">0</span>) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">                    vals.push(Integer.parseInt(currentChar));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    vals.push(Integer.parseInt(Integer.toString(vals.pop()) + currentChar));</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                ops.push(currentChar);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot;+&quot;</span>) || currentChar.equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                <span class="keyword">if</span>(ops.isEmpty());</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(ops.peek().equals(<span class="string">&quot;+&quot;</span>) || ops.peek().equals(<span class="string">&quot;-&quot;</span>))&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> vals.pop();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">op</span> <span class="operator">=</span> ops.pop();</span><br><span class="line">                    <span class="keyword">if</span>(op.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                        x = vals.pop() + x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(op.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                        x = vals.pop() - x;</span><br><span class="line">                    vals.push(x);</span><br><span class="line">                &#125;</span><br><span class="line">                ops.push(currentChar);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (currentChar.equals(<span class="string">&quot;)&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">op</span> <span class="operator">=</span> ops.pop();</span><br><span class="line">                <span class="keyword">while</span> (!op.equals(<span class="string">&quot;(&quot;</span>)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> vals.pop();</span><br><span class="line">                    <span class="keyword">if</span> (op.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                        x = vals.pop() + x;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                        x = vals.pop() - x;</span><br><span class="line">                    vals.push(x);</span><br><span class="line">                    <span class="keyword">if</span> (!ops.isEmpty())</span><br><span class="line">                        op = ops.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">op</span> <span class="operator">=</span> ops.pop();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> vals.pop();</span><br><span class="line">            <span class="keyword">if</span> (op.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                x = vals.pop() + x;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                x = vals.pop() - x;</span><br><span class="line">            vals.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vals.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Java </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA String学习笔记</title>
      <link href="/2021/07/01/java/java-string-xue-xi-bi-ji/"/>
      <url>/2021/07/01/java/java-string-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<p>String是一种特殊的对象（不同于8种基本数据类型）。String类的特殊性可以它的两个其他的类不具有的特点体现出来<span id="more"></span></p><ul><li><p>在创建一个String对象的时候，我们不仅可以通过和其他类类似的创建方式，通过<code>new</code>的方式创建，我们也可以直接通过赋值创建<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">newStr1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;content&quot;</span>); <span class="comment">// 和其他对象类似的创建方式</span></span><br><span class="line"><span class="type">String</span> <span class="variable">newStr2</span> <span class="operator">=</span>  <span class="string">&quot;content&quot;</span>;</span><br><span class="line"><span class="comment">// String 特殊的创建方式</span></span><br></pre></td></tr></table></figure></p></li><li><p>String可以直接进行+运算，达到字符串连接的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;One String&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot; Another String&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> str3 + str4;</span><br><span class="line"><span class="comment">// str5 = &quot;One String Another String&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>另外一个需要注意的点：String可以为空，但是空字符串不代表<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str6</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str8</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">/* str6和str7一样,但和str8不一样 */</span></span><br></pre></td></tr></table></figure><p>String作为一个对象，具有一个对象应该具有基本元素。String的field都是private的，所以我们也不需要知道他们的具体内容。String提供的method可以帮助我们实现很多对String的操作</p><ul><li><p><code>char charAt(int i)</code> 返回String在第<span class="math inline">\(i\)</span>个位置的字符</p></li><li><p><code>int compareTo(String anotherString)</code>返回值是整型，它是先比较对应字符的大小(ASCII码顺序)，如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的<strong>差值</strong>，如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符做比较，以此类推,直至比较的字符或被比较的字符有一方结束。（<a href="https://www.runoob.com/java/java-string-compareto.html">菜鸟教程</a>）</p></li><li><p><code>String concat(String str)</code>和加法运算符相同的效果</p></li><li><p><code>int indexOf(int ch)</code><code>int indexOf(int ch, int fromIndex)</code><code>int indexOf(String str)</code><code>int indexOf(String str, int fromIndex)</code>返回String中出现的第一个相应的参数字符的下标，<code>fromIndex</code>表示从此处开始搜索。对应的有<code>int lastIndexOf(parameters)</code>表示最后一个出现的字符下标</p></li><li><p><code>boolean isEmpty()</code>判断一个String是否为空，若是返回true。</p></li><li><p><code>String replace(char oldChar, char newChar)</code>将原本的字符串中的所有<code>oldchar</code>用<code>newChar</code>代替，返回替换后的字符串</p></li><li><p><code>String[] split(String regex, int limit)</code>以<code>regex</code>为界限分割String得到一个数组。参数<code>int limit</code>(optional)表示分割的上限次数（以前limit-1的<code>regex</code>进行分割，共分成limit个String），limit&lt;=0表示无界限。</p><p>e.g. 在下面这种情况中，<code>|</code>被编译器默认认为是或运算符,所以我们需要用<code>"\\|"</code>进行区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s=“ABC|DEF|GHI”;</span><br><span class="line">s.split(“|”)</span><br><span class="line"><span class="comment">/*-&gt; [ “A”, “B”, “C”, “|”, “D”, “E”, “F”, “|”, “G”, “H”, “I”];*/</span></span><br><span class="line">String s=“ABC|DEF|GHI”;</span><br><span class="line">s.split(“\\|”);</span><br><span class="line"><span class="comment">/* -&gt; [ “ABC”, “DEF”, “GHI”]; */</span></span><br></pre></td></tr></table></figure></li><li><p><code>String substring(int beginIndex, int endIndex)</code>返回从<code>beginIndex</code>开始到<code>endIndex</code>（不包括）的substring。</p></li><li><p><code>String trim()</code> 返回消除了所有空格之后的字符串</p><ul><li>有关String更详细的方法可以参考<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/String.html">官方文档</a></li></ul></li></ul><p>String一旦被创建就不能再更改（注：<code>String.concat()</code>和运算符"+"都会创建一个新的String对象而不是在原来的String基础上进行更改），所以Java提供了另一个类来实现String的更改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuilder</span> <span class="variable">strbui</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;something &quot;</span>);</span><br><span class="line">strbui.append(<span class="string">&quot;another thing &quot;</span>);</span><br><span class="line"><span class="comment">// strbui: something another thing</span></span><br></pre></td></tr></table></figure><p>相比于<code>concat</code>和加法运算，使用StringBuilder的好处就是提高了效率</p><p>数字和字符串之间的转换</p><ul><li><p>Integer与String转化</p><ul><li><p><code>Integer.parseInt(str)</code>将<code>str</code>转化为对应的Integer</p></li><li><p>Integer转化为对应的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span> + <span class="number">123</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> Integer.toString(<span class="number">123</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> String.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Double与String转化</p><ul><li><p><code>Double.parseDouble(str)</code>将<code>str</code>转化为对应的Double</p></li><li><p>Double转化为String使用<code>String.valueOf(double d)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">11.01</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(d);</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java链表、栈、队列、哈希表、集合</title>
      <link href="/2021/07/01/java/java-lian-biao-zhan-dui-lie-ha-xi-biao-ji-he/"/>
      <url>/2021/07/01/java/java-lian-biao-zhan-dui-lie-ha-xi-biao-ji-he/</url>
      
        <content type="html"><![CDATA[<p>总结一下JAVA中常见的一些与数据结构有关的持有对象以及他们的常见的方法(并不是全部因为全部太多了orz)</p><span id="more"></span><h2><span id="列表-list">列表 List</span></h2><table><colgroup><col style="width: 52%"><col style="width: 47%"></colgroup><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td>在列表末尾添加元素</td></tr><tr><td><code>void add(int index, E e)</code></td><td>在指定的下标处添加元素</td></tr><tr><td><code>void clear()</code></td><td>清除列表中的所有元素</td></tr><tr><td><code>boolean contains(Object o)</code></td><td>判断列表中是否包含指定的元素</td></tr><tr><td><code>E get(int index)</code></td><td>返回指定下标出的元素</td></tr><tr><td><code>int indexOf(Object o)</code></td><td>返回指定元素的下标，如果列表中不存在返回-1</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断列表是否为空</td></tr><tr><td><code>E remove(int index)</code></td><td>删除指定下标处的元素</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>删除指定元素，如果不存在返回<code>false</code></td></tr><tr><td><code>E set(int index, E element)</code></td><td>将指定下标处的元素用新的元素代替</td></tr><tr><td><code>int size()</code></td><td>返回列表的大小</td></tr><tr><td><code>default void sort(Comparator&lt;? super E&gt; c)</code></td><td>对列表进行按照给定的Compartor的排序</td></tr><tr><td><code>Object[] toArray()</code></td><td>将列表转化为对应元素的一个数组</td></tr></tbody></table><h3><span id="列表与数组之间的相互转化">列表与数组之间的相互转化</span></h3><p>在实际使用中，数组和列表的相互转化也是经常需要用到的，奈何本人记性太差，老是记不住，印象中已经是查了N次了，果然好记性不如烂笔头，还是记一下吧，原文：<a href="https://blog.csdn.net/lpq374606827/article/details/93203927">JavaList和Array之间的转换</a></p><h4><span id="array-转为list">Array 转为List</span></h4><ol type="1"><li><p>实现方法 :java中数组转list使用Arrays.asList(T... a)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array2List</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        List&lt;String&gt; listA=Arrays.asList(<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;cow&quot;</span>);</span><br><span class="line">        String[] strs=&#123;<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;cow&quot;</span>&#125;;</span><br><span class="line">        List&lt;String&gt; listB= Arrays.asList(strs);</span><br><span class="line">        System.out.println(listA);</span><br><span class="line">        System.out.println(listB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意事项</p><p>1）<code>Arrays.asList()</code>方法返回的对象是Arrays的内部类，对list的操作仍然反映在原数组上，因此这个list是定长的，不支持add、remove操作；</p><p>2）由于<code>asList</code>方法接受的泛型参数，因此不能用于基本类型，只能使用如下方法：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array2List</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] a=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:a)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li></ol><h4><span id="list转为array">List转为Array</span></h4><ol type="1"><li><p>实现：使用<code>list.toArray()</code></p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Array2List</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        List&lt;String&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        list.add(<span class="string">&quot;cow&quot;</span>);</span><br><span class="line">        String[] animals=list.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(String animal:animals)&#123;</span><br><span class="line">            System.out.println(animal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li><li><p>注意事项</p><p>由于<code>list.toArray()</code>返回的是Object对象数组，如果我们想要转化为基本类型数组，比如说<code>List&lt;Integer&gt;</code>转化为<code>int[]</code>，那么可以使用<code>steam()</code>：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.stream().mapToInt(Integer::intValue).toArray();</span><br></pre></td></tr></table></figure></p></li></ol><h2><span id="双端队列-deque-1">双端队列 Deque [1]</span></h2><table><colgroup><col style="width: 3%"><col style="width: 24%"><col style="width: 24%"><col style="width: 23%"><col style="width: 23%"></colgroup><thead><tr><th></th><th>First Element (Head)</th><th></th><th><strong>Last Element (Tail)</strong></th><th></th></tr></thead><tbody><tr><td></td><td><em>Throws exception</em></td><td><em>Special value</em></td><td><em>Throws exception</em></td><td><em>Special value</em></td></tr><tr><td><strong>Insert</strong></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addFirst(E)"><code>addFirst(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#offerFirst(E)"><code>offerFirst(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addLast(E)"><code>addLast(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#offerLast(E)"><code>offerLast(e)</code></a></td></tr><tr><td><strong>Remove</strong></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pollFirst()"><code>pollFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeLast()"><code>removeLast()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pollLast()"><code>pollLast()</code></a></td></tr><tr><td><strong>Examine</strong></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getFirst()"><code>getFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peekFirst()"><code>peekFirst()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getLast()"><code>getLast()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peekLast()"><code>peekLast()</code></a></td></tr></tbody></table><table><colgroup><col style="width: 47%"><col style="width: 52%"></colgroup><thead><tr><th><strong><code>Queue</code> Method</strong></th><th><strong>Equivalent <code>Deque</code> Method</strong></th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#add(E)"><code>add(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addLast(E)"><code>addLast(e)</code></a></td></tr><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#offer(E)"><code>offer(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#offerLast(E)"><code>offerLast(e)</code></a></td></tr><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#remove()"><code>remove()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td></tr><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#poll()"><code>poll()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pollFirst()"><code>pollFirst()</code></a></td></tr><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#element()"><code>element()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#getFirst()"><code>getFirst()</code></a></td></tr><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html#peek()"><code>peek()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peek()"><code>peekFirst()</code></a></td></tr></tbody></table><table><colgroup><col style="width: 46%"><col style="width: 53%"></colgroup><thead><tr><th><strong>Stack Method</strong></th><th><strong>Equivalent <code>Deque</code> Method</strong></th></tr></thead><tbody><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#push(E)"><code>push(e)</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#addFirst(E)"><code>addFirst(e)</code></a></td></tr><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#pop()"><code>pop()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#removeFirst()"><code>removeFirst()</code></a></td></tr><tr><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peek()"><code>peek()</code></a></td><td><a href="https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html#peekFirst()"><code>peekFirst()</code></a></td></tr></tbody></table><h3><span id="arraylist">ArrayList</span></h3><p>ArrayList是List接口的可变数组实现，所有的方法和List基本一致。时间复杂度方面，增的时间复杂度均摊下来是常数的，但是几乎其他的操作都是线性时间复杂度，优点是常数因子相比于LinkedList来说比较小。</p><table><colgroup><col style="width: 44%"><col style="width: 55%"></colgroup><thead><tr><th>特有的方法</th><th>作用</th></tr></thead><tbody><tr><td><code>void ensureCapcity(int minCapacity)</code></td><td>将动态数组进行扩容，确保列表能够容纳给定的最小容量</td></tr><tr><td><code>void trimToSize()</code></td><td>将动态数组的容量调整为数组中的元素个数</td></tr></tbody></table><h3><span id="linkedlist">LinkedList</span></h3><p>LinkedList是List接口和Deque接口的双向链表实现，所拥有的方法为List接口和Deque接口的集合。链表实现使得增、删时间复杂度为O(1)，但是没有了ArrayList中的索引机制，导致对于特定位置的元素查询时间复杂度为O(n)。</p><h2><span id="图-map-键值对">图 Map （键值对）</span></h2><table><colgroup><col style="width: 39%"><col style="width: 60%"></colgroup><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>void clear()</code></td><td>清除图中所有的元素</td></tr><tr><td><code>boolean containsKey(Object key)</code></td><td>判断是否包含我们给定键的键值对</td></tr><tr><td><code>boolean containsValue(Object value)</code></td><td>判断是否包含我们给定值的键值对</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td>返回Map的集合(Set)视图</td></tr><tr><td><code>V get (Object key)</code></td><td>返回给定键的对应值，若不存在，返回null</td></tr><tr><td><code>default V getOrDefault(Object key, V defaultValue)</code></td><td>返回给定键的对应值，若不存在，返回设定的默认值</td></tr><tr><td><code>boolean isEmpty()</code></td><td>判断Map是否为空</td></tr><tr><td><code>Set&lt;K&gt; keySet()</code></td><td>返回Map中键的集合(Set)视图</td></tr><tr><td><code>V put(K key, V value)</code></td><td>将给定的键值对插入到Map中，若已经存在对应的key，则替换value，返回旧的value，若不存在，返回null</td></tr><tr><td><code>default V putIfAbsent(K key, V value)</code></td><td>如果不存在给定的键的键值对，则插入，否则，返回当前键对应的值</td></tr><tr><td><code>V remove(Object key)</code></td><td>删除给定键的键值对</td></tr><tr><td><code>default boolean remove(Object key, Object value)</code></td><td>删除给定的键值对，返回是否删除成功</td></tr><tr><td><code>default V replace(K key, V value)</code></td><td>如果存在给定键的键值对，替换键的当前值为给定的新值</td></tr><tr><td><code>default boolean replace(K key, V oldValue, V newValue)</code></td><td>如果存在给定键值对，替换给定键值对中的值为新值，返回是否替换成功</td></tr><tr><td><code>int size()</code></td><td>返回Map中的键值对数目</td></tr></tbody></table><h3><span id="hashmap和hashtable">HashMap和Hashtable</span></h3><p>Map接口的哈希表实现，HashMap基本与Hashtable相同，除了HashMap是异步的并且允许nullkey。时间复杂度方面，对于基本的增查操作 (get andput)，HashMap可以达到常数的时间复杂度。关于HashMap和Hashtable的区分，详情可以参考这一篇博文<a href="https://www.cnblogs.com/lchzls/p/6714335.html">2</a></p><p>构造器Constructor：initialCapcacity和loadFactor影响HashMap的性能。当当前的entry数量超过loadFactor和当前容量的乘积，哈希表就会被rehash，扩容至原来的两倍[3]。默认情况下initialCapacity为16，loadFactor为0.75，这样的情况下性能是比较好的。</p><table><colgroup><col style="width: 100%"></colgroup><thead><tr><th>构造器 Constructor</th></tr></thead><tbody><tr><td>HashMap(): 默认的initialCapacity为16，loadFactor为0.75</td></tr><tr><td>HashMap(int initialCapacity)：设定初始化容量</td></tr><tr><td>HashMap(int initialCapacity, floatloadFactor)：设定初始化容量和负载系数</td></tr></tbody></table><h3><span id="treemap">TreeMap</span></h3><p>NavigableMap接口的红黑树实现，具有排序的能力，默认情况对键值的进行默认的排序，也可以指定Comparator进行排序。TreeMap与普通的Map不同的方法在于一些和键值顺序有关的函数，下面简要列举一下</p><table><colgroup><col style="width: 47%"><col style="width: 52%"></colgroup><thead><tr><th>方法</th><th>作用</th></tr></thead><tbody><tr><td><code>Map.Entry&lt;K,V&gt; ceilingEntry(K key)</code></td><td>最小的键大于等于给定值的键值对</td></tr><tr><td><code>K ceilingKey(K key)</code></td><td>最小的大于等于给定值的键</td></tr><tr><td><code>NavigableSet&lt;K&gt; descendingKeySet()</code></td><td>降序排列的键集合</td></tr><tr><td><code>NavigableMap&lt;K,V&gt; descendingMap()</code></td><td>按键降序排列的Map</td></tr><tr><td><code>Map.Entry&lt;K,V&gt; firstEntry()</code></td><td>键最小的键值对</td></tr><tr><td><code>K firstKey()</code></td><td>最小的键</td></tr><tr><td><code>Map.Entry&lt;K,v&gt; floorEntry(K key)</code></td><td>最大的键小于等于给定值的键值对</td></tr><tr><td><code>K floorKey(K key)</code></td><td>最大的小于等于给定值的键</td></tr><tr><td><code>SortedMap&lt;K,V&gt; headMap(K toKey)</code></td><td>返回小于给定键的所有键值对的一个map</td></tr><tr><td><code>NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)</code></td><td>返回小于（或等于）给定键的所有键值对的一个map，如果没有则返回null</td></tr><tr><td><code>Map.Entry&lt;K,V&gt; higherEntry(K key)</code></td><td>最小的键严格大于给定键的键值对</td></tr><tr><td><code>K higherKey(K key)</code></td><td>最小的严格大于给定键的键值对</td></tr><tr><td><code>Map.Entry&lt;K,V&gt; lastEntry()</code></td><td>键最大的键值对</td></tr><tr><td><code>K lastKey()</code></td><td>最大的键</td></tr><tr><td><code>Map.Entry&lt;K,V&gt; lowerEntry(K key)</code></td><td>最大的键严格小于给定键的键值对</td></tr><tr><td><code>K lowerKey(K key)</code></td><td>最大的严格小于给定键的键值对</td></tr><tr><td><code>Map.Entry&lt;K,V&gt;   pollFirstEntry()</code></td><td>删除并返回键最小的键值对</td></tr><tr><td><code>Map.Entry&lt;K,V&gt;   pollLastEntry()</code></td><td>删除并返回键最大的键值对</td></tr><tr><td><code>SortedMap&lt;K,V&gt; headMap(K toKey)</code></td><td>返回大于等于给定键的所有键值对的一个map</td></tr><tr><td><code>NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive)</code></td><td>返回大于（或等于）给定键的所有键值对的一个map，如果没有则返回null</td></tr></tbody></table><h2><span id="集合-set-接口">集合 Set 接口</span></h2><p>集合的方法就比较简单了，基本上都是之前的一些简单重复，简单列举一下</p><table><colgroup><col style="width: 35%"><col style="width: 27%"><col style="width: 37%"></colgroup><thead><tr><th>方法</th><th>方法</th><th>方法</th></tr></thead><tbody><tr><td><code>boolean add(E e)</code></td><td><code>void clear()</code></td><td><code>boolean contains(Object o)</code></td></tr><tr><td><code>boolean equals(Object o)</code></td><td><code>boolean isEmpty()</code></td><td><code>boolean remove(Object o)</code></td></tr><tr><td><code>int size()</code></td><td><code>Object[] toArray()</code></td><td></td></tr></tbody></table><p>常用的集合类有HashSet（基于HashMap实现）以及它的子类LinkedHashSet。</p><h2><span id="参考资料">参考资料</span></h2><p>[1] <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Deque.html">Deque(Java Platform SE 8 ) (oracle.com)</a></p><p>[2] <a href="https://www.cnblogs.com/lchzls/p/6714335.html">JAVA中HashMap和Hashtable区别- 知我者，足以 - 博客园 (cnblogs.com)</a></p><p>[3] <a href="https://www.cnblogs.com/crelle/p/13657214.html">HashMap中的InitialCapacity和Load Factory - 我要去巴萨 - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL问题:Temporary failure resolving &#39;&#39;archive.ubuntu.com&#39;&#39;</title>
      <link href="/2021/06/29/bug/bugwsl-wen-ti-temporary-failure-resolving-archive-ubuntu-com/"/>
      <url>/2021/06/29/bug/bugwsl-wen-ti-temporary-failure-resolving-archive-ubuntu-com/</url>
      
        <content type="html"><![CDATA[<p>今天在WSL进行操作的时候，发现从网络上下载东西无法成功，包括wget、apt-get 等命令都无法正常使用，比如执行sudo apt-get update的时候会提示</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Err:1 http://security.ubuntu.com/ubuntu bionic-security InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;security.ubuntu.com&#x27;</span></span><br><span class="line">Err:2 http://archive.ubuntu.com/ubuntu bionic InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">Err:3 http://archive.ubuntu.com/ubuntu bionic-updates InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">Err:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease</span><br><span class="line">  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">Reading package lists... Done</span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic/InRelease  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic-updates/InRelease  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic-backports/InRelease  Temporary failure resolving <span class="string">&#x27;archive.ubuntu.com&#x27;</span></span><br><span class="line">W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/bionic-security/InRelease  Temporary failure resolving <span class="string">&#x27;security.ubuntu.com&#x27;</span></span><br><span class="line">W: Some index files failed to download. They have been ignored, or old ones used instead.</span><br></pre></td></tr></table></figure><p>经过查询和搜索（解决bug真的痛苦😫），发现通过一下几行命令可以解决</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> /etc/resolv.conf</span><br><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&#x27;echo &quot;nameserver 8.8.8.8&quot; &gt; /etc/resolv.conf&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&#x27;echo &quot;[network]&quot; &gt; /etc/wsl.conf&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> bash -c <span class="string">&#x27;echo &quot;generateResolvConf = false&quot; &gt;&gt; /etc/wsl.conf&#x27;</span></span><br><span class="line"><span class="built_in">sudo</span> chattr +i /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>接下来下载东西就都没有问题了。</p><blockquote><p>2021.11.20补充：今天又碰到这个问题了，这次是ssh的时候无法解析hostname，</p><p>又get到了一种新的解决办法：</p><p>直接在/etc/resolv.conf中加入dns服务器地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nameserver 202.96.134.133</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>然后重新启动wsl就可以了</p></blockquote><p>参考资料:</p><p><a href="https://github.com/microsoft/WSL/issues/5420#issuecomment-646479747">Github上的一个issue</a></p><p><a href="https://blog.csdn.net/weixin_38204723/article/details/78316940">ubuntuapt-get 错误 Temporary failure resolving 'us.archive.ubuntu.com'解决</a></p>]]></content>
      
      
      <categories>
          
          <category> Bug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bug </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS EC2上部署PostgreSQL + TimeScaleDB</title>
      <link href="/2021/06/29/backend/aws-ec2-shang-bu-shu-postgresql-timescaledb/"/>
      <url>/2021/06/29/backend/aws-ec2-shang-bu-shu-postgresql-timescaledb/</url>
      
        <content type="html"><![CDATA[<h4><span id="在ec2上部署postgresqltimescaledb">在EC2上部署PostgreSQL+TimescaleDB</span></h4><p>首先，创建一个Ubuntu实例，使用ssh连接到这个服务器上（使用WSL进行连接可以看这一篇博文<a href="https://lucas-hao.github.io/2021/06/29/aws-ec2-shang-chuang-jian-yi-ge-ubuntu-instance-bing-shi-yong-wsl-lian-jie/">AWSEC2上创建一个Ubuntu Instance并使用WSL连接)</a>）。连接好之后，就可以按照<a href="https://docs.timescale.com/timescaledb/latest/how-to-guides/install-timescaledb/self-hosted/ubuntu/installation-apt-ubuntu/#apt-installation-ubuntu">Timescale文档</a>，进行PostgreSQL+TimeScaleDB的安装和部署了。</p><span id="more"></span><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `lsb_release -c -s` should return the correct codename of your OS</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;deb &lt;http://apt.postgresql.org/pub/repos/apt/&gt; <span class="subst">$(lsb_release -c -s)</span>-pgdg main&quot;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/pgdg.list</span><br><span class="line">wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | <span class="built_in">sudo</span> apt-key add -</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add our PPA</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:timescale/timescaledb-ppa</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now install appropriate package for PG version</span></span><br><span class="line"><span class="built_in">sudo</span> apt install timescaledb-2-postgresql-13</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> timescaledb-tune (y/y/n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Restart PostgreSQL instance</span></span><br><span class="line"><span class="built_in">sudo</span> service postgresql restart</span><br></pre></td></tr></table></figure><p>按照以上步骤操作完成之后，PostgreSQL就已经安装成功了。可以通过<code>psql --version</code>查看PostgreSQL版本信息。接下来，为了让我们的PostgreSQL被远程访问，我们需要对它进行配置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nano /etc/postgresql/13/main/postgresql.conf</span><br></pre></td></tr></table></figure><p>打开配置文件，找到</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#listen_addresses = &#x27;localhost&#x27;</span></span><br></pre></td></tr></table></figure><p>去掉注释，修改为（这样修改允许数据库能够监听所有的地址）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = &#x27;*&#x27;</span><br></pre></td></tr></table></figure><p>接下来打开另外一个配置文件进行修改</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo nano /etc/postgresql/13/main/pg_hba.conf</span><br></pre></td></tr></table></figure><p>找到最后几行，修改为如下样式，这样修改是为了能够远程访问到数据库。</p><figure><img src="https://i.loli.net/2021/07/16/LH8432jpWqN5GAh.png" alt="pg_hba-conf"><figcaption aria-hidden="true">pg_hba-conf</figcaption></figure><p>然后重新启动PostgreSQL服务<code>sudo service postgresql restart</code>，配置完成之后，输入命令<code>sudo -u postgres psql postgres</code>使用postgreSQL默认的用户postgres进入数据库，使用<code>\password</code>设置密码，然后就可以正常使用数据库了。</p><h4><span id="使用pgadmin连接">使用pgAdmin连接</span></h4><p>打开pgAdmin，右键Servers→Create→Server...，和正常连接到数据库一样，首先给一个命名，然后在Connection中，和在本地连接数据库一样，填写相关的信息，密码就是云端上数据库的密码。</p><figure><img src="https://i.loli.net/2021/07/16/zNyjnduafTb4cP8.png" alt="pgAdmin-connection"><figcaption aria-hidden="true">pgAdmin-connection</figcaption></figure><p>然后，在SSH Tunnel中，在Tunnel host输入AWS EC2实例的public IPv4DNS，Tunnelport填22，username就是服务器的用户名，Ubuntu服务器的默认用户名就是ubuntu。Authentication选择Identityfile，然后Identity file一栏选中之前下载的密钥对</p><figure><img src="https://i.loli.net/2021/07/16/PMASp6fxsUlZNXw.png" alt="pgAdmin-SSH"><figcaption aria-hidden="true">pgAdmin-SSH</figcaption></figure><p>点击Save按钮就可以成功连接。</p><h4><span id="命令行远程连接数据库">命令行远程连接数据库</span></h4><p>默认情况下，AWSEC2开放的端口只有SSH默认的端口22，但是我们想要远程访问的是PostgreSQL的端口5432，所以在默认情况下，我们无法远程访问PostgreSQL数据库。在我们输入命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres://username:password@hostname:port/dbname</span><br></pre></td></tr></table></figure><p>之后，就会得到报错信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">psql: 错误: 无法联接到服务器: Connection timed out (0x0000274C/10060)</span><br><span class="line">        服务器是否在主机 <span class="string">&quot;hostname&quot;</span> 上运行并且准备接受在端口</span><br><span class="line">5432 上的 TCP/IP 联接?</span><br></pre></td></tr></table></figure><p>这个错误信息就提示我们需要打开AWSEC2数据库中的5432端口，我们才可以对数据库进行远程访问。首先，我们需要打开EC2控制台，然后打开SecurityGroups (安全组)，选中一个安全组，然后进入Actions下的Edit inbound rules(编辑入站规则)。</p><figure><img src="https://i.loli.net/2021/07/16/1LodksGSKBmIMgt.png" alt="edit-bound-rules"><figcaption aria-hidden="true">edit-bound-rules</figcaption></figure><p>默认情况下只有一个类型为SSH的规则，点击Addrule，类型选择PostgreSQL，点击Save rules保存即可。</p><figure><img src="https://i.loli.net/2021/07/16/7fHB4xqA51uR9lE.png" alt="inbound-rules"><figcaption aria-hidden="true">inbound-rules</figcaption></figure><p>然后我们直接在命令行中使用命令就可以进行连接啦</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psql postgres://postgres:yourpassword@ec2-34-200-222-92.compute-1.amazonaws.com:5432/postgres</span><br></pre></td></tr></table></figure><p>同样的，我们可以使用Java中的jdbc连接数据库</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String... args)</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="type">String</span> <span class="variable">connUrl</span> <span class="operator">=</span> <span class="string">&quot;jdbc:postgresql://ec2-34-200-222-92.compute-1.amazonaws.com:5432/postgres?user=postgres&amp;password=yourpassword&quot;</span>;</span><br><span class="line">      <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DriverManager.getConnection(connUrl)) &#123;</span><br><span class="line">          System.out.println(conn.getClientInfo());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">          System.err.println(<span class="string">&quot;SQLState: &quot;</span> + ex.getSQLState() +  <span class="string">&quot;\\t&quot;</span> + ex.getMessage());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>显示结果</p><blockquote><p>{ApplicationName=PostgreSQL JDBC Driver}</p></blockquote><p>成功连接！</p>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AWS EC2上创建一个Ubuntu Instance 并使用WSL连接</title>
      <link href="/2021/06/29/backend/aws-ec2-shang-chuang-jian-yi-ge-ubuntu-instance-bing-shi-yong-wsl-lian-jie/"/>
      <url>/2021/06/29/backend/aws-ec2-shang-chuang-jian-yi-ge-ubuntu-instance-bing-shi-yong-wsl-lian-jie/</url>
      
        <content type="html"><![CDATA[<h4><span id="在aws-ec2上部署ubuntu">在AWS EC2上部署Ubuntu</span></h4><ol type="1"><li><p>登录AWS，进入EC2 Dashboard，点击Launch instance来新建一个实例。<img src="https://i.loli.net/2021/07/16/XOg3CIUzjirtlhw.png" alt="Ubuntu-lauch-instance"></p><p><span id="more"></span></p></li><li><p>选择AMI，这里我选择了Ubuntu 20.04 <img src="https://i.loli.net/2021/07/16/ClQOwTNs6BJj13m.png" alt="choose-ami"></p></li><li><p>选择想要的InstanceType，可以根据自己的实际需求进行选择，如果是进行学习的话，AWS对于第一次注册的用户在12个月内提供免费的套餐，如果我没有记错的话应该是t2.micro。选择好之后，默认情况下我们直接点击Reviewand Launch。 <img src="https://i.loli.net/2021/07/16/ObrBC8DadxVcq3e.png"></p></li><li><p>之后页面上会显示创建的实例的一些信息，如果有需要改变的地方，可以这里进行改变。在这里，由于我的目的是为这一个实例上部署一个PostgreSQL数据库，然后从远程访问这个数据库，所以我需要对SecurityGroups进行一些设置和修改，详情可以看这一篇博文<a href="https://lucas-hao.github.io/2021/06/29/aws-ec2-shang-bu-shu-postgresql-timescaledb/#more">AWSEC2上部署PostgreSQL + TimeScaleDB)</a>。 <img src="https://i.loli.net/2021/07/16/GmKzbHiEfoO6CJs.png" alt="review-instance-launch"></p></li><li><p>设置完成之后点击Launch，跳出如下页面，我们需要选择或者创建一个密钥对</p><p><img src="https://i.loli.net/2021/07/16/XZeKmCSxHiFzoTD.png" alt="key-pair">输入密钥对的名字之后，我们将这个密钥对下载到我们的电脑里面，这个密钥对一定要保存好，因为我们需要这个密钥对远程通过SSH连接这个服务器。然后点击LaunchInstances就成功在EC2上部署了一个Ubuntu的实例。</p></li></ol><h4><span id="使用wsl进行服务器远程访问">使用WSL进行服务器远程访问</span></h4><p>首先要确保Windows上安装了WSL和Linux子系统。想要连接到EC2，首先要将下载到Windows中的密钥对文件复制到WSL中的路径中，有两种方式：</p><ol type="1"><li><p>使用命令行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> /mnt/&lt;Windows drive letter&gt;/path/my-key-pair.pem ~/WSL-path/my-key-pair.pem</span><br></pre></td></tr></table></figure><p>注：Windows本地的文件夹可以在WSL下的mnt文件夹中进行访问</p></li><li><p>可以在Windows中的文件管理器中直接在地址栏中输入<code>\\wsl$</code>可以在网络中打开WSL的文件管理，然后直接将密钥对复制到对应的路径下就可以了。</p></li></ol><p>这个时候，还需要将密钥对的权限更改一下，否则的话由于我们没有对密钥对进行权限设置，直接连接的话就会报错。<img src="https://i.loli.net/2021/07/16/wB8JRmPL5ldi2AD.png" alt="wsl-warning"></p><p>通过命令<code>chmod 400 filename.pem</code>更改文件权限，这个问题就能够解决了。接下来，我们就可以通过命令行命令连接到EC2上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i /path/my-key-pair.pem my-instance-user-name@my-instance-public-dns-name</span><br></pre></td></tr></table></figure><p>以下为参数的解释</p><ol type="1"><li><p>/path/my-key-pair.pem 当然就是密钥对所在的路径了</p></li><li><p>my-instance-user-name就是所创建的EC2实例的用户名，下面是默认的用户名</p><p>对于 Amazon Linux 2 或 Amazon Linux AMI，用户名称是 ec2-user。</p><p>对于 CentOS AMI，用户名称是 centos。</p><p>对于 Debian AMI，用户名称是 admin。</p><p>对于 Fedora AMI，用户名为 ec2-user 或 fedora。</p><p>对于 RHEL AMI，用户名称是 ec2-user 或 root。</p><p>对于 SUSE AMI，用户名称是 ec2-user 或 root。</p><p>对于 Ubuntu AMI，用户名称是 ubuntu。</p></li><li><p>my-instance-public-dns-name 是创建的EC2实例的public IPv4DNS，在AWS EC2Dashboard中打开实例就可以找到，如果没有找到，那么在右上角的设置中打开显示即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AWS </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android获取应用使用时长和次数-UsageStatsManager使用</title>
      <link href="/2021/06/02/android/android-huo-qu-ying-yong-shi-yong-shi-chang-he-ci-shu-usagestatsmanager-shi-yong/"/>
      <url>/2021/06/02/android/android-huo-qu-ying-yong-shi-yong-shi-chang-he-ci-shu-usagestatsmanager-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>最近在做暑研，要求是需要获取到Android手机中的应用使用情况，经过查找，发现Android提供了<code>UsageStatsManager</code>类来帮助进行应用使用信息的统计（注明，Android5.0系统大部分手机不支持这个类，Android5.1系统之后完全支持[1],显然现在大部分手机都是支持的），这篇文章主要记录一下这个类的使用方法。</p><span id="more"></span><h4><span id="授权">授权</span></h4><p>想要使用这个类来获取应用使用信息，首先需要对app进行授权，我们需要在AndroidManifest.xml文件中加入<code>uses-permission</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;android.permission.PACKAGE_USAGE_STATS&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:ignore</span>=<span class="string">&quot;ProtectedPermissions&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要我们在设置-安全-更多安全设置-使用情况访问权限中给对应的app打开使用权限（华为p30pro）。我们在代码中也可以进行判断，主动要求用户打开该设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先判断获取到的list是否为空 if (packageInfoList == null)</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        startActivity(<span class="keyword">new</span> <span class="title class_">Intent</span>(Settings.ACTION_USAGE_ACCESS_SETTINGS));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Toast.makeText(MainActivity.<span class="built_in">this</span>,<span class="string">&quot;无法开启允许查看使用情况的应用界面&quot;</span>,Toast.LENGTH_LONG).show();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="对象初始化">对象初始化</span></h4><p>初始化<code>UsageStatsManager</code>类我们需要以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">UsageStatsManager</span> <span class="variable">usm</span> <span class="operator">=</span> (UsageStatsManager)getSystemService(Context.USAGE_STATS_SERVICE);</span><br></pre></td></tr></table></figure><h4><span id="获取usagestats">获取UsageStats</span></h4><p><code>UsageStatsManager</code>提供了一些方法让我们获取应用的<code>UsageStats</code>，比如<code>Map&lt;String, UsageStats&gt; queryAndAggregateUsageStats(long beginTime, long endTime)</code>和<code>List&lt;EventsStats&gt; queryEventStats(int intervalType, long beginTime, long endTime)</code>，通过传入开始时间，结束时间和一个间隔类型(intervalType)来获取在一定时间范围内的<code>UsageStats</code>列表。其中，Android给了以下几种intervalType</p><table><colgroup><col style="width: 26%"><col style="width: 73%"></colgroup><thead><tr><th>Constants</th><th>Meaning</th></tr></thead><tbody><tr><td><code>int INTERVAL_DAILY</code></td><td>An interval type that spans a day.</td></tr><tr><td><code>int INTERVAL_MONTHLY</code></td><td>An interval type that spans a month.</td></tr><tr><td><code>int INTERVAL_WEEKLY</code></td><td>An interval type that spans a week.</td></tr><tr><td><code>int INTERVAL_YEARLY</code></td><td>An interval type that spans a year.</td></tr><tr><td><code>int INTERVAL_BEST</code></td><td>An interval type that will use the best fit interval for the giventime range.</td></tr></tbody></table><p><code>queryAndAggregateUsageStats</code>默认的间隔类型是<code>INTERVAL_BEST</code>。</p><p>下面的图片代表了我们传入的时间和我们的间隔类型结合应该得到的时间范围，需要注意的是，<strong>我们传入的beginTime和endTime不完全是系统获取app信息的开始和结束时间，beginTime和endTime是包含在开始和结束时间之中</strong>，也就是说，如果我们的间隔类型设置为<code>INTERVAL_DAILY</code>，我们获取的使用信息的开始时间可能是beginTime的当天0时，结束时间可能是endTime的当天23:59，这个时间具体还和时区相关，所以具体情况需要视实际情况而定，更详细的解析可以看这一篇[2]<a href="https://blog.csdn.net/liuwan1992/article/details/83625520">关于UsageStatsManager.queryUsageStats 的注意事项及 UsageStatsService的简单原理_菜鸟的自我修养-CSDN博客</a>。</p><figure><img src="https://i.loli.net/2021/06/02/qDJ56Ld182YUrof.png" alt="image-20210602210207843"><figcaption aria-hidden="true">image-20210602210207843</figcaption></figure><h4><span id="获取应用名应用包名使用时长">获取应用名，应用包名，使用时长</span></h4><p>我们可以通过<code>UsageStats.getPackageName()</code>这个方法来获取应用的包名，通过<code>UsageStats.getTotalTimeInForeground()</code>这个方法获取应用在前台的使用时间。</p><p>获取应用的名字我们需要用到<code>PackageManger</code>中的<code>getApplcationLabel(ApplicationInfo info)</code>这个方法，获取<code>ApplicationInfo</code>可以使用<code>getApplicationInfo(String packageName, int flags)</code>这个方法，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">getApplicationNameByPackageName</span><span class="params">(Context context, String packageName)</span> &#123;</span><br><span class="line">    <span class="type">PackageManager</span> <span class="variable">pm</span> <span class="operator">=</span> context.getPackageManager();</span><br><span class="line">    String Name;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Name = pm.getApplicationLabel(pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA)).toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        Name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="获取应用使用次数">获取应用使用次数</span></h4><p>至于应用使用次数，通过查询发现<code>UsageStats</code>中有<code>mLauchCount</code>这个变量，但是Android没有提供对应的get方法，所以我们就需要用反射来获取使用次数[3]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用反射，获取UsageStats中统计的应用使用次数</span></span><br><span class="line"><span class="meta">@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getLaunchCount</span><span class="params">(UsageStats usageStats)</span> <span class="keyword">throws</span> IllegalAccessException &#123;</span><br><span class="line">    <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        field = usageStats.getClass().getDeclaredField(<span class="string">&quot;mLaunchCount&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;getLaunchCount: NoSuchFieldException&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;getLaunchCount: &quot;</span> + <span class="string">&quot;Package Name: &quot;</span> + usageStats.getPackageName() +</span><br><span class="line">          <span class="string">&quot;\t&quot;</span> + (<span class="type">int</span>) field.get(usageStats));</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) field.get(usageStats);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际使用下来的情况发现，得到的数据可能为0，原因不知道为什么，所以还可以通过一种较为复杂的方法进行实现。通过<code>UsageStatsManager.queryEvents(long beginTime, long endTime)</code>获取Android提供的另一个类<code>UsageEvents</code>，遍历可以获取到所有的events，通过<code>getEventType()</code>方法可以得到对应的eventtype，其中<code>ACTIVITY_PAUSED</code>和<code>ACTIVITY_RESUMED</code>分别代表了活动移动到了后台和移动到前台，可以通过这两个活动的次数来计算出应用使用次数。详细代码可以参考[3]<a href="https://blog.csdn.net/github_37271067/article/details/85292543">android统计手机应用使用时长以及开启次数_github_37271067的博客-CSDN博客</a>。</p><h4><span id="参考资料">参考资料</span></h4><p>[1] <a href="https://mp.weixin.qq.com/s?__biz=MzI0NDYzMzg0OQ==&amp;mid=2247483683&amp;idx=1&amp;sn=1cceed0d62a5fbfcc373d5ec45370ed9&amp;chksm=e95b98b5de2c11a37c180d231633245e94c9ede239dbdfcca769afe09f1461e6d995c81241ec#rd作者：唐码农链接：https://www.jianshu.com/p/f88b6a9f7462来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。">Android5.0以上通过UsageStatsManager类 获取应用使用情况（精品） (qq.com)</a></p><p>[2] <a href="https://blog.csdn.net/liuwan1992/article/details/83625520">关于UsageStatsManager.queryUsageStats 的注意事项及 UsageStatsService的简单原理_菜鸟的自我修养-CSDN博客</a></p><p>[3] <a href="https://blog.csdn.net/github_37271067/article/details/85292543">android统计手机应用使用时长以及开启次数_github_37271067的博客-CSDN博客</a></p><p>[4] <a href="https://developer.android.com/reference">GoogleDevelopers</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言哈希表uthash的使用</title>
      <link href="/2021/05/16/algorithms/c-yu-yan-ha-xi-biao-uthash-de-shi-yong/"/>
      <url>/2021/05/16/algorithms/c-yu-yan-ha-xi-biao-uthash-de-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>C语言的标准库中没有哈希表的函数可以使用，但是可以通过第三方头文件<code>uthash.h</code>这个包来实现哈希表的操作。首先，想要使用这个包，可以访问它的github网站https://github.com/troydhanson/uthash下载<code>uthash.h</code>文件。</p><span id="more"></span><h2><span id="使用说明">使用说明</span></h2><p>在你的程序中，首先需要定义一个结构体 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>需要注意的是，当你添加一个结构体变量到哈希表中时，这个结构体不会被复制或者移动到其他地址，所以你还是可以在程序的生命周期中安全的指向这个结构体变量的地址。每一个这样的结构体由一个id(被当作键值使用)，一个要储存的变量，和一个<code>UT_hash_handle</code>变量。<code>UT_hash_handle</code>是非常重要的变量，它是这个结构体能够实现哈希表操作的关键。</p><p>然后需要定义一个全局的<code>my_struct</code>变量 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span> <span class="comment">/* important! initialize to NULL */</span></span><br></pre></td></tr></table></figure></p><h4><span id="添加元素">添加元素</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(<span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      s = (<span class="keyword">struct</span> my_struct *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *s);</span><br><span class="line">      s-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(users, id, s);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里通过<code>HASH_FIND_INT</code>首先确定当前id的唯一性，然后再通过<code>HASH_ADD_INT</code>添加元素。如果当前元素已经存在，那么修改它储存的元素值。</p><h4><span id="查找元素">查找元素</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> my_struct *<span class="title function_">find_user</span><span class="params">(<span class="type">int</span> user_id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* s: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="删除元素">删除元素</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_user</span><span class="params">(<span class="keyword">struct</span> my_struct *user)</span> &#123;</span><br><span class="line">    HASH_DEL(users, user);  <span class="comment">/* user: pointer to deletee */</span></span><br><span class="line">    <span class="built_in">free</span>(user);             <span class="comment">/* optional; it&#x27;s up to you! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="清空表">清空表</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete_all</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">current_user</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">  HASH_ITER(hh, users, current_user, tmp) &#123;</span><br><span class="line">    HASH_DEL(users, current_user);  <span class="comment">/* delete; users advances to next */</span></span><br><span class="line">    <span class="built_in">free</span>(current_user);             <span class="comment">/* optional- if you want to free  */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="计算元素个数">计算元素个数</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num_users;</span><br><span class="line">num_users = HASH_COUNT(users);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;there are %u users\n&quot;</span>, num_users);</span><br></pre></td></tr></table></figure><h4><span id="遍历打印所有元素">遍历打印所有元素</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print_users</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (s = users; s != <span class="literal">NULL</span>; s = s-&gt;hh.next) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;user id %d: name %s\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="排序">排序</span></h4><ol type="1"><li>通过id排序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">name_sort</span><span class="params">(<span class="keyword">struct</span> my_struct *a, <span class="keyword">struct</span> my_struct *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;name, b-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_by_name</span><span class="params">()</span> &#123;</span><br><span class="line">    HASH_SORT(users, name_sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>通过键值排序 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">id_sort</span><span class="params">(<span class="keyword">struct</span> my_struct *a, <span class="keyword">struct</span> my_struct *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a-&gt;id - b-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_by_id</span><span class="params">()</span> &#123;</span><br><span class="line">    HASH_SORT(users, id_sort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2><span id="完整的例子">完整的例子</span></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>   <span class="comment">/* gets */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span>  <span class="comment">/* atoi, malloc */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span>  <span class="comment">/* strcpy */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;uthash.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> id;                    <span class="comment">/* key */</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    UT_hash_handle hh;         <span class="comment">/* makes this structure hashable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">users</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">add_user</span><span class="params">(<span class="type">int</span> user_id, <span class="type">char</span> *name)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* id already in the hash? */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">      s = (<span class="keyword">struct</span> my_struct *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span> *s);</span><br><span class="line">      s-&gt;id = user_id;</span><br><span class="line">      HASH_ADD_INT(users, id, s);  <span class="comment">/* id: name of key field */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcpy</span>(s-&gt;name, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> my_struct *<span class="title function_">find_user</span><span class="params">(<span class="type">int</span> user_id)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    HASH_FIND_INT(users, &amp;user_id, s);  <span class="comment">/* s: output pointer */</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_user</span><span class="params">(<span class="keyword">struct</span> my_struct *user)</span> &#123;</span><br><span class="line">    HASH_DEL(users, user);  <span class="comment">/* user: pointer to deletee */</span></span><br><span class="line">    <span class="built_in">free</span>(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_all</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">current_user</span>, *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">  HASH_ITER(hh, users, current_user, tmp) &#123;</span><br><span class="line">    HASH_DEL(users, current_user);  <span class="comment">/* delete it (users advances to next) */</span></span><br><span class="line">    <span class="built_in">free</span>(current_user);             <span class="comment">/* free it */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_users</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (s = users; s != <span class="literal">NULL</span>; s = (<span class="keyword">struct</span> my_struct*)(s-&gt;hh.next)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;user id %d: name %s\n&quot;</span>, s-&gt;id, s-&gt;name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">name_sort</span><span class="params">(<span class="keyword">struct</span> my_struct *a, <span class="keyword">struct</span> my_struct *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;name, b-&gt;name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">id_sort</span><span class="params">(<span class="keyword">struct</span> my_struct *a, <span class="keyword">struct</span> my_struct *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a-&gt;id - b-&gt;id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_by_name</span><span class="params">()</span> &#123;</span><br><span class="line">    HASH_SORT(users, name_sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort_by_id</span><span class="params">()</span> &#123;</span><br><span class="line">    HASH_SORT(users, id_sort);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> in[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> id = <span class="number">1</span>, running = <span class="number">1</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">my_struct</span> *<span class="title">s</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> num_users;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (running) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 1. add user\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 2. add/rename user by id\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 3. find user\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 4. delete user\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 5. delete all users\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 6. sort items by name\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 7. sort items by id\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 8. print users\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; 9. count users\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;10. quit\n&quot;</span>);</span><br><span class="line">        gets(in);</span><br><span class="line">        <span class="keyword">switch</span>(atoi(in)) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;name?\n&quot;</span>);</span><br><span class="line">                add_user(id++, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;id?\n&quot;</span>);</span><br><span class="line">                gets(in); id = atoi(in);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;name?\n&quot;</span>);</span><br><span class="line">                add_user(id, gets(in));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;id?\n&quot;</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;user: %s\n&quot;</span>, s ? s-&gt;name : <span class="string">&quot;unknown&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;id?\n&quot;</span>);</span><br><span class="line">                s = find_user(atoi(gets(in)));</span><br><span class="line">                <span class="keyword">if</span> (s) delete_user(s);</span><br><span class="line">                <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;id unknown\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                delete_all();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                sort_by_name();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                sort_by_id();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                print_users();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                num_users = HASH_COUNT(users);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;there are %u users\n&quot;</span>, num_users);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                running = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete_all();  <span class="comment">/* free any structures */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="参考资料">参考资料</span></h2><p><a href="https://troydhanson.github.io/uthash/userguide.html">uthash用户使用指南</a><a href="https://www.cnblogs.com/dongxb/p/14212531.html">uthash简介</a></p>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>421.数组中两个数的最大异或值</title>
      <link href="/2021/05/16/leetcode/421-shu-zu-zhong-liang-ge-shu-de-zui-da-yi-huo-zhi/"/>
      <url>/2021/05/16/leetcode/421-shu-zu-zhong-liang-ge-shu-de-zui-da-yi-huo-zhi/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i]</code> XOR<code>nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code>。 - 要求在<code>O(n)</code>时间内解决这个问题 -限制：<code>1 &lt;= nums.length &lt;= 2 * 10^4</code><code>0 &lt;= nums[i] &lt;= 2^31 - 1</code></p><span id="more"></span><h2><span id="题解">题解</span></h2><p>异或运算的真值表如下 (相同为0，不同为1)，又称为不进位加法：</p><figure><img src="https://i.loli.net/2021/05/16/EYtfh6gJrATMFIQ.png" alt="图"><figcaption aria-hidden="true">图</figcaption></figure><p>要找到最大的数，我们要尽量选择高位异或结果为“1”的，所以我们可以将nums中的数加入一个Trie中，然后每次贪心的进行匹配，找到可以使得当前位为1的节点。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        Node[] node = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> (x &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.node[u] == <span class="literal">null</span>) p.node[u] = <span class="keyword">new</span> <span class="title class_">Node</span>(); </span><br><span class="line">            p = p.node[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (x &gt;&gt; i) &amp; <span class="number">1</span>, b = <span class="number">1</span> - a;</span><br><span class="line">            <span class="keyword">if</span> (p.node[b] != <span class="literal">null</span>) &#123;</span><br><span class="line">                ans |= (b &lt;&lt; i);</span><br><span class="line">                p = p.node[b];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans |= (a &lt;&lt; i);</span><br><span class="line">                p = p.node[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximumXOR</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">            add(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> getVal(i);</span><br><span class="line">            ans = Math.max(ans, i ^ j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="参考资料">参考资料</span></h3><p><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-bmjdg/">【宫水三叶の相信科学系列】详解为何能用「贪心」&amp;「Trie」找「最大异或结果」- 数组中两个数的最大异或值 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 17.21. 直方图的水量</title>
      <link href="/2021/04/26/leetcode/mian-shi-ti-17-21-zhi-fang-tu-de-shui-liang/"/>
      <url>/2021/04/26/leetcode/mian-shi-ti-17-21-zhi-fang-tu-de-shui-liang/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>给定一个直方图(也称柱状图)，假设有人从上面源源不断地倒水，最后直方图能存多少水量?直方图的宽度为1。<img src="https://i.loli.net/2021/04/06/Yyt1qnaTPRZAIhQ.png" alt="LeetCode: 面试题17.21"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: [0,1,0,2,1,0,1,3,2,1,2,1]</span><br><span class="line">输出: 6</span><br></pre></td></tr></table></figure><span id="more"></span><h2><span id="题解">题解</span></h2><p>思路：当前位置能储存的水量取决于左右两边遇到的最大值中的最小值(min(leftTop,rightTop))。</p><p>方法：双指针。一个左指针，一个右指针。左指针小于右指针，当前位置可以存水，大小为leftTop-left，然后右移左指针，更新leftTop。同理，右指针小于左指针，当前位置可以存储rightTop-right的水量，左移右指针，更新rightTop。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>* height, <span class="type">int</span> heightSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heightSize &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;   <span class="comment">// 大小不足3，必定不能存水</span></span><br><span class="line">    <span class="type">int</span> lefttop = <span class="number">0</span>, righttop = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (lefttop+<span class="number">1</span> &lt; heightSize &amp;&amp; height[lefttop+<span class="number">1</span>] &gt;= height[lefttop]) lefttop++;</span><br><span class="line">    <span class="keyword">while</span>(righttop - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; height[righttop<span class="number">-1</span>] &gt;= height[righttop]) righttop--;</span><br><span class="line">    <span class="type">int</span> left = lefttop, right = righttop, capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt;= height[right]) &#123;</span><br><span class="line">            capacity += height[lefttop] - height[left];</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span> (height[left] &gt; height[lefttop]) lefttop = left;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (height[left] &gt; height[right]) &#123;</span><br><span class="line">            capacity += height[righttop] - height[right];</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">if</span> (height[right] &gt; height[righttop]) righttop = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> capacity;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>71. 简化路径</title>
      <link href="/2021/04/08/leetcode/71-jian-hua-lu-jing/"/>
      <url>/2021/04/08/leetcode/71-jian-hua-lu-jing/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>给你一个字符串 path ，表示指向某一文件或目录的Unix 风格绝对路径（以'/' 开头，请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点（..）表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，'//'）都被视为单个斜杠'/' 。对于此问题，任何其他格式的点（例如，'...'）均被视为文件/目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><p>始终以斜杠 '/' 开头。 两个目录名之间必须只有一个斜杠 '/' 。最后一个目录名（如果存在）不能 以 '/' 结尾。此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 '.' 或'..'）。 返回简化后得到的 规范路径 。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。 </span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot; </span><br></pre></td></tr></table></figure><p>提示：</p><p>1 &lt;= path.length &lt;= 3000</p><ul><li>path 由英文字母，数字，'.'，'/' 或 '_' 组成。</li><li>path 是一个有效的 Unix 风格绝对路径。</li></ul></blockquote><h2><span id="题解">题解</span></h2><p>利用栈，分各种情况讨论。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">simplifyPath</span><span class="params">(<span class="type">char</span> * path)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(path);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="literal">NULL</span> || len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span> * simPath = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (len + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (simPath == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>); <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, numOfDots = <span class="number">0</span>, isDir = <span class="number">0</span>;      <span class="comment">// 栈顶下标，&#x27;.&#x27;的数量，当前输入字符是否为路径</span></span><br><span class="line">    <span class="keyword">if</span> (path[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Invalid Input\n&quot;</span>); <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    simPath[<span class="number">0</span>] = path[<span class="number">0</span>];                       <span class="comment">// 第一位为&#x27;/&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;.&#x27;</span>) &#123;                   <span class="comment">// 当前字符为&#x27;.&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (!isDir) numOfDots++;            <span class="comment">// 若当前字符不是路径，&#x27;.&#x27;的数量增加1</span></span><br><span class="line">            simPath[++top] = <span class="string">&#x27;.&#x27;</span>;               <span class="comment">// &#x27;.&#x27;入栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// 当前字符不为&#x27;.&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (path[i] != <span class="string">&#x27;/&#x27;</span>) &#123;               <span class="comment">// 当前字符不为&#x27;/&#x27;</span></span><br><span class="line">                numOfDots = <span class="number">0</span>;                  <span class="comment">// 当前输入为路径，所以&#x27;.&#x27;的数量更新为0</span></span><br><span class="line">                isDir = <span class="number">1</span>;                      <span class="comment">// 当前输入为路径</span></span><br><span class="line">                simPath[++top] = path[i];       <span class="comment">// 当前路径字符入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOfDots == <span class="number">1</span>) &#123;        <span class="comment">// 栈顶为&#x27;.&#x27;</span></span><br><span class="line">                top -= <span class="number">2</span>;                       <span class="comment">// &#x27;/.&#x27;出栈</span></span><br><span class="line">                <span class="keyword">if</span>(top == <span class="number">-1</span>)                   <span class="comment">// 碰到根目录</span></span><br><span class="line">                    simPath[++top] = <span class="string">&#x27;/&#x27;</span>;       <span class="comment">// &#x27;/&#x27;入栈</span></span><br><span class="line">                numOfDots = <span class="number">0</span>;                  <span class="comment">// 重置&#x27;.&#x27;的数量</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numOfDots == <span class="number">2</span>) &#123;        <span class="comment">// 栈顶为&#x27;..&#x27;</span></span><br><span class="line">                top -= <span class="number">3</span>;                       <span class="comment">// 出栈&#x27;/..&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(top == <span class="number">-1</span>)                   <span class="comment">// 碰到根目录</span></span><br><span class="line">                    simPath[++top] = <span class="string">&#x27;/&#x27;</span>;       <span class="comment">// &#x27;/&#x27;入栈</span></span><br><span class="line">                <span class="keyword">while</span>(top &gt;= <span class="number">0</span> &amp;&amp; simPath[top] != <span class="string">&#x27;/&#x27;</span>) top--;   <span class="comment">// 出栈直到遇到下一个&#x27;/&#x27;</span></span><br><span class="line">                numOfDots = <span class="number">0</span>;                  <span class="comment">// 重置&#x27;.&#x27;的数量</span></span><br><span class="line">            &#125;                          </span><br><span class="line">            <span class="keyword">if</span> (path[i] ==<span class="string">&#x27;/&#x27;</span> &amp;&amp; simPath[top] != <span class="string">&#x27;/&#x27;</span>)&#123;<span class="comment">// 当前字符为&#x27;/&#x27;</span></span><br><span class="line">                simPath[++top] = path[i];       <span class="comment">// 栈顶不是&#x27;/&#x27;，入栈&#x27;/&#x27;</span></span><br><span class="line">                isDir = <span class="number">0</span>;                      <span class="comment">// 当前输入非路径文件名称</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (numOfDots == <span class="number">1</span>) top -= <span class="number">2</span>;               <span class="comment">// 处理&#x27;.&#x27;没有被处理的情况</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (numOfDots == <span class="number">2</span>) &#123;</span><br><span class="line">        top -= <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(top &gt;= <span class="number">0</span> &amp;&amp; simPath[top] != <span class="string">&#x27;/&#x27;</span>) top--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">-1</span>) simPath[++top] = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (top &gt; <span class="number">0</span> &amp;&amp; simPath[top] == <span class="string">&#x27;/&#x27;</span>)  top--; <span class="comment">// 最后一个字符为&#x27;/&#x27;      </span></span><br><span class="line">    simPath[++top] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> simPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>81. 搜索旋转排序数组II</title>
      <link href="/2021/04/07/leetcode/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/"/>
      <url>/2021/04/07/leetcode/81-sou-suo-xuan-zhuan-pai-xu-shu-zu-ii/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>已知存在一个按非降序排列的整数数组 nums，数组中的值不必互不相同。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt;nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ...,nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为[4,5,6,6,7,0,1,2,4,4] 。</p><p>给你旋转后的数组nums和一个整数target，请你编写一个函数来判断给定的目标值是否存在于数组中。如果nums 中存在这个目标值 target，则返回 true，否则返回 false。</p><span id="more"></span><p>示例 1：</p><p>输入：nums = [2,5,6,0,0,1,2], target = 0 输出：true 示例 2：</p><p>输入：nums = [2,5,6,0,0,1,2], target = 3 输出：false</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 5000</li><li>-10<sup>4</sup> &lt;= nums[i] &lt;= 10<sup>4</sup></li><li>题目数据保证 nums 在预先未知的某个下标上进行了旋转</li><li>-10<sup>4</sup> &lt;= target &lt;= 10<sup>4</sup></li></ul></blockquote><h2><span id="题解">题解</span></h2><p>思路：利用到数组是排序过的性质，我们可以采用二分法。由于数组是进行旋转过的排序数组所以如果nums[i]&gt;nums[j]，那么i和j一定是处于旋转的下标的两侧的。定义左指针l，右指针r，中间指针mid。</p><ul><li>第一种情况：nums[l]&lt;=nums[mid]。说明l和mid都在旋转下标的左侧（这里有特殊情况待会讨论），如果此时tar在l和mid的中间，那么右指针更新为mid-1；否则，说明在mid和r中间，左指针更新为mid+1。</li><li>第二种情况：nums[l]&gt;nums[mid]。说明l和mid在旋转下标的不同侧，也就是mid和r都在旋转下标的右侧，如果此时tar在mid和r中间，那么左指针更新为mid+1；否则，右指针更新为mid-1。</li><li>特殊情况：考虑相等的情况，如果nums[l]=nums[mid]，我们不一定能保证l和mid在同一侧，因为如果l和r不能保证不相等，如果三者都相等，那么完全可能mid和r都在右侧。对于这种情况，我们排除掉当前l和r，同时向中间移动一位。</li><li>分析：在最坏情况下，数组的所有元素都相同，那么就完全没有用到二分法，时间复杂度为O(n)，空间复杂度为O(1)。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize == <span class="number">0</span>)  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = numsSize - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[l] == nums[mid] &amp;&amp; nums[mid] == nums[r]) &#123;</span><br><span class="line">            ++l;</span><br><span class="line">            --r;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt;= nums[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[numsSize - <span class="number">1</span>]) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说来滑稽，由于这个数组的大小不大，如果采用暴力解法，直接遍历搜索简单明了，得出的结果也还不错,甚至比采用二分法的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numsSize; i++) <span class="keyword">if</span> (nums[i] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>二分法：</p><p>执行用时：8 ms, 在所有 C 提交中击败了55.63%的用户</p><p>内存消耗：5.7 MB, 在所有 C 提交中击败了99.68%的用户</p><p>暴力法：</p><p>执行用时：4 ms, 在所有 C 提交中击败了93.57%的用户</p><p>内存消耗：5.8 MB, 在所有 C 提交中击败了84.89%的用户</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>80. 删除有序数组中的重复项II</title>
      <link href="/2021/04/06/leetcode/80-shan-chu-you-xu-shu-zu-zhong-de-chong-fu-xiang-ii/"/>
      <url>/2021/04/06/leetcode/80-shan-chu-you-xu-shu-zu-zhong-de-chong-fu-xiang-ii/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素最多出现两次 ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1)额外空间的条件下完成。</p><span id="more"></span><p>说明：</p><p>为什么返回数值是整数，但输出的答案是数组呢？</p><p>请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><p>// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 int len =removeDuplicates(nums);</p><p>// 在函数里修改输入数组对于调用者是可见的。 //根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 for(int i = 0; i &lt; len; i++) { print(nums[i]); }</p><p>示例 1：</p><p>输入：nums = [1,1,1,2,2,3] 输出：5, nums = [1,1,2,2,3]解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1,2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。 示例 2：</p><p>输入：nums = [0,0,1,1,1,1,2,3,3] 输出：7, nums = [0,0,1,1,2,3,3]解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0,1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。</p><p>提示：</p><ul><li>1 &lt;= nums.length &lt;= 3 * 104</li><li>-104 &lt;= nums[i] &lt;= 104</li><li>nums 已按升序排列</li></ul></blockquote><h2><span id="题解">题解</span></h2><p>由于这道题数组已经是有序数组，所以很容易想到使用双指针。一个指针从头到尾遍历数组，另一个指针指向当前需要修改的位置。当前数字出现次数如果超过2，那么当前位置不需要修改；未超过2，更改当前需要更改的位置；若当前数字发生变化，更新出现次数和当前位置。时间复杂度O(n)，空间复杂度O(1)，和题目要求一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> currNum = nums[<span class="number">0</span>], freq = <span class="number">1</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; numsSize; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currNum == nums[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++freq &lt;= <span class="number">2</span>) nums[++len] = nums[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            currNum = nums[i];</span><br><span class="line">            freq = <span class="number">1</span>;</span><br><span class="line">            nums[++len] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上方法还可以进行改进。如果原本的数组长度小于等于2，最多就两个元素，不需要更改。此外，这种方法我们需要一个额外的变量来计算元素出现的次数，实际上我们已经知道一个数字最多出现两次，所以如果当前访问位置和需要修改的当前位置前两个位置相同的话，那么说明当前的数字已经出现了多次，则直接移动到下一位置即可；否则需要修改的位置修改为当前遍历到的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (numsSize &lt;= <span class="number">2</span>) <span class="keyword">return</span> numsSize;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">2</span>, curr = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (; curr &lt; numsSize; curr++)</span><br><span class="line">        <span class="keyword">if</span> (nums[len<span class="number">-2</span>] != nums[curr])</span><br><span class="line">            nums[len++] = nums[curr];</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5706. 句子相似性III（第49场双周赛）</title>
      <link href="/2021/04/04/leetcode/5706-ju-zi-xiang-si-xing-iii/"/>
      <url>/2021/04/04/leetcode/5706-ju-zi-xiang-si-xing-iii/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>一个句子是由一些单词与它们之间的单个空格组成，且句子的开头和结尾没有多余空格。比方说，<code>"Hello World"</code>，<code>"HELLO"</code> ，<code>"hello world hello world"</code>都是句子。每个单词都 <strong>只</strong> 包含大写和小写英文字母。</p><p>如果两个句子 <code>sentence1</code> 和 <code>sentence2</code>，可以通过往其中一个句子插入一个任意的句子（<strong>可以是空句子</strong>）而得到另一个句子，那么我们称这两个句子是<strong>相似的</strong>。比方说，<code>sentence1 = "Hello my name is Jane"</code> 且<code>sentence2 = "Hello Jane"</code> ，我们可以往<code>sentence2</code> 中 <code>"Hello"</code> 和 <code>"Jane"</code>之间插入 <code>"my name is"</code> 得到 <code>sentence1</code> 。</p><p>给你两个句子 <code>sentence1</code> 和 <code>sentence2</code> ，如果<code>sentence1</code> 和 <code>sentence2</code> 是相似的，请你返回<code>true</code> ，否则返回 <code>false</code> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;My name is Haley&quot;, sentence2 = &quot;My Haley&quot;</span><br><span class="line">&gt;输出：true</span><br><span class="line">&gt;解释：可以往 sentence2 中 &quot;My&quot; 和 &quot;Haley&quot; 之间插入 &quot;name is&quot; ，得到 sentence1 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;of&quot;, sentence2 = &quot;A lot of words&quot;</span><br><span class="line">&gt;输出：false</span><br><span class="line">&gt;解释：没法往这两个句子中的一个句子只插入一个句子就得到另一个句子。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;Eating right now&quot;, sentence2 = &quot;Eating&quot;</span><br><span class="line">&gt;输出：true</span><br><span class="line">&gt;解释：可以往 sentence2 的结尾插入 &quot;right now&quot; 得到 sentence1 。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;输入：sentence1 = &quot;Luky&quot;, sentence2 = &quot;Lucccky&quot;</span><br><span class="line">&gt;输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= sentence1.length, sentence2.length &lt;= 100</code></li><li><code>sentence1</code> 和 <code>sentence2</code>都只包含大小写英文字母和空格。</li><li><code>sentence1</code> 和 <code>sentence2</code>中的单词都只由单个空格隔开。</li></ul></blockquote><h2><span id="题解">题解</span></h2><p>本题我采用了动态规划的思路。果然还是很不熟练，找状态转移方程想了好久，想出来的还是感觉很笨的办法，果然还是得加强练习。</p><p>思路：<code>dp[i, j]</code>表示sentence1的前i个和sentence2的前j个word能否经过一次插入获得。分别考虑两个句子当前的word是否是可以插入另一个sentence获得相同的sentence。情况如下：</p><ol type="1"><li>如果sentence1前<code>i-1</code>个word和sentence2前j个word可以通过一次插入相等，并且之前插入的word在sentence1中并且还可以继续插入，那么就可以继续在sentence1中插入，我们记为1。</li><li>如果sentence1前i个word和sentence2前j-1个word可以通过一次插入相等，并且之前插入的word在sentence2中并且还可以继续插入，那么就可以继续在sentence2中插入，我们记为2。</li><li>以上两种情况都不符合，如果sentence1第i个word和sentence2第j个word一致，那么我们只需要考虑sentence1前i-1个word和sentence2前j-1个word是否可以通过一次插入相等。如果之前是在继续插入的，那么我们现在就要终止插入，记为3，否则dp[i,j]=dp[i-1,j-1]。（这里我们已经排除了虽然当前word相等但是可以把当前的word当成插入的情况：比如sentence1=”ab c“, sentence2="a b g b c"中sentence2中的"g b"是插入的，而sentence1中也存在b）</li><li>剩下的情况就是我们无法插入一个sentence使两组sentence相等，记为4</li></ol><p>代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先将sentence转化为word数组</span></span><br><span class="line"><span class="type">char</span>** <span class="title function_">sentenceToWord</span><span class="params">(<span class="type">char</span> * sentence, <span class="type">int</span> *wordlen)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sen_len = <span class="built_in">strlen</span>(sentence);</span><br><span class="line">    <span class="keyword">if</span> (sen_len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">char</span>** word = (<span class="type">char</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>*) * sen_len);</span><br><span class="line">    <span class="type">int</span> wordIdx = <span class="number">0</span>, i = <span class="number">0</span>, charIdx = <span class="number">0</span>;</span><br><span class="line">    word[wordIdx] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * (sen_len+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; sen_len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sentence[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            word[wordIdx][charIdx] = <span class="string">&#x27;\0&#x27;</span>; </span><br><span class="line">            word[++wordIdx] = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>) * sen_len);</span><br><span class="line">            charIdx = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            word[wordIdx][charIdx++] = sentence[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    word[wordIdx][charIdx] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    *wordlen = wordIdx + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> word;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">areSentencesSimilar</span><span class="params">(<span class="type">char</span> * sentence1, <span class="type">char</span> * sentence2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len1, len2;</span><br><span class="line">    <span class="type">char</span>** word1 = sentenceToWord(sentence1, &amp;len1);</span><br><span class="line">    <span class="type">char</span>** word2 = sentenceToWord(sentence2, &amp;len2);</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> ** dp = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*) * (len1+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= len1; i++) dp[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * (len2 + <span class="number">1</span>));</span><br><span class="line">    <span class="comment">// 0代表还没有插入</span></span><br><span class="line">    <span class="comment">// 1代表i正在插入</span></span><br><span class="line">    <span class="comment">// 2代表j正在插入</span></span><br><span class="line">    <span class="comment">// 3代表已经插入</span></span><br><span class="line">    <span class="comment">// 4代表无法插入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len2; i++) dp[<span class="number">0</span>][i] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j] == <span class="number">1</span> || dp[i<span class="number">-1</span>][j] == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j<span class="number">-1</span>] == <span class="number">2</span> || dp[i][j<span class="number">-1</span>] == <span class="number">0</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(word1[i<span class="number">-1</span>], word2[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">1</span> || dp[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="number">2</span>) dp[i][j] = <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2] != <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 盛最多水的容器</title>
      <link href="/2021/04/03/leetcode/11-sheng-zui-duo-shui-de-rong-qi/"/>
      <url>/2021/04/03/leetcode/11-sheng-zui-duo-shui-de-rong-qi/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai)。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>说明：你不能倾斜容器。</p><span id="more"></span><p>示例 1：</p><figure><img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><p>输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组[1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为49。</p><p>示例 2：</p><p>输入：height = [1,1] 输出：1</p><p>示例 3：</p><p>输入：height = [4,3,2,1,4] 输出：16</p><p>示例 4：</p><p>输入：height = [1,2,1] 输出：2</p><p>提示：</p><ul><li>n = height.length</li><li>2 &lt;= n &lt;= 3 * 104</li><li>0 &lt;= height[i] &lt;= 3 * 104</li></ul></blockquote><h2><span id="解法双指针">解法：双指针</span></h2><p>定义两个左右指针，获取其中较小的指针，将较小指针向中间移动，重新获取两个指针中的较小者，然后比较当前区域大小与移动后区域大小并进行赋值。重复以上操作直到两个指针相遇。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span> *height, <span class="type">int</span> heightSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (heightSize == <span class="number">0</span> &amp;&amp; heightSize == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = heightSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> min = height[left] &lt; height[right] ? left : right;</span><br><span class="line">    <span class="type">int</span> area = height[min] * (right - left);</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &lt;= left ) left++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (min &gt;= right ) right--;</span><br><span class="line">        min = height[left] &lt; height[right] ? left : right;</span><br><span class="line">        <span class="keyword">if</span> (area &lt; height[min] * (right - left))</span><br><span class="line">            area = height[min] * (right - left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><a href="https://leetcode-cn.com/problems/container-with-most-water/">11.盛最多水的容器 - 力扣（LeetCode） (leetcode-cn.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1143. 最长公共子序列</title>
      <link href="/2021/04/03/leetcode/1143-zui-chang-gong-gong-zi-xu-lie/"/>
      <url>/2021/04/03/leetcode/1143-zui-chang-gong-gong-zi-xu-lie/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><blockquote><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。如果不存在公共子序列 ，返回 0 。</p><p>一个字符串的子序列是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><p>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><span id="more"></span><p>示例 1：</p><p>输入：text1 = "abcde", text2 = "ace" 输出：3<br>解释：最长公共子序列是 "ace" ，它的长度为 3 。 示例 2：</p><p>输入：text1 = "abc", text2 = "abc" 输出：3 解释：最长公共子序列是"abc" ，它的长度为 3 。 示例 3：</p><p>输入：text1 = "abc", text2 = "def" 输出：0解释：两个字符串没有公共子序列，返回 0 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul></blockquote><h2><span id="题解">题解</span></h2><p>经典的动态规划。dp[i][j]表示text1的前i个字符和text2的前j个字符的最长公共子序列个数。当我们移动到(i,j)这个位置的时候，分为以下两种情况：</p><ul><li>text1[i] == text2[j]。此时dp[i][j]=dp[i-1][j-1]+1;</li><li>text1[i] != text2[j]。此时dp[i][j]=max(dp[i-1][j], dp[i][j-1])</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 动态规划 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(<span class="type">char</span> * text1, <span class="type">char</span> * text2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len1 = <span class="built_in">strlen</span>(text1), len2 = <span class="built_in">strlen</span>(text2);</span><br><span class="line">    <span class="type">int</span> dp[<span class="number">1000</span>][<span class="number">1000</span>];</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len1; i++) dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;= len2; i++) dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] &gt; dp[i][j<span class="number">-1</span>] ? dp[i<span class="number">-1</span>][j] : dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2><span id="注意">注意</span></h2><ul><li>在代码中尽量不要使用分配内存的方法，内存消耗明显增加。</li><li>调用函数也会增加运行的时间，如果定义max函数，运行时间会变长。</li><li>初始化dp表的时候，可以简单通过<code>int dp[1000][1000] = &#123;0&#125;;</code>来进行初始化，但是这样会初始化一些不需要初始化的位置，运行时间会增加。所以只需要通过遍历初始化第一行和第一列即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. 正则表达式匹配</title>
      <link href="/2021/04/01/leetcode/10-zheng-ze-biao-da-shi-pi-pei/"/>
      <url>/2021/04/01/leetcode/10-zheng-ze-biao-da-shi-pi-pei/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*'的正则表达式匹配。</p><ul><li>'.' 匹配任意单个字符</li><li>'*' 匹配零个或多个前面的那一个元素。所谓匹配，是要涵盖整个字符串s的，而不是部分字符串。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">示例 4：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27;为 0 个, &#x27;a&#x27;被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><span id="more"></span><h2><span id="题解">题解</span></h2><blockquote><h3><span id="解析">解析</span></h3><p>使用动态规划的方法进行解题，分为两种情况：首先是非*的情况，这种情况下我们需要考虑s和p当前字符是否匹配，很容易得出状态转移方程。然后是p为*，也可以分为两种情况，一种是s的当前字符与p的前一个字符不匹配，那么*就匹配一个字符，另一种是s的当前字符可以和p的前一个字符进行匹配，说明*可以匹配多个字符，两种情况</p><ul><li>匹配 s末尾的一个字符，将该字符扔掉，而该组合还可以继续进行匹配；</li><li>不匹配字符，将该组合扔掉，不再进行匹配。</li></ul><figure><img src="https://raw.githubusercontent.com/Lucas-hao/Picgo-Picture/master/img/image-20220227143444739.png" alt="image-20220227143444739"><figcaption aria-hidden="true">image-20220227143444739</figcaption></figure></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">charMatch</span><span class="params">(<span class="type">char</span> s, <span class="type">char</span> p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;.&#x27;</span> || s == p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用方法：动态规划 */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">isMatch</span><span class="params">(<span class="type">char</span> * s, <span class="type">char</span> * p)</span>&#123;</span><br><span class="line">    <span class="type">int</span> height = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> width = <span class="built_in">strlen</span>(p);</span><br><span class="line">    <span class="type">bool</span>** table = (<span class="type">bool</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>*) * (height+<span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (table == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= height; i++) &#123;</span><br><span class="line">        table[i] = (<span class="type">bool</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bool</span>) * (width+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (table[i] == <span class="literal">NULL</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;Error\n&quot;</span>); <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= height; i++) table[i][<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= width; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[i<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; i &gt;= <span class="number">2</span>) table[<span class="number">0</span>][i] = table[<span class="number">0</span>][i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">else</span> table[<span class="number">0</span>][i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= height; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= width; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">2</span> &amp;&amp; p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> ) &#123;</span><br><span class="line">                <span class="keyword">if</span> (charMatch(s[i<span class="number">-1</span>], p[j<span class="number">-2</span>]))</span><br><span class="line">                    table[i][j] = table[i<span class="number">-1</span>][j] || table[i][j<span class="number">-2</span>];</span><br><span class="line">                <span class="keyword">else</span> table[i][j] = table[i][j<span class="number">-2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charMatch(s[i<span class="number">-1</span>], p[j<span class="number">-1</span>])) &#123;</span><br><span class="line">                table[i][j] = table[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                table[i][j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table[height][width];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来源：<a href="https://leetcode-cn.com/problems/regular-expression-matching/">LeetCode-10</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>61. 旋转链表</title>
      <link href="/2021/03/27/leetcode/61-xuan-zhuan-lian-biao/"/>
      <url>/2021/03/27/leetcode/61-xuan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<h2><span id="题目描述">题目描述</span></h2><p>给你一个链表的头节点 <code>head</code>，旋转链表，将链表每个节点向右移动 <code>k</code> 个位置。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[4,5,1,2,3]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：head = [0,1,2], k = 4</span><br><span class="line">输出：[2,0,1]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">提示：</span><br><span class="line">链表中节点的数目在范围 [0, 500] 内</span><br><span class="line">-100 &lt;= Node.val &lt;= 100</span><br><span class="line">0 &lt;= k &lt;= 2 * 109</span><br></pre></td></tr></table></figure><h2><span id="题解">题解</span></h2><p>本题不难，只需要找到newHead和newTail的位置，将原来的tail和原来的head连接，返回newHead就可以了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">rotateRight</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// Exception: empty list</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">preHead</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newTail</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">preTail</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> ListSize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// get the total size of the list as well as the previous tail of the list</span></span><br><span class="line">    <span class="keyword">for</span> (; preTail-&gt;next != <span class="literal">NULL</span>; preTail = preTail-&gt;next, ListSize++);</span><br><span class="line">    k %= ListSize;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> head;</span><br><span class="line">    <span class="comment">// get the new tail of the new list</span></span><br><span class="line">    <span class="comment">// new head of the list is the successor of the new tail</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ListSize - k - <span class="number">1</span>; i++, newTail = newTail-&gt;next);</span><br><span class="line">    newHead = newTail-&gt;next;</span><br><span class="line">    newTail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// connect the previous tail to the previous head;</span></span><br><span class="line">    preTail-&gt;next = preHead;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏概率模型</title>
      <link href="/2020/12/26/other/you-xi-chou-qia-mo-xing-fen-xi/"/>
      <url>/2020/12/26/other/you-xi-chou-qia-mo-xing-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>目前的中国游戏市场，最热门的莫过于免费抽卡手游。游戏厂商为了盈利，设计出有不同规则的卡池，让玩家抽卡获取稀有的人物和武器。这一机制吸引了很多玩家，首先因为手游是免费的，入手门槛较低，其次很多人喜欢抽卡获取角色和武器的成就感。为了更吸引玩家，游戏策划就得设计出能够让大部分玩家，无论是欧皇还是非酋满意的抽卡机制。本文将简要分析目前游戏厂商可能使用的抽卡机制（仅属于个人猜想加一些网上的资料）。</p><span id="more"></span><h3><span id="抽卡机制的大致分类">抽卡机制的大致分类</span></h3><ol type="1"><li>最简单的抽卡模型就是每次抽卡的概率都是固定的，也就是说每次抽卡的概率都是<span class="math inline">\(p\)</span>,我们可以称之为纯随机。那么玩家第<span class="math inline">\(n\)</span>次抽中的随机变量分布就是一个几何分布。这种抽卡模型很明显对于非酋非常不友好，理论上可能存在抽了很多很多次仍然没有抽中的人存在。所以纯随机模型在抽卡游戏中是不会使用的。</li><li>对应于纯随机的，我们可以称之为伪随机（注意这里的伪随机和计算机随机数概念中的伪随机不是一个东西）。伪随机就是说每次抽卡的概率都是是会进行改变的。下面就重点介绍几种可能的伪随机模型。</li></ol><h3><span id="伪随机模型">伪随机模型</span></h3><ul><li><h4><span id="十连保底">十连保底</span></h4><p>十连保底应该是我们在游戏中最常见到的概率模型。如果连抽十次，前九次都没有抽中的话，那么第十次就必定会抽中。这种概率模型会导致很多玩家都是依靠十连保底，并且概率质量函数图像会在第十次突然上升，显得不均匀。</p><p>例如，如果我们设定抽到A卡的概率为0.1，那么我们得出的该概率质量函数和累积分布函数的图像就是下图。可以算出数学期望为6.5，并且大约60%的玩家在前9次抽到，而所谓的非酋也就是触发保底的玩家占到了40%。</p><p><img src="https://i.loli.net/2021/03/27/i13cMAZSkxavU24.png"></p><p>如果我们用程序模拟10000次在这种概率模型下的抽卡，我们可以得出下面的分布。从图中可以看出，大部分玩家抽100次会得到16-20个想要得到的。</p><p><img src="https://i.loli.net/2021/03/27/MW9EINoerzX2lyO.png"></p><p>这种十连保底的模型一般用于四星角色或者武器。四星虽然没有五星稀有，但是也是需要一定的保障以确保玩家甚至连四星都抽不到。</p></li><li><h4><span id="概率增加模型">概率增加模型</span></h4><p>那么对于更加稀有的五星角色和武器来说，十连保底肯定就显得太过容易了。这个时候策划一般希望玩家差不多抽几十发可以抽中一个，所以就需要比如100抽保底这样的机制。但是如果这个时候继续采用以上的前面的概率都不变，那么很容易想到这样子的话大部分玩家都会是100发保底...所以就需要调整该概率。</p><p>首先，我们设定一个初始概率<span class="math inline">\(p\)</span>，然后如果没有抽中，那么下一次抽卡概率就给他一个增量<span class="math inline">\(\alpha\)</span>，如果抽中，那么就回归初始概率。所以，第X次抽中的概率就是<span class="math inline">\(p(x)=p+\alpha\times(x-1)\)</span>，概率质量函数</p><p><span class="math display">\[P(x) =\Pi^{x-1}_{i=1}\lbrack(1-p(i))\rbrack\times p(x)=\Pi^{x-1}_{i=1}[(1-p-\alpha\times(i-1))]\times(p+\alpha\times(x-1))\]</span></p><p>我们设定<span class="math inline">\(p=0.01,\alpha=0.01\)</span>，然后画出图像之后发现，这个图像居然很像是一个正态分布的图像，所以顺便把正态分布的图像画了出来对比，虽然也不知道为什么这两张图这么像。</p></li></ul><p><img src="https://i.loli.net/2021/03/27/3mABlhKoPTYfWyQ.png"></p><p>在这个概率模型下，由于100次的时候<span class="math inline">\(p(100)=0.01+99\times0.1=1\)</span>，所以实现了一个100抽保底的效果。但是策划希望的是100抽保底，并且大部分人应该是在五六十抽的时候抽到的，而在这个模型中，超过90%的人在前二十抽就抽到了，这显然不符合预期。所以在这个模型的基础上，我们需要进行相应的调整，让模型的最高点向右偏移。我们由此可以使用一下模型：前50次抽卡概率固定，后50次抽卡使用上面的模型，每次抽卡概率增加。这样我们得出的该概率质量函数就是<span class="math display">\[  p(x)=    \begin{cases}    p, &amp; x&lt;50 \\\\    p+\alpha(x-50), &amp;x&gt;=50    \end{cases}\]</span></p><p>和上面一样，如果需要满足100抽保底的话，让<span class="math inline">\(p=0.02,\alpha=0.02\)</span>。其概率质量函数和累积分布函数图像如下：</p><figure><img src="https://i.loli.net/2021/03/27/uxRhTpL34nm21GC.png" alt="拓展模型模拟结果"><figcaption aria-hidden="true">拓展模型模拟结果</figcaption></figure><p>这张图我认为说可以用作五星的概率模型了。70发之前大部分人都能够抽到，并且集中在40发到70发，占了43.69%。这也可以视作游戏玩家口中的“低保”。</p><p>我们使用上面的模型模拟10000次100连抽，得到的结果如下：</p><figure><img src="https://i.loli.net/2021/03/27/uxRhTpL34nm21GC.png" alt="拓展模型模拟结果"><figcaption aria-hidden="true">拓展模型模拟结果</figcaption></figure><p>​这个结果个人认为就非常像真实游戏中的结果了，大部分人都只能够抽到1-2发，并且很多人都是依靠低保的（这很真实）</p><hr><h3><span id="参考资料">参考资料</span></h3><p><a href="https://www.40407.com/zixun/7986.html">明日方舟抽卡概率和保底机制研</a><a href="https://www.jianshu.com/p/031e53e8553c">游戏抽奖概率模型</a></p>]]></content>
      
      
      <categories>
          
          <category> Other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言实现全排列</title>
      <link href="/2020/12/25/algorithms/c-yu-yan-shi-xian-quan-pai-lie/"/>
      <url>/2020/12/25/algorithms/c-yu-yan-shi-xian-quan-pai-lie/</url>
      
        <content type="html"><![CDATA[<p>使用方法：回溯法</p><blockquote><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯<a href="https://baike.baidu.com/item/条件/1783021">条件</a>的某个<a href="https://baike.baidu.com/item/状态/33204">状态</a>的点称为“回溯点”。——百度百科</p></blockquote><span id="more"></span><p>全排列回溯的基本思想：对当前位置依次进行与后面所有位置的一个交换，然后对交换后的当前位置之后的元素进行一个全排列，全排列完毕后，进行回溯：将当前位置与之前交换的位置重新调换，形成原来的排列，然后继续进行下一次交换。</p><p>比如我们想要对<code>[1, 2, 3, 4, 5]</code>进行排列，首先确定第一位数，可以是1，2， 3 ， 4，5中任意一个，下图中我们与3进行交换，那么交换后的后四个数就是<code>[2, 1, 4, 5]</code>，然后对这个数组进行全排列(递归)，最后回溯之后就会回到<code>[1, 2, 3, 4, 5]</code>（每次排列都会回溯，所以最外层回溯的时候的排列和起初一定是一样的），接下来把4作为首位，需要排列的数就是<code>[2, 3, 1, 5]</code>，依次类推。</p><figure><img src="https://i.loli.net/2021/04/06/hsI6Vv9DzgGatBM.png" alt="image-20210406142817183"><figcaption aria-hidden="true">image-20210406142817183</figcaption></figure><p>全部代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">permute</span><span class="params">(<span class="type">int</span> *<span class="built_in">list</span>, <span class="type">int</span> begin, <span class="type">int</span> size)</span>; <span class="comment">// 实现全排列的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span>; <span class="comment">// 交换数组中两个数的值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>; <span class="comment">// 记录全排列的次数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">list</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input the size of the number list: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">list</span> = (<span class="type">int</span>*)<span class="built_in">calloc</span>(n, <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态数组</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input the number list:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;<span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    permute(<span class="built_in">list</span>, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The total number of permutation is %d&quot;</span>, num);</span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">list</span>); <span class="comment">// 释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">permute</span><span class="params">(<span class="type">int</span> *<span class="built_in">list</span>, <span class="type">int</span> begin, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (begin &gt;= size) &#123;</span><br><span class="line">        <span class="comment">// a permutation is found</span></span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = begin; k &lt; size; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (k != begin) swap(&amp;<span class="built_in">list</span>[begin], &amp;<span class="built_in">list</span>[k]);</span><br><span class="line">        permute(<span class="built_in">list</span>, begin+<span class="number">1</span>, size);</span><br><span class="line">        <span class="keyword">if</span> (k != begin) swap(&amp;<span class="built_in">list</span>[begin], &amp;<span class="built_in">list</span>[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
